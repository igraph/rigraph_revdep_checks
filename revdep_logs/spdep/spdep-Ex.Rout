
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "spdep"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "spdep-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('spdep')
Loading required package: sp
Loading required package: Matrix
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("EBImoran.mc")
> ### * EBImoran.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: EBImoran.mc
> ### Title: Permutation test for empirical Bayes index
> ### Aliases: EBImoran.mc EBImoran
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(nc.sids)

nc.sds> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

nc.sds> nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],
nc.sds+   ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

nc.sds> rn <- sapply(slot(nc.sids, "polygons"), function(x) slot(x, "ID"))

nc.sds> ncCC89_nb <- read.gal(system.file("etc/weights/ncCC89.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ncCR85_nb <- read.gal(system.file("etc/weights/ncCR85.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ## Not run: 
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCR85_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCC89_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ## End(Not run)
nc.sds> 
nc.sds> 
nc.sds> 
> EBImoran.mc(nc.sids$SID74, nc.sids$BIR74,
+  nb2listw(ncCC89_nb, style="B", zero.policy=TRUE), nsim=999, zero.policy=TRUE)

	Monte-Carlo simulation of Empirical Bayes Index

data:  cases: nc.sids$SID74, risk population: nc.sids$BIR74
weights: nb2listw(ncCC89_nb, style = "B", zero.policy = TRUE)
number of simulations + 1: 1000

statistic = 0.25396, observed rank = 1000, p-value = 0.001
alternative hypothesis: greater

> sids.p <- nc.sids$SID74 / nc.sids$BIR74
> moran.mc(sids.p, nb2listw(ncCC89_nb, style="B", zero.policy=TRUE),
+  nsim=999, zero.policy=TRUE)

	Monte-Carlo simulation of Moran's I

data:  sids.p 
weights: nb2listw(ncCC89_nb, style = "B", zero.policy = TRUE)  
number of simulations + 1: 1000 

statistic = 0.20904, observed rank = 999, p-value = 0.001
alternative hypothesis: greater

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("EBImoran.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("EBest")
> ### * EBest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: EBest
> ### Title: Global Empirical Bayes estimator
> ### Aliases: EBest
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(auckland)

acklnd> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

acklnd> auckland <- readShapePoly(system.file("etc/shapes/auckland.shp",
acklnd+  package="spdep")[1])

acklnd> auckland.nb <- poly2nb(auckland)
> res <- EBest(auckland$M77_85, 9*auckland$Und5_81)
> attr(res, "parameters")
$a
[1] 7.284173e-07

$b
[1] 0.002633436

> cols <- grey(6:2/7)
> brks <- c(-Inf,2,2.5,3,3.5,Inf)
> plot(auckland, col=cols[findInterval(res$estmm*1000, brks, all.inside=TRUE)])
> legend("bottomleft", fill=cols, legend=leglabs(brks), bty="n")
> title(main="Global moment estimator of infant mortality per 1000 per year")
> data(huddersfield)
> res <- EBest(huddersfield$cases, huddersfield$total, family="binomial")
> round(res[,1:2],4)*100
     raw estmm
1  42.86 34.44
2  28.95 29.56
3  28.31 28.94
4  21.43 28.93
5  33.33 30.72
6  30.86 30.43
7  33.70 31.85
8  45.61 35.93
9  26.67 28.95
10 29.41 29.95
11 27.76 28.36
12 33.75 31.75
13 32.67 31.84
14 22.91 25.36
15 34.21 32.33
16 33.77 31.72
17 29.09 29.69
18 15.87 24.36
19 40.91 32.11
20 40.00 31.01
21 28.79 29.53
22 38.89 31.47
23 28.32 29.10
24 33.33 31.44
25 13.95 22.36
26 33.77 31.72
27 31.58 30.31
28 33.33 30.42
29 26.67 28.26
30 63.64 33.57
31 34.38 32.24
32 20.00 27.62
33 19.15 24.60
34 25.53 28.54
35 24.14 27.79
36 44.00 32.98
37 25.33 27.95
38 18.18 26.96
39 31.78 30.97
40 32.20 30.88
41 26.19 28.23
42 19.05 26.65
43 16.67 26.81
44 20.00 28.66
45 32.99 31.54
46 50.00 31.97
47 37.21 32.30
48 32.79 31.13
49 38.89 31.47
50 25.00 27.26
51 26.03 28.29
52 30.43 30.18
53 19.75 25.28
54 50.00 31.61
55 21.62 27.67
56 22.22 27.88
57 36.36 30.71
58 31.25 30.22
59  0.00 29.73
60 29.41 29.95
61 31.16 30.71
62 33.33 30.58
63 33.87 32.22
64 30.00 30.04
65 30.34 30.19
66 40.74 35.00
67 46.43 38.96
68 34.21 31.91
69 24.26 26.10
70 29.41 29.75
71 47.17 39.13
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("EBest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("EBlocal")
> ### * EBlocal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: EBlocal
> ### Title: Local Empirical Bayes estimator
> ### Aliases: EBlocal
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(auckland)

acklnd> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

acklnd> auckland <- readShapePoly(system.file("etc/shapes/auckland.shp",
acklnd+  package="spdep")[1])

acklnd> auckland.nb <- poly2nb(auckland)
> res <- EBlocal(auckland$M77_85,  9*auckland$Und5_81, auckland.nb)
> brks <- c(-Inf,2,2.5,3,3.5,Inf)
> cols <- grey(6:2/7)
> plot(auckland, col=cols[findInterval(res$est*1000, brks, all.inside=TRUE)])
> legend("bottomleft", fill=cols, legend=leglabs(brks), bty="n")
> title(main="Local moment estimator of infant mortality per 1000 per year")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("EBlocal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("GMerrorsar")
> ### * GMerrorsar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GMerrorsar
> ### Title: Spatial simultaneous autoregressive error model estimation by
> ###   GMM
> ### Aliases: GMerrorsar residuals.gmsar deviance.gmsar coef.gmsar
> ###   fitted.gmsar print.gmsar summary.gmsar print.summary.gmsar
> ###   GMargminImage
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"), method="eigen")
> summary(COL.errW.eig, Hausman=TRUE)

Call:
errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), method = "eigen")

Residuals:
      Min        1Q    Median        3Q       Max 
-34.81174  -6.44031  -0.72142   7.61476  23.33626 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 59.893219   5.366163 11.1613 < 2.2e-16
INC         -0.941312   0.330569 -2.8476 0.0044057
HOVAL       -0.302250   0.090476 -3.3407 0.0008358

Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945
Asymptotic standard error: 0.13387
    z-value: 4.1966, p-value: 2.7098e-05
Wald statistic: 17.611, p-value: 2.7098e-05

Log likelihood: -183.3805 for error model
ML residual variance (sigma squared): 95.575, (sigma: 9.7762)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 376.76, (AIC for lm: 382.75)
Hausman test: 4.902, df: 3, p-value: 0.17911

> COL.errW.GM <- GMerrorsar(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"), returnHcov=TRUE)
> summary(COL.errW.GM, Hausman=TRUE)

Call:
GMerrorsar(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), returnHcov = TRUE)

Residuals:
     Min       1Q   Median       3Q      Max 
-30.5432  -6.5553  -2.1921  10.0553  28.7497 

Type: GM SAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 62.513752   5.121339  12.207 < 2.2e-16
INC         -1.128283   0.339745  -3.321  0.000897
HOVAL       -0.296957   0.095699  -3.103  0.001915

Lambda: 0.40196 (standard error): 0.42334 (z-value): 0.94948
Residual variance (sigma squared): 106.64, (sigma: 10.327)
GM argmin sigma squared: 106.36
Number of observations: 49 
Number of parameters estimated: 5 
Hausman test: 6.6406, df: 3, p-value: 0.08428

> aa <- GMargminImage(COL.errW.GM)
> levs <- quantile(aa$z, seq(0, 1, 1/12))
> image(aa, breaks=levs, xlab="lambda", ylab="s2")
> points(COL.errW.GM$lambda, COL.errW.GM$s2, pch=3, lwd=2)
> contour(aa, levels=signif(levs, 4), add=TRUE)
> COL.errW.GM1 <- GMerrorsar(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"))
> summary(COL.errW.GM1)

Call:
GMerrorsar(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"))

Residuals:
     Min       1Q   Median       3Q      Max 
-30.5432  -6.5553  -2.1921  10.0553  28.7497 

Type: GM SAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 62.513752   5.121339  12.207 < 2.2e-16
INC         -1.128283   0.339745  -3.321  0.000897
HOVAL       -0.296957   0.095699  -3.103  0.001915

Lambda: 0.40196 (standard error): 0.42334 (z-value): 0.94948
Residual variance (sigma squared): 106.64, (sigma: 10.327)
GM argmin sigma squared: 106.36
Number of observations: 49 
Number of parameters estimated: 5 

> example(NY_data)

NY_dat> ## NY leukemia
NY_dat> library(foreign)

NY_dat> nydata <- read.dbf(system.file("etc/misc/nydata.dbf", package="spdep")[1])

NY_dat> coordinates(nydata) <- c("X", "Y")

NY_dat> nyadjmat <- as.matrix(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1])[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> ID <- as.character(names(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1]))[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10))
[1] TRUE

NY_dat> nyadjlw <- mat2listw(nyadjmat, as.character(nydata$AREAKEY))

NY_dat> listw_NY <- nb2listw(nyadjlw$neighbours, style="B")
> esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
+  listw=listw_NY, family="SAR", method="eigen")
> summary(esar1f)

Call: 
spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata, 
    listw = listw_NY, family = "SAR", method = "eigen")

Residuals:
     Min       1Q   Median       3Q      Max 
-1.56754 -0.38239 -0.02643  0.33109  4.01219 

Coefficients: 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.618193   0.176784 -3.4969 0.0004707
PEXPOSURE    0.071014   0.042051  1.6888 0.0912635
PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09
PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930

Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026 
Numerical Hessian standard error of lambda: 0.017199 

Log likelihood: -276.1069 
ML residual variance (sigma squared): 0.41388, (sigma: 0.64333)
Number of observations: 281 
Number of parameters estimated: 6 
AIC: 564.21

> esar1gm <- GMerrorsar(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
+  data=nydata, listw=listw_NY)
> summary(esar1gm)

Call:GMerrorsar(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, 
    data = nydata, listw = listw_NY)

Residuals:
      Min        1Q    Median        3Q       Max 
-1.641411 -0.396370 -0.026618  0.341740  4.204264 

Type: GM SAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.604364   0.174576 -3.4619 0.0005364
PEXPOSURE    0.067902   0.041164  1.6496 0.0990337
PCTAGE65P    3.775308   0.622965  6.0602 1.359e-09
PCTOWNHOME  -0.437545   0.188906 -2.3162 0.0205468

Lambda: 0.03605 (standard error): 0.2022 (z-value): 0.17829
Residual variance (sigma squared): 0.41585, (sigma: 0.64487)
GM argmin sigma squared: 0.45141
Number of observations: 281 
Number of parameters estimated: 6 

> esar1gm1 <- GMerrorsar(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
+  data=nydata, listw=listw_NY, method="Nelder-Mead")
> summary(esar1gm1)

Call:GMerrorsar(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, 
    data = nydata, listw = listw_NY, method = "Nelder-Mead")

Residuals:
      Min        1Q    Median        3Q       Max 
-1.641390 -0.396374 -0.026616  0.341745  4.204277 

Type: GM SAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.604384   0.174580 -3.4619 0.0005363
PEXPOSURE    0.067907   0.041165  1.6496 0.0990225
PCTAGE65P    3.775275   0.622969  6.0601  1.36e-09
PCTOWNHOME  -0.437518   0.188910 -2.3160 0.0205572

Lambda: 0.036057 (standard error): 0.20221 (z-value): 0.17832
Residual variance (sigma squared): 0.41585, (sigma: 0.64487)
GM argmin sigma squared: 0.45139
Number of observations: 281 
Number of parameters estimated: 6 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GMerrorsar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:foreign’

> nameEx("LR.sarlm")
> ### * LR.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: LR.sarlm
> ### Title: Likelihood ratio test
> ### Aliases: LR.sarlm LR1.sarlm Wald1.sarlm Hausman.test Hausman.test.sarlm
> ###   Hausman.test.gmsar logLik.sarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> mixed <- lagsarlm(CRIME ~ HOVAL + INC, data=columbus, nb2listw(col.gal.nb),
+   type="mixed")
> error <- errorsarlm(CRIME ~ HOVAL + INC, data=columbus, nb2listw(col.gal.nb))
> LR.sarlm(mixed, error)

	Likelihood ratio for spatial linear models

data:  
Likelihood ratio = 4.2782, df = 2, p-value = 0.1178
sample estimates:
Log likelihood of mixed Log likelihood of error 
              -182.0161               -184.1552 

> Hausman.test(error)

	Spatial Hausman test (asymptotic)

data:  NULL
Hausman test = 6.4729, df = 3, p-value = 0.09074

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("LR.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("MCMCsamp")
> ### * MCMCsamp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: MCMCsamp
> ### Title: MCMC sample from fitted spatial regression
> ### Aliases: MCMCsamp MCMCsamp.spautolm MCMCsamp.sarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(NY_data)

NY_dat> ## NY leukemia
NY_dat> library(foreign)

NY_dat> nydata <- read.dbf(system.file("etc/misc/nydata.dbf", package="spdep")[1])

NY_dat> coordinates(nydata) <- c("X", "Y")

NY_dat> nyadjmat <- as.matrix(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1])[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> ID <- as.character(names(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1]))[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10))
[1] TRUE

NY_dat> nyadjlw <- mat2listw(nyadjmat, as.character(nydata$AREAKEY))

NY_dat> listw_NY <- nb2listw(nyadjlw$neighbours, style="B")
> ## Not run: 
> ##D esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, family="SAR", method="eigen")
> ##D summary(esar1f)
> ##D res <- MCMCsamp(esar1f, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D ecar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, family="CAR", method="eigen")
> ##D summary(ecar1f)
> ##D res <- MCMCsamp(ecar1f, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D esar1fw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=POP8, family="SAR", method="eigen")
> ##D summary(esar1fw)
> ##D res <- MCMCsamp(esar1fw, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D ecar1fw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=POP8, family="CAR", method="eigen")
> ##D summary(ecar1fw)
> ##D res <- MCMCsamp(ecar1fw, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ## End(Not run)
> esar0 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
+  listw=listw_NY)
> summary(esar0)

Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, 
    data = nydata, listw = listw_NY)

Residuals:
     Min       1Q   Median       3Q      Max 
-1.56754 -0.38239 -0.02643  0.33109  4.01219 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.618193   0.176784 -3.4969 0.0004707
PEXPOSURE    0.071014   0.042051  1.6888 0.0912635
PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09
PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930

Lambda: 0.040487, LR test value: 5.2438, p-value: 0.022026
Asymptotic standard error: 0.016214
    z-value: 2.4971, p-value: 0.01252
Wald statistic: 6.2356, p-value: 0.01252

Log likelihood: -276.1069 for error model
ML residual variance (sigma squared): 0.41388, (sigma: 0.64333)
Number of observations: 281 
Number of parameters estimated: 6 
AIC: 564.21, (AIC for lm: 567.46)

> res <- MCMCsamp(esar0, mcmc=5000, burnin=500, listw=listw_NY)
> summary(res)

Iterations = 1:5000
Thinning interval = 1 
Number of chains = 1 
Sample size per chain = 5000 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

                Mean      SD  Naive SE Time-series SE
lambda       0.04549 0.01735 0.0002453       0.001032
(Intercept) -0.63854 0.19384 0.0027413       0.011980
PEXPOSURE    0.07670 0.04496 0.0006358       0.002646
PCTAGE65P    3.69353 0.63704 0.0090091       0.035944
PCTOWNHOME  -0.39333 0.21530 0.0030447       0.013326

2. Quantiles for each variable:

                 2.5%      25%      50%      75%    97.5%
lambda       0.011934  0.03388  0.04440  0.05747  0.08089
(Intercept) -1.048497 -0.76247 -0.62847 -0.51309 -0.28034
PEXPOSURE   -0.006487  0.04541  0.07508  0.10548  0.16836
PCTAGE65P    2.461083  3.25825  3.68929  4.11025  4.96685
PCTOWNHOME  -0.804526 -0.53791 -0.40195 -0.25982  0.05319

> ## Not run: 
> ##D esar1 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, etype="emixed")
> ##D summary(esar1)
> ##D res <- MCMCsamp(esar1, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D lsar0 <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY)
> ##D summary(lsar0)
> ##D res <- MCMCsamp(lsar0, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D lsar1 <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, type="mixed")
> ##D summary(lsar1)
> ##D res <- MCMCsamp(lsar1, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D ssar0 <- sacsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY)
> ##D summary(ssar0)
> ##D res <- MCMCsamp(ssar0, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ##D ssar1 <- sacsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, type="sacmixed")
> ##D summary(ssar1)
> ##D res <- MCMCsamp(ssar1, mcmc=5000, burnin=500, listw=listw_NY)
> ##D summary(res)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("MCMCsamp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:foreign’

> nameEx("ME")
> ### * ME
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ME
> ### Title: Moran eigenvector GLM filtering
> ### Aliases: ME print.ME_res fitted.ME_res
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D example(columbus)
> ##D lmbase <- lm(CRIME ~ INC + HOVAL, data=columbus)
> ##D lagcol <- SpatialFiltering(CRIME ~ 1, ~ INC + HOVAL, data=columbus,
> ##D  nb=col.gal.nb, style="W", alpha=0.1, verbose=TRUE)
> ##D lagcol
> ##D lmlag <- lm(CRIME ~ INC + HOVAL + fitted(lagcol), data=columbus)
> ##D anova(lmlag)
> ##D anova(lmbase, lmlag)
> ##D set.seed(123)
> ##D lagcol1 <- ME(CRIME ~ INC + HOVAL, data=columbus, family="gaussian",
> ##D  listw=nb2listw(col.gal.nb), alpha=0.1, verbose=TRUE)
> ##D lagcol1
> ##D lmlag1 <- lm(CRIME ~ INC + HOVAL + fitted(lagcol1), data=columbus)
> ##D anova(lmlag1)
> ##D anova(lmbase, lmlag1)
> ##D set.seed(123)
> ##D lagcol2 <- ME(CRIME ~ INC + HOVAL, data=columbus, family="gaussian",
> ##D  listw=nb2listw(col.gal.nb), alpha=0.1, stdev=TRUE, verbose=TRUE)
> ##D lagcol2
> ##D lmlag2 <- lm(CRIME ~ INC + HOVAL + fitted(lagcol2), data=columbus)
> ##D anova(lmlag2)
> ##D anova(lmbase, lmlag2)
> ##D example(nc.sids)
> ##D glmbase <- glm(SID74 ~ 1, data=nc.sids, offset=log(BIR74),
> ##D  family="poisson")
> ##D set.seed(123)
> ##D MEpois1 <- ME(SID74 ~ 1, data=nc.sids, offset=log(BIR74),
> ##D  family="poisson", listw=nb2listw(ncCR85_nb, style="B"), alpha=0.2, verbose=TRUE)
> ##D MEpois1
> ##D glmME <- glm(SID74 ~ 1 + fitted(MEpois1), data=nc.sids, offset=log(BIR74),
> ##D  family="poisson")
> ##D anova(glmME, test="Chisq")
> ##D anova(glmbase, glmME, test="Chisq")
> ##D data(hopkins)
> ##D hopkins_part <- hopkins[21:36,36:21]
> ##D hopkins_part[which(hopkins_part > 0, arr.ind=TRUE)] <- 1
> ##D hopkins.rook.nb <- cell2nb(16, 16, type="rook")
> ##D glmbase <- glm(c(hopkins_part) ~ 1, family="binomial")
> ##D set.seed(123)
> ##D MEbinom1 <- ME(c(hopkins_part) ~ 1, family="binomial",
> ##D  listw=nb2listw(hopkins.rook.nb, style="B"), alpha=0.2, verbose=TRUE)
> ##D glmME <- glm(c(hopkins_part) ~ 1 + fitted(MEbinom1), family="binomial")
> ##D anova(glmME, test="Chisq")
> ##D anova(glmbase, glmME, test="Chisq")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ME", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("NY_data")
> ### * NY_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: NY_data
> ### Title: New York leukemia data
> ### Aliases: NY_data nydata listw_NY
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## NY leukemia
> library(foreign)
> nydata <- read.dbf(system.file("etc/misc/nydata.dbf", package="spdep")[1])
> coordinates(nydata) <- c("X", "Y")
> nyadjmat <- as.matrix(read.dbf(system.file("etc/misc/nyadjwts.dbf",
+  package="spdep")[1])[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’
> ID <- as.character(names(read.dbf(system.file("etc/misc/nyadjwts.dbf",
+  package="spdep")[1]))[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’
> identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10))
[1] TRUE
> nyadjlw <- mat2listw(nyadjmat, as.character(nydata$AREAKEY))
> listw_NY <- nb2listw(nyadjlw$neighbours, style="B")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("NY_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:foreign’

> nameEx("SpatialFiltering")
> ### * SpatialFiltering
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SpatialFiltering
> ### Title: Semi-parametric spatial filtering
> ### Aliases: SpatialFiltering print.SFResult fitted.SFResult
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> lmbase <- lm(CRIME ~ INC + HOVAL, data=columbus)
> sarcol <- SpatialFiltering(CRIME ~ INC + HOVAL, data=columbus,
+  nb=col.gal.nb, style="W", ExactEV=TRUE)
> sarcol
  Step SelEvec      Eval        MinMi      ZMinMi      Pr(ZI)        R2
0    0       0 0.0000000  0.212374153  2.68100025 0.007340246 0.5524040
1    1       5 0.7148326  0.121528166  1.89037770 0.058707464 0.6209393
2    2       3 0.8408661  0.065848648  1.54064108 0.123404165 0.6481722
3    3       1 1.0206316 -0.005424824  1.08514557 0.277857187 0.6726114
4    4      10 0.3658588 -0.039356232  0.80357070 0.421644951 0.7000258
5    5      14 0.1831325 -0.072949543  0.47790213 0.632719864 0.7393770
6    6      11 0.3144120 -0.108332631  0.18566599 0.852706701 0.7611907
7    7       2 0.9157325 -0.153675621 -0.03464097 0.972366030 0.7713163
      gamma
0   0.00000
1  30.34786
2  19.13010
3 -18.12234
4  19.19379
5  22.99586
6  17.12127
7  11.66487
> lmsar <- lm(CRIME ~ INC + HOVAL + fitted(sarcol), data=columbus)
> lmsar

Call:
lm(formula = CRIME ~ INC + HOVAL + fitted(sarcol), data = columbus)

Coefficients:
        (Intercept)                  INC                HOVAL  
            68.6190              -1.5973              -0.2739  
 fitted(sarcol)vec5   fitted(sarcol)vec3   fitted(sarcol)vec1  
            30.3479              19.1301             -18.1223  
fitted(sarcol)vec10  fitted(sarcol)vec14  fitted(sarcol)vec11  
            19.1938              22.9959              17.1213  
 fitted(sarcol)vec2  
            11.6649  

> anova(lmbase, lmsar)
Analysis of Variance Table

Model 1: CRIME ~ INC + HOVAL
Model 2: CRIME ~ INC + HOVAL + fitted(sarcol)
  Res.Df    RSS Df Sum of Sq      F    Pr(>F)    
1     46 6014.9                                  
2     39 3073.1  7    2941.8 5.3334 0.0002445 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> lm.morantest(lmsar, nb2listw(col.gal.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ INC + HOVAL + fitted(sarcol), data =
columbus)
weights: nb2listw(col.gal.nb)

Moran I statistic standard deviate = -0.034641, p-value = 0.5138
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
      -0.153675621       -0.150918131        0.006336477 

> lagcol <- SpatialFiltering(CRIME ~ 1, ~ INC + HOVAL - 1, data=columbus,
+  nb=col.gal.nb, style="W")
> lagcol
   Step SelEvec      Eval       MinMi      ZMinMi      Pr(ZI)        R2
0     0       0 0.0000000  0.21237415  2.68100025 0.007340246 0.5524040
1     1       6 0.7161123  0.11782248  1.84511963 0.065020139 0.6038801
2     2       4 0.8682938  0.06242664  1.49482111 0.134961136 0.6531288
3     3       1 1.0310063 -0.02066604  0.88134183 0.378132834 0.6924845
4     4       5 0.7905397 -0.04619973  0.84746904 0.396733736 0.7136578
5     5      15 0.1753342 -0.07609524  0.55233191 0.580720971 0.7558543
6     6       9 0.5501433 -0.10190889  0.43919419 0.660520837 0.7626784
7     7       8 0.5721041 -0.12232942  0.41846803 0.675604953 0.7757314
8     8       3 0.9026222 -0.14991822  0.38315383 0.701605709 0.7908693
9     9       2 0.9649166 -0.21756342 -0.28556733 0.775209527 0.8078727
10   10       7 0.6219404 -0.22017920 -0.04856547 0.961265592 0.8082842
        gamma
0    0.000000
1   19.848854
2   35.542595
3  -30.697851
4  -24.540372
5   25.227798
6    7.590082
7  -16.933168
8  -20.556931
9  -18.434534
10  -2.597572
> lmlag <- lm(CRIME ~ INC + HOVAL + fitted(lagcol), data=columbus)
> lmlag

Call:
lm(formula = CRIME ~ INC + HOVAL + fitted(lagcol), data = columbus)

Coefficients:
        (Intercept)                  INC                HOVAL  
            56.7977              -0.4857              -0.3821  
 fitted(lagcol)vec6   fitted(lagcol)vec4   fitted(lagcol)vec1  
            19.8489              35.5426             -30.6979  
 fitted(lagcol)vec5  fitted(lagcol)vec15   fitted(lagcol)vec9  
           -24.5404              25.2278               7.5901  
 fitted(lagcol)vec8   fitted(lagcol)vec3   fitted(lagcol)vec2  
           -16.9332             -20.5569             -18.4345  
 fitted(lagcol)vec7  
            -2.5976  

> anova(lmbase, lmlag)
Analysis of Variance Table

Model 1: CRIME ~ INC + HOVAL
Model 2: CRIME ~ INC + HOVAL + fitted(lagcol)
  Res.Df    RSS Df Sum of Sq      F    Pr(>F)    
1     46 6014.9                                  
2     36 2576.3 10    3438.6 4.8049 0.0002165 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> lm.morantest(lmlag, nb2listw(col.gal.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ INC + HOVAL + fitted(lagcol), data =
columbus)
weights: nb2listw(col.gal.nb)

Moran I statistic standard deviate = -0.048565, p-value = 0.5194
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
      -0.220179195       -0.217083975        0.004061888 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("SpatialFiltering", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("afcon")
> ### * afcon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: afcon
> ### Title: Spatial patterns of conflict in Africa 1966-78
> ### Aliases: afcon africa.rook.nb afxy paper.nb
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(afcon)
> plot(africa.rook.nb, afxy)
> plot(diffnb(paper.nb, africa.rook.nb), afxy, col="red", add=TRUE)
> text(afxy, labels=attr(africa.rook.nb, "region.id"), pos=4, offset=0.4)
> moran.test(afcon$totcon, nb2listw(africa.rook.nb))

	Moran's I test under randomisation

data:  afcon$totcon  
weights: nb2listw(africa.rook.nb)  

Moran I statistic standard deviate = 4.1251, p-value = 1.853e-05
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.40981723       -0.02439024        0.01107950 

> moran.test(afcon$totcon, nb2listw(paper.nb))

	Moran's I test under randomisation

data:  afcon$totcon  
weights: nb2listw(paper.nb)  

Moran I statistic standard deviate = 4.3485, p-value = 6.854e-06
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.41679563       -0.02439024        0.01029358 

> geary.test(afcon$totcon, nb2listw(paper.nb))

	Geary's C test under randomisation

data:  afcon$totcon 
weights: nb2listw(paper.nb) 

Geary C statistic standard deviate = 2.8988, p-value = 0.001873
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
       0.58395772        1.00000000        0.02059931 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("afcon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aggregate.nb")
> ### * aggregate.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aggregate.nb
> ### Title: Aggregate a spatial neighbours object
> ### Aliases: aggregate.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(used.cars)
> data(state)
> cont_st <- match(attr(usa48.nb, "region.id"), state.abb)
> cents <- as.matrix(as.data.frame(state.center))[cont_st,]
> opar <- par(mfrow=c(2,1))
> plot(usa48.nb, cents, xlim=c(-125, -65), ylim=c(25, 50))
> IDs <- as.character(state.division[cont_st])
> agg_cents <- aggregate(cents, list(IDs), mean)
> agg_nb <- aggregate(usa48.nb, IDs)
> plot(agg_nb, agg_cents[, 2:3], xlim=c(-125, -65), ylim=c(25, 50))
> text(agg_cents[, 2:3], agg_cents[, 1], cex=0.6)
> par(opar)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aggregate.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("anova.sarlm")
> ### * anova.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: anova.sarlm
> ### Title: Comparison of simultaneous autoregressive models
> ### Aliases: anova.sarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> lm.mod <- lm(CRIME ~ HOVAL + INC, data=columbus)
> lag <- lagsarlm(CRIME ~ HOVAL + INC, data=columbus, nb2listw(col.gal.nb))
> mixed <- lagsarlm(CRIME ~ HOVAL + INC, data=columbus, nb2listw(col.gal.nb),
+   type="mixed")
> error <- errorsarlm(CRIME ~ HOVAL + INC, data=columbus, nb2listw(col.gal.nb))
> LR.sarlm(mixed, error)

	Likelihood ratio for spatial linear models

data:  
Likelihood ratio = 4.2782, df = 2, p-value = 0.1178
sample estimates:
Log likelihood of mixed Log likelihood of error 
              -182.0161               -184.1552 

> anova(lag, lm.mod)
       Model df    AIC  logLik Test L.Ratio   p-value
lag        1  5 376.34 -183.17    1                  
lm.mod     2  4 382.75 -187.38    2  8.4179 0.0037154
> anova(lag, error, mixed)
      Model df    AIC  logLik Test L.Ratio p-value
lag       1  5 376.34 -183.17    1                
error     2  5 378.31 -184.16    1                
mixed     3  7 378.03 -182.02    2  4.2782 0.11776
> AIC(lag, error, mixed)
      df      AIC
lag    5 376.3366
error  5 378.3104
mixed  7 378.0322
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("anova.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("aple")
> ### * aple
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aple
> ### Title: Approximate profile-likelihood estimator (APLE)
> ### Aliases: aple
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(wheat)

wheat> ## Not run: 
wheat> ##D data(wheat)
wheat> ##D wheat$lat1 <- 69 - wheat$lat
wheat> ##D wheat$r <- factor(wheat$lat1)
wheat> ##D wheat$c <- factor(wheat$lon)
wheat> ##D wheat_sp <- wheat
wheat> ##D coordinates(wheat_sp) <- c("lon", "lat1")
wheat> ##D wheat_spg <- wheat_sp
wheat> ##D gridded(wheat_spg) <- TRUE
wheat> ##D wheat_spl <- as(wheat_spg, "SpatialPolygons")
wheat> ##D df <- as(wheat_spg, "data.frame")
wheat> ##D row.names(df) <- sapply(slot(wheat_spl, "polygons"),
wheat> ##D  function(x) slot(x, "ID"))
wheat> ##D wheat <- SpatialPolygonsDataFrame(wheat_spl, data=df)
wheat> ## End(Not run)
wheat> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

wheat> wheat <- readShapeSpatial(system.file("etc/shapes/wheat.shp",
wheat+  package="spdep")[1])
> nbr1 <- poly2nb(wheat, queen=FALSE)
> nbrl <- nblag(nbr1, 2)
> nbr12 <- nblag_cumul(nbrl)
> cms0 <- with(as(wheat, "data.frame"), tapply(yield, c, median))
> cms1 <- c(model.matrix(~ factor(c) -1, data=wheat) %*% cms0)
> wheat$yield_detrend <- wheat$yield - cms1
> isTRUE(all.equal(c(with(as(wheat, "data.frame"),
+  tapply(yield_detrend, c, median))), rep(0.0, 25),
+  check.attributes=FALSE))
[1] TRUE
> moran.test(wheat$yield_detrend, nb2listw(nbr12, style="W"))

	Moran's I test under randomisation

data:  wheat$yield_detrend  
weights: nb2listw(nbr12, style = "W")  

Moran I statistic standard deviate = 10.305, p-value < 2.2e-16
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
     0.1935469610     -0.0020040080      0.0003600869 

> aple(as.vector(scale(wheat$yield_detrend, scale=FALSE)), nb2listw(nbr12, style="W"))
[1] 0.6601805
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aple", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("aple.mc")
> ### * aple.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aple.mc
> ### Title: Approximate profile-likelihood estimator (APLE) permutation test
> ### Aliases: aple.mc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aple.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aple.plot")
> ### * aple.plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aple.plot
> ### Title: Approximate profile-likelihood estimator (APLE) scatterplot
> ### Aliases: aple.plot localAple
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D example(aple)
> ##D plt_out <- aple.plot(as.vector(scale(wheat$yield_detrend, scale=FALSE)),
> ##D  nb2listw(nbr12, style="W"), cex=0.6)
> ##D crossprod(plt_out$Y, plt_out$X)/crossprod(plt_out$X)
> ##D lm_obj <- lm(Y ~ X, plt_out)
> ##D abline(lm_obj)
> ##D abline(v=0, h=0, lty=2)
> ##D zz <- summary(influence.measures(lm_obj))
> ##D infl <- as.integer(rownames(zz))
> ##D points(plt_out$X[infl], plt_out$Y[infl], pch=3, cex=0.6, col="red")
> ##D wheat$localAple <- localAple(as.vector(scale(wheat$yield_detrend, scale=FALSE)),
> ##D  nb2listw(nbr12, style="W"))
> ##D mean(wheat$localAple)
> ##D hist(wheat$localAple)
> ##D spl <- list("sp.text", coordinates(wheat)[infl,], rep("*", length(infl)))
> ##D spplot(wheat, "localAple", sp.layout=spl)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aple.plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as_dgRMatrix_listw")
> ### * as_dgRMatrix_listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as_dgRMatrix_listw
> ### Title: Interface between Matrix class objects and weights lists
> ### Aliases: as_dgRMatrix_listw as_dsTMatrix_listw as_dsCMatrix_I
> ###   as_dsCMatrix_IrW Jacobian_W coerce,listw,CsparseMatrix-method
> ###   coerce,listw,RsparseMatrix-method coerce,listw,symmetricMatrix-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(NY_data)

NY_dat> ## NY leukemia
NY_dat> library(foreign)

NY_dat> nydata <- read.dbf(system.file("etc/misc/nydata.dbf", package="spdep")[1])

NY_dat> coordinates(nydata) <- c("X", "Y")

NY_dat> nyadjmat <- as.matrix(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1])[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> ID <- as.character(names(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1]))[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10))
[1] TRUE

NY_dat> nyadjlw <- mat2listw(nyadjmat, as.character(nydata$AREAKEY))

NY_dat> listw_NY <- nb2listw(nyadjlw$neighbours, style="B")
> W_C <- as(listw_NY, "CsparseMatrix")
> W_R <- as(listw_NY, "RsparseMatrix")
> W_S <- as(listw_NY, "symmetricMatrix")
> n <- nrow(W_S)
> I <- Diagonal(n)
> rho <- 0.1
> c(determinant(I - rho * W_S, logarithm=TRUE)$modulus)
[1] -9.587255
> sum(log(1 - rho * eigenw(listw_NY)))
[1] -9.587255
> nW <- - W_S
> nChol <- Cholesky(nW, Imult=8)
> n * log(rho) + (2 * c(determinant(update(nChol, nW, 1/rho))$modulus))
[1] -9.587255
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as_dgRMatrix_listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:foreign’

> nameEx("auckland")
> ### * auckland
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: auckland
> ### Title: Marshall's infant mortality in Auckland dataset
> ### Aliases: auckland auckland.nb auckpolys
> ### Keywords: datasets
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> auckland <- readShapePoly(system.file("etc/shapes/auckland.shp",
+  package="spdep")[1])
> auckland.nb <- poly2nb(auckland)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("auckland", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("autocov_dist")
> ### * autocov_dist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: autocov_dist
> ### Title: Distance-weighted autocovariate
> ### Aliases: autocov_dist
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> xy <- cbind(columbus$X, columbus$Y)
> ac1a <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
+  type="one")
> acinva <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
+  type="inverse")
> acinv2a <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
+  type="inverse.squared")
> 
> plot(ac1a ~ columbus$CRIME, pch=16, asp=1)
> points(acinva ~ columbus$CRIME, pch=16, col="red")
> points(acinv2a ~ columbus$CRIME, pch=16, col="blue")
> abline(0,1)
> 
> nb <- dnearneigh(xy, 0, 10)
> lw <- nb2listw(nb, style="B")
> ac1b <- lag(lw, columbus$CRIME)
> all.equal(ac1b, ac1a)
[1] TRUE
> 
> nbd <- nbdists(nb, xy)
> gl <- lapply(nbd, function(x) 1/x)
> lw <- nb2listw(nb, glist=gl)
> acinvb <- lag(lw, columbus$CRIME)
> all.equal(acinvb, acinva)
[1] "Mean relative difference: 4.825204"
> 
> gl2 <- lapply(nbd, function(x) 1/(x^2))
> lw <- nb2listw(nb, glist=gl2)
> acinv2b <- lag(lw, columbus$CRIME)
> all.equal(acinv2b, acinv2a)
[1] "Mean relative difference: 1.108139"
> 
> glm(CRIME ~ HOVAL + ac1b, data=columbus, family="gaussian")

Call:  glm(formula = CRIME ~ HOVAL + ac1b, family = "gaussian", data = columbus)

Coefficients:
(Intercept)        HOVAL         ac1b  
   24.17582     -0.31353      0.02312  

Degrees of Freedom: 48 Total (i.e. Null);  46 Residual
Null Deviance:	    13440 
Residual Deviance: 5148 	AIC: 375.1
> spautolm(columbus$CRIME ~ HOVAL, data=columbus,
+  listw=nb2listw(nb, style="W"))

Call:
spautolm(formula = columbus$CRIME ~ HOVAL, data = columbus, listw = nb2listw(nb, 
    style = "W"))

Coefficients:
(Intercept)       HOVAL      lambda 
 48.7892314  -0.4377925   0.6323170 

Log likelihood: -195.0896 
> 
> xy <- SpatialPoints(xy)
> acinva <- autocov_dist(columbus$CRIME, xy, nbs=10, style="W",
+  type="inverse")
> nb <- dnearneigh(xy, 0, 10)
> nbd <- nbdists(nb, xy)
> gl <- lapply(nbd, function(x) 1/x)
> lw <- nb2listw(nb, glist=gl)
> acinvb <- lag(lw, columbus$CRIME)
> all.equal(acinvb, acinva)
[1] TRUE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("autocov_dist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("baltimore")
> ### * baltimore
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: baltimore
> ### Title: House sales prices, Baltimore, MD 1978
> ### Aliases: baltimore
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(baltimore)
> ## maybe str(baltimore) ; plot(baltimore) ...
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("baltimore", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bhicv")
> ### * bhicv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bhicv
> ### Title: Data set with 4 life condition indices of Belo Horizonte region
> ### Aliases: bhicv
> ### Keywords: data
> 
> ### ** Examples
> 
> ### see example in 'skater' function help
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bhicv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("boston")
> ### * boston
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: boston
> ### Title: Corrected Boston Housing Data
> ### Aliases: boston.c boston boston.soi boston.utm
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(boston)
> hr0 <- lm(log(MEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2) +
+  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), data=boston.c)
> summary(hr0)

Call:
lm(formula = log(MEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
    I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + 
    log(LSTAT), data = boston.c)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.71176 -0.09169 -0.00566  0.09895  0.79780 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  4.558e+00  1.544e-01  29.512  < 2e-16 ***
CRIM        -1.186e-02  1.245e-03  -9.532  < 2e-16 ***
ZN           8.016e-05  5.056e-04   0.159 0.874105    
INDUS        2.395e-04  2.364e-03   0.101 0.919318    
CHAS1        9.140e-02  3.320e-02   2.753 0.006129 ** 
I(NOX^2)    -6.380e-01  1.131e-01  -5.639 2.88e-08 ***
I(RM^2)      6.328e-03  1.312e-03   4.823 1.89e-06 ***
AGE          9.074e-05  5.263e-04   0.172 0.863179    
log(DIS)    -1.913e-01  3.339e-02  -5.727 1.78e-08 ***
log(RAD)     9.571e-02  1.913e-02   5.002 7.91e-07 ***
TAX         -4.203e-04  1.227e-04  -3.426 0.000664 ***
PTRATIO     -3.112e-02  5.013e-03  -6.208 1.14e-09 ***
B            3.637e-04  1.031e-04   3.527 0.000460 ***
log(LSTAT)  -3.712e-01  2.501e-02 -14.841  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.1825 on 492 degrees of freedom
Multiple R-squared:  0.8059,	Adjusted R-squared:  0.8008 
F-statistic: 157.1 on 13 and 492 DF,  p-value: < 2.2e-16

> logLik(hr0)
'log Lik.' 149.9548 (df=15)
> gp0 <- lm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2) +
+  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), data=boston.c)
> summary(gp0)

Call:
lm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
    I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + 
    log(LSTAT), data = boston.c)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.70893 -0.09295 -0.01049  0.09575  0.79618 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  4.562e+00  1.523e-01  29.955  < 2e-16 ***
CRIM        -1.177e-02  1.228e-03  -9.590  < 2e-16 ***
ZN           9.175e-05  4.987e-04   0.184 0.854085    
INDUS        1.789e-04  2.331e-03   0.077 0.938846    
CHAS1        9.213e-02  3.274e-02   2.813 0.005097 ** 
I(NOX^2)    -6.372e-01  1.116e-01  -5.711 1.95e-08 ***
I(RM^2)      6.255e-03  1.294e-03   4.833 1.80e-06 ***
AGE          7.100e-05  5.190e-04   0.137 0.891253    
log(DIS)    -1.978e-01  3.293e-02  -6.007 3.67e-09 ***
log(RAD)     8.957e-02  1.887e-02   4.746 2.72e-06 ***
TAX         -4.191e-04  1.210e-04  -3.464 0.000579 ***
PTRATIO     -2.960e-02  4.944e-03  -5.986 4.14e-09 ***
B            3.611e-04  1.017e-04   3.551 0.000421 ***
log(LSTAT)  -3.749e-01  2.466e-02 -15.200  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.1799 on 492 degrees of freedom
Multiple R-squared:  0.8108,	Adjusted R-squared:  0.8058 
F-statistic: 162.1 on 13 and 492 DF,  p-value: < 2.2e-16

> logLik(gp0)
'log Lik.' 156.9788 (df=15)
> lm.morantest(hr0, nb2listw(boston.soi))

	Global Moran's I for regression residuals

data:  
model: lm(formula = log(MEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +
I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
data = boston.c)
weights: nb2listw(boston.soi)

Moran I statistic standard deviate = 14.509, p-value < 2.2e-16
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
      0.4364296993      -0.0168870829       0.0009762383 

> ## Not run: 
> ##D require(maptools)
> ##D boston.tr <- readShapePoly(system.file("etc/shapes/boston_tracts.shp",
> ##D   package="spdep")[1], ID="poltract",
> ##D   proj4string=CRS(paste("+proj=longlat +datum=NAD27 +no_defs +ellps=clrk66",
> ##D   "+nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat")))
> ##D boston_nb <- poly2nb(boston.tr)
> ## End(Not run)
> ## Not run: 
> ##D gp1 <- errorsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2)
> ##D  + I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
> ##D  data=boston.c, nb2listw(boston.soi), method="Matrix", 
> ##D  control=list(tol.opt = .Machine$double.eps^(1/4)))
> ##D summary(gp1)
> ##D gp2 <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)
> ##D  +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
> ##D  data=boston.c, nb2listw(boston.soi), method="Matrix")
> ##D summary(gp2)
> ## End(Not run)
> ## Not run: 
> ##D ## Conversion table 1980/1970
> ##D # ICPSR_07913.zip
> ##D # 07913-0001-Data.txt
> ##D # http://dx.doi.org/10.3886/ICPSR07913.v1
> ##D # Provider: ICPSR
> ##D # Content: text/plain; charset="us-ascii"
> ##D # 
> ##D # TY  - DATA
> ##D # T1  - Census of Population and Housing 1980 [United States]:
> ##D # 1970-Pre 1980 Tract Relationships
> ##D # AU  - United States Department of Commerce. Bureau of the Census
> ##D # DO  - 10.3886/ICPSR07913.v1
> ##D # PY  - 1984-06-28
> ##D # UR  - http://dx.doi.org/10.3886/ICPSR07913.v1
> ##D # PB  - Inter-university Consortium for Political and Social Research
> ##D # (ICPSR) [distributor]
> ##D # ER  -
> ##D # widths <- c(ID=5L, FIPS70State=2L, FIPS70cty=3L, Tract70=6L, FIPS80State=2L,
> ##D #  FIPS80cty=3L, f1=7L, CTC=6L, f2=2L, intersect1=3L, intersect2=3L, name=30L)
> ##D # dta0 <- read.fwf("07913-0001-Data.txt", unname(widths),
> ##D #  col.names=names(widths), colClasses=rep("character", 12), as.is=TRUE)
> ##D # sub <- grep("25", dta0$FIPS80State)
> ##D # MA <- dta0[sub,]
> ##D ## match against boston data set
> ##D # library(spdep)
> ##D # data(boston)
> ##D # bTR <- boston.c$TRACT
> ##D # x1 <- match(as.integer(MA$Tract70), bTR)
> ##D # BOSTON <- MA[!is.na(x1),]
> ##D ## MA 1990 tracts
> ##D # library(rgdal)
> ##D # MAtr90 <- readOGR(".", "tr25_d90")
> ##D ## counties in the BOSTON SMSA
> ##D # BOSTON_SMSA <- MAtr90[MAtr90$CO ##D 
> ##D # proj4string(BOSTON_SMSA) <- CRS(paste("+proj=longlat +datum=NAD27 +no_defs",
> ##D #   "+ellps=clrk66 +nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat"))
> ##D # CTC4 <- substring(BOSTON$CTC, 1, 4)
> ##D # CTC4u <- unique(CTC4)
> ##D # TB_CTC4u <- match(BOSTON_SMSA$TRACTBASE, CTC4u)
> ##D ## match 1980 tracts with 1990
> ##D # BOSTON_SMSA1 <- BOSTON_SMSA[!is.na(TB_CTC4u),]
> ##D ## union Polygons objects with same 1970 tract code
> ##D #library(rgeos)
> ##D # BOSTON_SMSA2 <- unionSpatialPolygons(BOSTON_SMSA1,
> ##D #  id=as.character(BOSTON_SMSA1$TRACTBASE))
> ##D #BOSTON_SMSA2 <- gUnaryUnion(BOSTON_SMSA1,
> ##D # id=as.character(BOSTON_SMSA1$TRACTBASE))
> ##D ## reorder data set
> ##D # mm <- match(as.integer(as.character(row.names(BOSTON_SMSA2))), boston.c$TRACT)
> ##D # df <- boston.c[mm,]
> ##D # row.names(df) <- df$TRACT
> ##D # row.names(BOSTON_SMSA2) <- as.character(as.integer(row.names(BOSTON_SMSA2)))
> ##D ## create SpatialPolygonsDataFrame
> ##D # BOSTON_SMSA3 <- SpatialPolygonsDataFrame(BOSTON_SMSA2,
> ##D #  data=data.frame(poltract=row.names(BOSTON_SMSA2),
> ##D #  row.names=row.names(BOSTON_SMSA2)))
> ##D # BOSTON_SMSA4 <- spCbind(BOSTON_SMSA3, df)
> ##D # mm1 <- match(boston.c$TRACT, row.names(BOSTON_SMSA4))
> ##D # BOSTON_SMSA5 <- BOSTON_SMSA4[mm1,]
> ##D #writeOGR(BOSTON_SMSA5, ".", "boston_tracts", driver="ESRI Shapefile",
> ##D # overwrite_layer=TRUE)
> ##D # moran.test(boston.c$CMEDV, nb2listw(boston.soi))
> ##D # moran.test(BOSTON_SMSA5$CMEDV, nb2listw(boston.soi))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("boston", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bptest.sarlm")
> ### * bptest.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bptest.sarlm
> ### Title: Breusch-Pagan test for spatial models
> ### Aliases: bptest.sarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> error.col <- errorsarlm(CRIME ~ HOVAL + INC, data=columbus,
+  nb2listw(col.gal.nb))
> bptest.sarlm(error.col)

	studentized Breusch-Pagan test

data:  
BP = 9.3694, df = 2, p-value = 0.009235

> bptest.sarlm(error.col, studentize=FALSE)

	Breusch-Pagan test

data:  
BP = 16.285, df = 2, p-value = 0.0002908

> ## Not run: 
> ##D lm.target <- lm(error.col$tary ~ error.col$tarX - 1)
> ##D if (require(lmtest) && require(sandwich)) {
> ##D   coeftest(lm.target, vcov=vcovHC(lm.target, type="HC0"), df=Inf)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bptest.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("card")
> ### * card
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: card
> ### Title: Cardinalities for neighbours lists
> ### Aliases: card
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> table(card(col.gal.nb))

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("card", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("cell2nb")
> ### * cell2nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cell2nb
> ### Title: Generate neighbours list for grid cells
> ### Aliases: cell2nb mrc2vi rookcell queencell vi2mrc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> nb7rt <- cell2nb(7, 7)
> summary(nb7rt)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 168 
Percentage nonzero weights: 6.997085 
Average number of links: 3.428571 
Link number distribution:

 2  3  4 
 4 20 25 
4 least connected regions:
1:1 7:1 1:7 7:7 with 2 links
25 most connected regions:
2:2 3:2 4:2 5:2 6:2 2:3 3:3 4:3 5:3 6:3 2:4 3:4 4:4 5:4 6:4 2:5 3:5 4:5 5:5 6:5 2:6 3:6 4:6 5:6 6:6 with 4 links
> xyc <- attr(nb7rt, "region.id")
> xy <- matrix(as.integer(unlist(strsplit(xyc, ":"))), ncol=2, byrow=TRUE)
> plot(nb7rt, xy)
> nb7rt <- cell2nb(7, 7, torus=TRUE)
> summary(nb7rt)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 196 
Percentage nonzero weights: 8.163265 
Average number of links: 4 
Link number distribution:

 4 
49 
49 least connected regions:
1:1 2:1 3:1 4:1 5:1 6:1 7:1 1:2 2:2 3:2 4:2 5:2 6:2 7:2 1:3 2:3 3:3 4:3 5:3 6:3 7:3 1:4 2:4 3:4 4:4 5:4 6:4 7:4 1:5 2:5 3:5 4:5 5:5 6:5 7:5 1:6 2:6 3:6 4:6 5:6 6:6 7:6 1:7 2:7 3:7 4:7 5:7 6:7 7:7 with 4 links
49 most connected regions:
1:1 2:1 3:1 4:1 5:1 6:1 7:1 1:2 2:2 3:2 4:2 5:2 6:2 7:2 1:3 2:3 3:3 4:3 5:3 6:3 7:3 1:4 2:4 3:4 4:4 5:4 6:4 7:4 1:5 2:5 3:5 4:5 5:5 6:5 7:5 1:6 2:6 3:6 4:6 5:6 6:6 7:6 1:7 2:7 3:7 4:7 5:7 6:7 7:7 with 4 links
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cell2nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("choynowski")
> ### * choynowski
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: choynowski
> ### Title: Choynowski probability map values
> ### Aliases: choynowski
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(auckland)

acklnd> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

acklnd> auckland <- readShapePoly(system.file("etc/shapes/auckland.shp",
acklnd+  package="spdep")[1])

acklnd> auckland.nb <- poly2nb(auckland)
> res <- choynowski(auckland$M77_85, 9*auckland$Und5_81)
> resl <- choynowski(auckland$M77_85, 9*auckland$Und5_81, legacy=TRUE)
> all.equal(res, resl)
[1] TRUE
> rt <- sum(auckland$M77_85)/sum(9*auckland$Und5_81)
> ch_ppois_pmap <- numeric(length(auckland$Und5_81))
> side <- c("greater", "less")
> for (i in seq(along=ch_ppois_pmap)) {
+   ch_ppois_pmap[i] <- poisson.test(auckland$M77_85[i], r=rt,
+     T=(9*auckland$Und5_81[i]), alternative=side[(res$type[i]+1)])$p.value
+ }
> all.equal(ch_ppois_pmap, res$pmap)
[1] TRUE
> 
> res1 <- probmap(auckland$M77_85, 9*auckland$Und5_81)
> table(abs(res$pmap - res1$pmap) < 0.00001, res$type)
       
        FALSE TRUE
  FALSE    74    0
  TRUE      0   93
> lt005 <- (res$pmap < 0.05) & (res$type)
> ge005 <- (res$pmap < 0.05) & (!res$type)
> cols <- rep("white", length(lt005))
> cols[lt005] <- grey(2/7)
> cols[ge005] <- grey(5/7)
> plot(auckland, col=cols) 
> legend("bottomleft", fill=grey(c(2,5)/7), legend=c("low", "high"), bty="n")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("choynowski", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("columbus")
> ### * columbus
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: columbus
> ### Title: Columbus OH spatial analysis data set
> ### Aliases: columbus col.gal.nb coords polys bbs
> ### Keywords: datasets
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
+  package="spdep")[1])
> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
+  package="spdep")[1])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("columbus", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("compon")
> ### * compon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Graph Components
> ### Title: Depth First Search on Neighbor Lists
> ### Aliases: n.comp.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> plot(col.gal.nb, coords, col="grey")
> col2 <- droplinks(col.gal.nb, 21)
> plot(col2, coords, add=TRUE)
> res <- n.comp.nb(col2)
> table(res$comp.id)

 1  2  3 
42  1  6 
> points(coords, col=res$comp.id, pch=16)
> if (require(igraph)) {
+ B <- as(nb2listw(col2, style="B", zero.policy=TRUE), "CsparseMatrix")
+ g1 <- graph.adjacency(B, mode="undirected")
+ c1 <- clusters(g1)
+ print(c1$no == res$nc)
+ print(all.equal(c1$membership, res$comp.id))
+ print(all.equal(c1$csize, c(table(res$comp.id)), check.attributes=FALSE))
+ W <- as(nb2listw(col2, style="W", zero.policy=TRUE), "CsparseMatrix")
+ g1W <- graph.adjacency(W, mode="directed", weighted="W")
+ c1W <- clusters(g1W)
+ print(all.equal(c1W$membership, res$comp.id))
+ B1 <- get.adjacency(g1)
+ print(all.equal(B, B1))
+ }
Loading required package: igraph

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

[1] TRUE
[1] "names for target but not for current"
[1] TRUE
[1] "names for target but not for current"
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:igraph’, ‘package:maptools’

> nameEx("diffnb")
> ### * diffnb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: diffnb
> ### Title: Differences between neighbours lists
> ### Aliases: diffnb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> rn <- sapply(slot(columbus, "polygons"), function(x) slot(x, "ID"))
> knn1 <- knearneigh(coords, 1)
> knn2 <- knearneigh(coords, 2)
> nb1 <- knn2nb(knn1, row.names=rn)
> nb2 <- knn2nb(knn2, row.names=rn)
> diffs <- diffnb(nb2, nb1)
> plot(columbus, border="grey")
> plot(nb1, coords, add=TRUE)
> plot(diffs, coords, add=TRUE, col="red", lty=2)
> title(main="Plot of first (black) and second (red)\nnearest neighbours")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("diffnb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("dnearneigh")
> ### * dnearneigh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dnearneigh
> ### Title: Neighbourhood contiguity by distance
> ### Aliases: dnearneigh
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> rn <- sapply(slot(columbus, "polygons"), function(x) slot(x, "ID"))
> k1 <- knn2nb(knearneigh(coords))
> all.linked <- max(unlist(nbdists(k1, coords)))
> col.nb.0.all <- dnearneigh(coords, 0, all.linked, row.names=rn)
> summary(col.nb.0.all, coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 252 
Percentage nonzero weights: 10.49563 
Average number of links: 5.142857 
Link number distribution:

 1  2  3  4  5  6  7  8  9 10 11 
 4  8  6  2  5  8  6  2  6  1  1 
4 least connected regions:
5 9 20 46 with 1 link
1 most connected region:
27 with 11 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1276  0.3608  0.4566  0.4331  0.5224  0.6189 

  The decimal point is 2 digit(s) to the left of the |

  12 | 88
  14 | 44
  16 | 
  18 | 7788
  20 | 0033
  22 | 772277
  24 | 4488
  26 | 8822
  28 | 2244
  30 | 00334466
  32 | 11114444001188
  34 | 0033446633
  36 | 1133559900335588
  38 | 1133668899003355
  40 | 44557777222266
  42 | 990022333399
  44 | 3322777799
  46 | 22223344666677001111225588
  48 | 00000011222299
  50 | 1122888800557799
  52 | 22223333446600
  54 | 00333377001133556677
  56 | 111133446666
  58 | 0022337799
  60 | 2299111199

> plot(columbus, border="grey")
> plot(col.nb.0.all, coords, add=TRUE)
> title(main=paste("Distance based neighbours 0-",  format(all.linked),
+  " distance units", sep=""))
> data(state)
> us48.fipsno <- read.geoda(system.file("etc/weights/us48.txt",
+  package="spdep")[1])
> if (as.numeric(paste(version$major, version$minor, sep="")) < 19) {
+  m50.48 <- match(us48.fipsno$"State.name", state.name)
+ } else {
+  m50.48 <- match(us48.fipsno$"State_name", state.name)
+ }
> xy <- as.matrix(as.data.frame(state.center))[m50.48,]
> llk1 <- knn2nb(knearneigh(xy, k=1, longlat=FALSE))
> all.linked <- max(unlist(nbdists(llk1, xy, longlat=FALSE)))
> ll.nb <- dnearneigh(xy, 0, all.linked, longlat=FALSE)
> summary(ll.nb, xy, longlat=TRUE, scale=0.5)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 190 
Percentage nonzero weights: 8.246528 
Average number of links: 3.958333 
Link number distribution:

 1  2  3  4  5  7  8  9 10 
11  9  4  8  4  4  4  3  1 
11 least connected regions:
2 4 8 10 24 26 29 32 35 41 45 with 1 link
1 most connected region:
28 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  293.00  360.10  354.00  448.00  542.40 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 667788999999
  3 | 000000001111111122222222222233333333334444
  3 | 555566666677777788888899999999
  4 | 0000001111223344
  4 | 555555555555666666777788888888889999
  5 | 000000111122334444

> gck1 <- knn2nb(knearneigh(xy, k=1, longlat=TRUE))
> all.linked <- max(unlist(nbdists(gck1, xy, longlat=TRUE)))
> gc.nb <- dnearneigh(xy, 0, all.linked, longlat=TRUE)
> summary(gc.nb, xy, longlat=TRUE, scale=0.5)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 220 
Percentage nonzero weights: 9.548611 
Average number of links: 4.583333 
Link number distribution:

 1  2  3  4  5  6  7  8  9 10 
 5  9  6  8  5  2  3  3  5  2 
5 least connected regions:
2 4 8 41 45 with 1 link
2 most connected regions:
7 28 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  304.10  381.10  371.80  467.30  523.60 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 667788999999
  3 | 000000001111111122222222222233333333334444
  3 | 555566666677777788888899999999
  4 | 00000011112233334444
  4 | 55555555555566666666667777888888888888999999
  5 | 000000000000001111111122222222222222

> plot(ll.nb, xy)
> plot(diffnb(ll.nb, gc.nb), xy, add=TRUE, col="red", lty=2)
> title(main="Differences between Euclidean and Great Circle neighbours")
> 
> xy1 <- SpatialPoints((as.data.frame(state.center))[m50.48,],
+   proj4string=CRS("+proj=longlat"))
> gck1a <- knn2nb(knearneigh(xy1, k=1))
> all.linked <- max(unlist(nbdists(gck1a, xy1)))
> gc.nb <- dnearneigh(xy1, 0, all.linked)
> summary(gc.nb, xy1, scale=0.5)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 220 
Percentage nonzero weights: 9.548611 
Average number of links: 4.583333 
Link number distribution:

 1  2  3  4  5  6  7  8  9 10 
 5  9  6  8  5  2  3  3  5  2 
5 least connected regions:
2 4 8 41 45 with 1 link
2 most connected regions:
7 28 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  304.10  381.10  371.80  467.30  523.60 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 667788999999
  3 | 000000001111111122222222222233333333334444
  3 | 555566666677777788888899999999
  4 | 00000011112233334444
  4 | 55555555555566666666667777888888888888999999
  5 | 000000000000001111111122222222222222

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dnearneigh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("do_ldet")
> ### * do_ldet
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: do_ldet
> ### Title: Spatial regression model Jacobian computations
> ### Aliases: do_ldet jacobianSetup eigen_setup eigen_pre_setup mcdet_setup
> ###   cheb_setup spam_setup spam_update_setup Matrix_setup Matrix_J_setup
> ###   LU_setup LU_prepermutate_setup moments_setup SE_classic_setup
> ###   SE_whichMin_setup SE_interp_setup
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(boston)
> lw <- nb2listw(boston.soi)
> can.sim <- spdep:::can.be.simmed(lw)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("can.sim", can.sim, envir=env)
> assign("similar", FALSE, envir=env)
> assign("verbose", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> eigen_setup(env)
> get("similar", envir=env)
[1] TRUE
> do_ldet(0.5, env)
[1] -18.26702
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("can.sim", can.sim, envir=env)
> assign("similar", FALSE, envir=env)
> assign("verbose", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> assign("n", length(boston.soi), envir=env)
> eigen_pre_setup(env, pre_eig=eigenw(similar.listw(lw)))
> do_ldet(0.5, env)
[1] -18.26702
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("can.sim", can.sim, envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> assign("n", length(boston.soi), envir=env)
> Matrix_setup(env, Imult=2, super=FALSE)
> get("similar", envir=env)
[1] TRUE
> do_ldet(0.5, env)
[1] -18.26702
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("n", length(boston.soi), envir=env)
> assign("can.sim", can.sim, envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> spam_setup(env)
> get("similar", envir=env)
[1] TRUE
> do_ldet(0.5, env)
[1] -18.26702
attr(,"logarithm")
[1] TRUE
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("n", length(boston.soi), envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> LU_setup(env)
> get("similar", envir=env)
[1] FALSE
> do_ldet(0.5, env)
[1] -18.26702
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("n", length(boston.soi), envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> LU_prepermutate_setup(env)
> get("similar", envir=env)
[1] FALSE
> do_ldet(0.5, env)
[1] -18.26702
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> cheb_setup(env, q=5)
> get("similar", envir=env)
[1] FALSE
> do_ldet(0.5, env)
[1] -18.26176
> rm(env)
> env <- new.env(parent=globalenv())
> assign("listw", lw, envir=env)
> assign("n", length(boston.soi), envir=env)
> assign("similar", FALSE, envir=env)
> assign("family", "SAR", envir=env)
> set.seed(12345)
> mcdet_setup(env, p=16, m=30)
> get("similar", envir=env)
[1] FALSE
> do_ldet(0.5, env)
[1] -18.38606
attr(,"sd")
[1] 0.2045107
> rm(env)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("do_ldet", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("droplinks")
> ### * droplinks
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: droplinks
> ### Title: Drop links in a neighbours list
> ### Aliases: droplinks
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("droplinks", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("edit.nb")
> ### * edit.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: edit.nb
> ### Title: Interactive editing of neighbours lists
> ### Aliases: edit.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D example(columbus)
> ##D class(columbus)
> ##D nnb1 <- edit.nb(col.gal.nb, polys=columbus)
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("edit.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eigenw")
> ### * eigenw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eigenw
> ### Title: Spatial weights matrix eigenvalues
> ### Aliases: eigenw griffith_sone subgraph_eigenw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> W.eig <- eigenw(nb2listw(COL.nb, style="W"))
> 1/range(W.eig)
[1] -1.536177  1.000000
> S.eig <- eigenw(nb2listw(COL.nb, style="S"))
> 1/range(S.eig)
[1] -1.7364189  0.8918997
> B.eig <- eigenw(nb2listw(COL.nb, style="B"))
> 1/range(B.eig)
[1] -0.3229290  0.1692726
> # cases for intrinsically asymmetric weights
> crds <- cbind(COL.OLD$X, COL.OLD$Y)
> k3 <- knn2nb(knearneigh(crds, k=3))
> is.symmetric.nb(k3)
[1] FALSE
> k3eig <- eigenw(nb2listw(k3, style="W"))
> is.complex(k3eig)
[1] TRUE
> rho <- 0.5
> Jc <- sum(log(1 - rho * k3eig))
> # complex eigenvalue Jacobian
> Jc
[1] -1.749705+0i
> # subgraphs
> nc <- n.comp.nb(k3)
> nc$nc
[1] 2
> table(nc$comp.id)

 1  2 
43  6 
> k3eigSG <- subgraph_eigenw(k3, style="W")
> all.equal(sort(k3eig), k3eigSG)
[1] TRUE
> W <- as(nb2listw(k3, style="W"), "CsparseMatrix")
> I <- diag(length(k3))
> Jl <- sum(log(abs(diag(slot(lu(I - rho * W), "U")))))
> # LU Jacobian equals complex eigenvalue Jacobian
> Jl
[1] -1.749705
> all.equal(Re(Jc), Jl)
[1] TRUE
> # wrong value if only real part used
> Jr <- sum(log(1 - rho * Re(k3eig)))
> Jr
[1] -1.762734
> all.equal(Jr, Jl)
[1] "Mean relative difference: 0.007391147"
> # construction of Jacobian from complex conjugate pairs (Jan Hauke)
> Rev <- Re(k3eig)[which(Im(k3eig) == 0)]
> # real eigenvalues
> Cev <- k3eig[which(Im(k3eig) != 0)]
> pCev <- Cev[Im(Cev) > 0]
> # separate complex conjugate pairs
> RpCev <- Re(pCev)
> IpCev <- Im(pCev)
> # reassemble Jacobian
> Jc1 <- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2 + (rho^2)*(IpCev^2)))
> all.equal(Re(Jc), Jc1)
[1] TRUE
> # impact of omitted complex part term in real part only Jacobian
> Jc2 <- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2))
> all.equal(Jr, Jc2)
[1] TRUE
> # trace of asymmetric (WW) and crossprod of complex eigenvalues for APLE
> sum(diag(W %*% W))
[1] 11.55556
> crossprod(k3eig)
            [,1]
[1,] 11.55556+0i
> # analytical regular grid eigenvalues
> rg <- cell2nb(ncol=7, nrow=7, type="rook")
> rg_eig <- eigenw(nb2listw(rg, style="B"))
> rg_GS <- griffith_sone(P=7, Q=7, type="rook")
> all.equal(rg_eig, rg_GS)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eigenw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eire")
> ### * eire
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eire
> ### Title: Eire data sets
> ### Aliases: eire eire.df eire.polys.utm eire.coords.utm eire.nb
> ### Keywords: datasets
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> eire <- readShapePoly(system.file("etc/shapes/eire.shp", package="spdep")[1],
+   ID="names", proj4string=CRS("+proj=utm +zone=30 +units=km"))
> eire.nb <- poly2nb(eire)
> #data(eire)
> summary(eire$A)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  23.92   27.92   29.26   29.53   30.94   35.86 
> brks <- round(fivenum(eire$A), digits=2)
> cols <- rev(heat.colors(4))
> plot(eire, col=cols[findInterval(eire$A, brks, all.inside=TRUE)])
> title(main="Percentage with blood group A in Eire")
> legend(x=c(-50, 70), y=c(6120, 6050), leglabs(brks), fill=cols, bty="n")
> plot(eire)
> plot(eire.nb, coordinates(eire), add=TRUE)
> lA <- lag.listw(nb2listw(eire.nb), eire$A)
> summary(lA)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  26.08   28.33   29.21   29.64   31.12   33.39 
> moran.test(eire$A, nb2listw(eire.nb))

	Moran's I test under randomisation

data:  eire$A  
weights: nb2listw(eire.nb)  

Moran I statistic standard deviate = 4.6851, p-value = 1.399e-06
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.55412382       -0.04000000        0.01608138 

> geary.test(eire$A, nb2listw(eire.nb))

	Geary's C test under randomisation

data:  eire$A 
weights: nb2listw(eire.nb) 

Geary C statistic standard deviate = 4.5146, p-value = 3.172e-06
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
       0.38011971        1.00000000        0.01885309 

> cor(lA, eire$A)
[1] 0.8144345
> moran.plot(eire$A, nb2listw(eire.nb),
+  labels=eire$names)
> A.lm <- lm(A ~ towns + pale, data=eire)
> summary(A.lm)

Call:
lm(formula = A ~ towns + pale, data = eire)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.6420 -1.0340 -0.3428  1.0263  4.0460 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  27.5728     0.5448  50.614  < 2e-16 ***
towns        -0.3595     2.9672  -0.121 0.904610    
pale          4.3419     1.0851   4.001 0.000561 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 2.018 on 23 degrees of freedom
Multiple R-squared:  0.5551,	Adjusted R-squared:  0.5164 
F-statistic: 14.35 on 2 and 23 DF,  p-value: 9.014e-05

> res <- residuals(A.lm)
> brks <- c(min(res),-2,-1,0,1,2,max(res))
> cols <- rev(cm.colors(6))
> plot(eire, col=cols[findInterval(res, brks, all.inside=TRUE)])
> title(main="Regression residuals")
> legend(x=c(-50, 70), y=c(6120, 6050), legend=leglabs(brks), fill=cols,
+   bty="n")
> lm.morantest(A.lm, nb2listw(eire.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = A ~ towns + pale, data = eire)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 1.8003, p-value = 0.03591
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.15085317        -0.06845969         0.01484007 

> lm.morantest.sad(A.lm, nb2listw(eire.nb))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = A ~ towns + pale, data = eire)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 1.7284, p-value = 0.04196
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.1508532 

> lm.LMtests(A.lm, nb2listw(eire.nb), test="LMerr")

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = A ~ towns + pale, data = eire)
weights: nb2listw(eire.nb)

LMErr = 1.1634, df = 1, p-value = 0.2808

> brks <- round(fivenum(eire$OWNCONS), digits=2)
> cols <- grey(4:1/5)
> plot(eire, col=cols[findInterval(eire$OWNCONS, brks, all.inside=TRUE)])
> title(main="Percentage own consumption of agricultural produce")
> legend(x=c(-50, 70), y=c(6120, 6050), legend=leglabs(brks),
+   fill=cols, bty="n")
> moran.plot(eire$OWNCONS, nb2listw(eire.nb))
> moran.test(eire$OWNCONS, nb2listw(eire.nb))

	Moran's I test under randomisation

data:  eire$OWNCONS  
weights: nb2listw(eire.nb)  

Moran I statistic standard deviate = 5.8637, p-value = 2.263e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.71281837       -0.04000000        0.01648309 

> e.lm <- lm(OWNCONS ~ ROADACC, data=eire)
> res <- residuals(e.lm)
> brks <- c(min(res),-2,-1,0,1,2,max(res))
> cols <- rev(cm.colors(6))
> plot(eire, col=cols[findInterval(res, brks, all.inside=TRUE)])
> title(main="Regression residuals")
> legend(x=c(-50, 70), y=c(6120, 6050), legend=leglabs(brks), fill=cm.colors(6),
+   bty="n")
> lm.morantest(e.lm, nb2listw(eire.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 3.2575, p-value = 0.0005619
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.33660565        -0.05877741         0.01473183 

> lm.morantest.sad(e.lm, nb2listw(eire.nb))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 2.9395, p-value = 0.001644
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.3366057 

> lm.LMtests(e.lm, nb2listw(eire.nb), test="LMerr")

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

LMErr = 5.7925, df = 1, p-value = 0.01609

> print(localmoran.sad(e.lm, eire.nb, select=1:length(slot(eire, "polygons"))))
             Local Morans I Saddlepoint    Pr. (Sad)
1 Carlow         0.21699668  0.95074844 1.708660e-01
2 Cavan         -0.37257361 -1.00603119 8.427997e-01
3 Clare          0.23197510  0.67166518 2.508984e-01
4 Cork           0.78193548  1.74761575 4.026529e-02
5 Donegal       -1.69064059 -1.72031078 9.573120e-01
6 Dublin        -0.16069692 -0.35212627 6.376282e-01
7 Galway         1.31371473  2.66849536 3.809592e-03
8 Kerry          0.36534866  0.78073279 2.174798e-01
9 Kildare       -0.02557544  0.04167665 4.833782e-01
10 Kilkenny      0.57684331  1.70897697 4.372761e-02
11 Laoghis      -0.05951798 -0.12155465 5.483741e-01
12 Leitrim       0.38484587  1.47227033 7.047395e-02
13 Limerick      0.11817987  0.45727712 3.237359e-01
14 Longford      1.41643200  2.51113769 6.017137e-03
15 Louth         0.56242920  1.07441571 1.413182e-01
16 Mayo          0.87572704  2.05251226 2.005995e-02
17 Meath         0.00367856  0.12813539 4.490209e-01
18 Monaghan      0.55098311  1.23999193 1.074892e-01
19 Offaly        0.15155556  0.80786519 2.095841e-01
20 Roscommon     2.04368839  4.53187292 2.923151e-06
21 Sligo        -0.47579871 -0.94578114 8.278699e-01
22 Tipperary    -0.03454106 -0.06919691 5.275836e-01
23 Waterford     0.85723423  1.91385108 2.781959e-02
24 Westmeath     0.45138572  1.36017204 8.688774e-02
25 Wexford       0.64371834  1.63188492 5.135187e-02
26 Wicklow       0.02441950  0.21197000 4.160652e-01
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eire", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("elect80")
> ### * elect80
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: elect80
> ### Title: 1980 Presidential election results
> ### Aliases: elect80 elect80_lw k4 dll e80_queen
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(elect80)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("elect80", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("errorsarlm")
> ### * errorsarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: errorsarlm
> ### Title: Spatial simultaneous autoregressive error model estimation
> ### Aliases: errorsarlm lmSLX create_WX
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> lw <- nb2listw(COL.nb, style="W")
> COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  lw, method="eigen", quiet=FALSE)

Spatial autoregressive error model

Jacobian calculated using neighbourhood matrix eigenvalues
Computing eigenvalues ...

lambda: -0.5674437  function: -195.8051  Jacobian: -1.636549  SSE: 7936.201 
lambda: 0.03126655  function: -187.0219  Jacobian: -0.005318373  SSE: 5927.009 
lambda: 0.4012898  function: -183.8422  Jacobian: -0.9953987  SSE: 4999.419 
lambda: 0.6299767  function: -183.4895  Jacobian: -2.818134  SSE: 4574.641 
lambda: 0.5811116  function: -183.3887  Jacobian: -2.314073  SSE: 4650.566 
lambda: 0.554104  function: -183.3817  Jacobian: -2.066354  SSE: 4696.49 
lambda: 0.5621834  function: -183.3805  Jacobian: -2.138326  SSE: 4682.474 
lambda: 0.5617028  function: -183.3805  Jacobian: -2.133995  SSE: 4683.301 
lambda: 0.5617888  function: -183.3805  Jacobian: -2.134769  SSE: 4683.153 
lambda: 0.5617902  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.15 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
> summary(COL.errW.eig, correlation=TRUE)

Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw, 
    method = "eigen", quiet = FALSE)

Residuals:
      Min        1Q    Median        3Q       Max 
-34.81174  -6.44031  -0.72142   7.61476  23.33626 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 59.893219   5.366163 11.1613 < 2.2e-16
INC         -0.941312   0.330569 -2.8476 0.0044057
HOVAL       -0.302250   0.090476 -3.3407 0.0008358

Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945
Asymptotic standard error: 0.13387
    z-value: 4.1966, p-value: 2.7098e-05
Wald statistic: 17.611, p-value: 2.7098e-05

Log likelihood: -183.3805 for error model
ML residual variance (sigma squared): 95.575, (sigma: 9.7762)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 376.76, (AIC for lm: 382.75)

 Correlation of coefficients 
            sigma lambda (Intercept) INC  
lambda      -0.24                         
(Intercept)  0.00  0.00                   
INC          0.00  0.00  -0.56            
HOVAL        0.00  0.00  -0.26       -0.45

> ev <- eigenw(similar.listw(lw))
> COL.errW.eig_ev <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  lw, method="eigen", control=list(pre_eig=ev))
> all.equal(coefficients(COL.errW.eig), coefficients(COL.errW.eig_ev))
[1] TRUE
> COL.errB.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="B"), method="eigen", quiet=FALSE)

Spatial autoregressive error model

Jacobian calculated using neighbourhood matrix eigenvalues
Computing eigenvalues ...

lambda: -0.1349247  function: -196.5231  Jacobian: -1.943757  SSE: 8070.392 
lambda: -0.01873166  function: -188.4544  Jacobian: -0.03979938  SSE: 6275.036 
lambda: 0.0530796  function: -184.5803  Jacobian: -0.357711  SSE: 5288.195 
lambda: 0.09746139  function: -182.6524  Jacobian: -1.362311  SSE: 4691.642 
lambda: 0.1248908  function: -182.0539  Jacobian: -2.513709  SSE: 4368.243 
lambda: 0.1474059  function: -182.6008  Jacobian: -4.079119  SSE: 4190.365 
lambda: 0.1229929  function: -182.0642  Jacobian: -2.414173  SSE: 4387.866 
lambda: 0.1261661  function: -182.0507  Jacobian: -2.582701  SSE: 4355.382 
lambda: 0.1269409  function: -182.0502  Jacobian: -2.625484  SSE: 4347.7 
lambda: 0.126872  function: -182.0502  Jacobian: -2.621655  SSE: 4348.378 
lambda: 0.1268641  function: -182.0502  Jacobian: -2.621217  SSE: 4348.456 
lambda: 0.1268645  function: -182.0502  Jacobian: -2.621238  SSE: 4348.452 
lambda: 0.1268645  function: -182.0502  Jacobian: -2.621238  SSE: 4348.453 
lambda: 0.1268645  function: -182.0502  Jacobian: -2.621237  SSE: 4348.453 
lambda: 0.1268645  function: -182.0502  Jacobian: -2.621238  SSE: 4348.453 
> summary(COL.errB.eig, correlation=TRUE)

Call:
errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "B"), method = "eigen", quiet = FALSE)

Residuals:
      Min        1Q    Median        3Q       Max 
-32.19010  -5.22646  -0.69952   7.92588  24.23511 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 55.383119   5.449775 10.1625 < 2.2e-16
INC         -0.936595   0.319355 -2.9328 0.0033596
HOVAL       -0.299857   0.088678 -3.3814 0.0007212

Lambda: 0.12686, LR test value: 10.654, p-value: 0.0010983
Asymptotic standard error: 0.021745
    z-value: 5.8342, p-value: 5.4044e-09
Wald statistic: 34.038, p-value: 5.4044e-09

Log likelihood: -182.0502 for error model
ML residual variance (sigma squared): 88.744, (sigma: 9.4204)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 374.1, (AIC for lm: 382.75)

 Correlation of coefficients 
            sigma lambda (Intercept) INC  
lambda      -0.24                         
(Intercept)  0.00  0.00                   
INC          0.00  0.00  -0.60            
HOVAL        0.00  0.00  -0.30       -0.42

> W <- as(nb2listw(COL.nb), "CsparseMatrix")
> trMatc <- trW(W, type="mult")
> COL.errW.M <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  lw, method="Matrix", quiet=FALSE, trs=trMatc)

Spatial autoregressive error model

Jacobian calculated using sparse matrix Cholesky decomposition
lambda: -0.2364499  function: -190.4287  Jacobian: -0.2899343  SSE: 6732.556 
lambda: 0.2354499  function: -185.0024  Jacobian: -0.3201148  SSE: 5388.346 
lambda: 0.5271001  function: -183.4053  Jacobian: -1.838306  SSE: 4744.975 
lambda: 0.728364  function: -184.1244  Jacobian: -4.106761  SSE: 4454.203 
lambda: 0.5304163  function: -183.4009  Jacobian: -1.865308  SSE: 4738.889 
lambda: 0.5557478  function: -183.3812  Jacobian: -2.080853  SSE: 4693.62 
lambda: 0.6216813  function: -183.4637  Jacobian: -2.727084  SSE: 4586.84 
lambda: 0.5627129  function: -183.3805  Jacobian: -2.143105  SSE: 4681.563 
lambda: 0.5618852  function: -183.3805  Jacobian: -2.135638  SSE: 4682.987 
lambda: 0.5617866  function: -183.3805  Jacobian: -2.134749  SSE: 4683.157 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.15 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
lambda: 0.5617902  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.151 
lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151 
> summary(COL.errW.M, correlation=TRUE)

Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw, 
    method = "Matrix", quiet = FALSE, trs = trMatc)

Residuals:
      Min        1Q    Median        3Q       Max 
-34.81174  -6.44031  -0.72142   7.61476  23.33626 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 59.893219   5.366163 11.1613 < 2.2e-16
INC         -0.941312   0.330569 -2.8476 0.0044057
HOVAL       -0.302250   0.090476 -3.3407 0.0008358

Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945
Asymptotic standard error: 0.13387
    z-value: 4.1966, p-value: 2.7098e-05
Wald statistic: 17.611, p-value: 2.7098e-05

Log likelihood: -183.3805 for error model
ML residual variance (sigma squared): 95.575, (sigma: 9.7762)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 376.76, (AIC for lm: 382.75)

 Correlation of coefficients 
            sigma lambda (Intercept) INC  
lambda      -0.24                         
(Intercept)  0.00  0.00                   
INC          0.00  0.00  -0.56            
HOVAL        0.00  0.00  -0.26       -0.45

> COL.SDEMW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  lw, method="eigen", etype="emixed")
> summary(COL.SDEMW.eig, correlation=TRUE)

Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw, 
    etype = "emixed", method = "eigen")

Residuals:
      Min        1Q    Median        3Q       Max 
-37.31635  -6.54376  -0.22212   6.44591  23.15801 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 73.545133   8.783543  8.3731 < 2.2e-16
INC         -1.051673   0.319514 -3.2915 0.0009966
HOVAL       -0.275608   0.091151 -3.0236 0.0024976
lag.INC     -1.156711   0.578629 -1.9991 0.0456024
lag.HOVAL    0.111691   0.198993  0.5613 0.5746048

Lambda: 0.4254, LR test value: 4.9871, p-value: 0.025537
Asymptotic standard error: 0.15842
    z-value: 2.6852, p-value: 0.0072485
Wald statistic: 7.2103, p-value: 0.0072485

Log likelihood: -181.5846 for error model
ML residual variance (sigma squared): 92.531, (sigma: 9.6193)
Number of observations: 49 
Number of parameters estimated: 7 
AIC: 377.17, (AIC for lm: 380.16)

 Correlation of coefficients 
            sigma lambda (Intercept) INC   HOVAL lag.INC
lambda      -0.19                                       
(Intercept)  0.00  0.00                                 
INC          0.00  0.00  -0.25                          
HOVAL        0.00  0.00  -0.18       -0.45              
lag.INC      0.00  0.00  -0.40       -0.05 -0.17        
lag.HOVAL    0.00  0.00  -0.38       -0.04  0.20 -0.56  

> COL.SLX <- lmSLX(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw)
> summary(COL.SLX)

Call:
lm(formula = nfo, data = data, na.action = na.action)

Residuals:
    Min      1Q  Median      3Q     Max 
-36.536  -7.835   0.474   8.349  25.594 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  75.0287     6.6260  11.323 1.26e-14 ***
INC          -1.1089     0.3738  -2.967  0.00485 ** 
HOVAL        -0.2897     0.1014  -2.858  0.00649 ** 
WX.INC       -1.3710     0.5613  -2.443  0.01867 *  
WX.HOVAL      0.1918     0.2003   0.957  0.34369    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 10.93 on 44 degrees of freedom
Multiple R-squared:  0.6088,	Adjusted R-squared:  0.5732 
F-statistic: 17.12 on 4 and 44 DF,  p-value: 1.553e-08

> COL.SLX <- lmSLX(CRIME ~ INC + HOVAL + I(HOVAL^2), data=COL.OLD, listw=lw)
> summary(COL.SLX)

Call:
lm(formula = nfo, data = data, na.action = na.action)

Residuals:
    Min      1Q  Median      3Q     Max 
-33.974  -7.764   0.907   6.820  24.395 

Coefficients:
               Estimate Std. Error t value Pr(>|t|)    
(Intercept)   92.459835  19.278187   4.796 2.06e-05 ***
INC           -0.947594   0.398833  -2.376   0.0221 *  
HOVAL         -0.777428   0.464457  -1.674   0.1016    
I(HOVAL^2)     0.004640   0.004226   1.098   0.2785    
WX.INC        -1.275339   0.596874  -2.137   0.0385 *  
WX.HOVAL      -0.355048   0.982132  -0.362   0.7195    
WX.I(HOVAL^2)  0.005608   0.009084   0.617   0.5403    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 10.99 on 42 degrees of freedom
Multiple R-squared:  0.6224,	Adjusted R-squared:  0.5684 
F-statistic: 11.54 on 6 and 42 DF,  p-value: 1.361e-07

> NA.COL.OLD <- COL.OLD
> NA.COL.OLD$CRIME[20:25] <- NA
> COL.err.NA <- errorsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,
+  nb2listw(COL.nb), na.action=na.exclude)
> COL.err.NA$na.action
1020 1021 1022 1023 1024 1025 
  20   21   22   23   24   25 
attr(,"class")
[1] "exclude"
> COL.err.NA

Call:
errorsarlm(formula = CRIME ~ INC + HOVAL, data = NA.COL.OLD, 
    listw = nb2listw(COL.nb), na.action = na.exclude)
Type: error 

Coefficients:
     lambda (Intercept)         INC       HOVAL 
  0.5748430  58.2460528  -0.8473028  -0.3024909 

Log likelihood: -161.8763 
> resid(COL.err.NA)
        1001         1002         1003         1004         1005         1006 
 -4.18270830 -11.44133842   0.31874928 -34.47163074   2.42244758  -4.32095072 
        1007         1008         1009         1010         1011         1012 
  8.66744165 -13.38669935  -1.92276585  17.85753951  -1.11484596  -2.30434792 
        1013         1014         1015         1016         1017         1018 
 -8.16935116  -5.80500231   0.14973721   5.93191444  -7.03028271   2.39112829 
        1019         1020         1021         1022         1023         1024 
 -8.95099917           NA           NA           NA           NA           NA 
        1025         1026         1027         1028         1029         1030 
          NA  -2.52940711  -9.60025384  -6.95635586  -0.43630579   5.98493664 
        1031         1032         1033         1034         1035         1036 
  6.25882669   7.75527031  10.83413235  23.23927250  -0.05594958   1.43808573 
        1037         1038         1039         1040         1041         1042 
  9.51995265  12.18295373   8.31031724  17.06834503   7.04418392   7.50088924 
        1043         1044         1045         1046         1047         1048 
 -7.78485976  -6.79207446  -7.94977534 -11.25362117  -5.68994630   5.04837399 
        1049 
  2.22497381 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("errorsarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geary")
> ### * geary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geary
> ### Title: Compute Geary's C
> ### Aliases: geary
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> col.W <- nb2listw(COL.nb, style="W")
> str(geary(COL.OLD$CRIME, col.W, length(COL.nb), length(COL.nb)-1,
+  Szero(col.W)))
List of 2
 $ C: num 0.53
 $ K: num 2.23
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geary.mc")
> ### * geary.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geary.mc
> ### Title: Permutation test for Geary's C statistic
> ### Aliases: geary.mc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> sim1 <- geary.mc(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
+  nsim=99, alternative="less")
> sim1

	Monte-Carlo simulation of Geary's C

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb, style = "W") 
number of simulations + 1: 100 

statistic = 0.52987, observed rank = 1, p-value = 0.99
alternative hypothesis: less

> mean(sim1$res)
[1] 0.9899218
> var(sim1$res)
[1] 0.008075363
> summary(sim1$res)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.5299  0.9419  0.9904  0.9899  1.0450  1.1740 
> colold.lags <- nblag(COL.nb, 3)
> sim2 <- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
+  style="W"), nsim=99)
> sim2

	Monte-Carlo simulation of Geary's C

data:  COL.OLD$CRIME 
weights: nb2listw(colold.lags[[2]], style = "W") 
number of simulations + 1: 100 

statistic = 0.81129, observed rank = 1, p-value = 0.01
alternative hypothesis: greater

> summary(sim2$res)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.8113  0.9398  1.0010  0.9954  1.0400  1.1530 
> sim3 <- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
+  style="W"), nsim=99)
> sim3

	Monte-Carlo simulation of Geary's C

data:  COL.OLD$CRIME 
weights: nb2listw(colold.lags[[3]], style = "W") 
number of simulations + 1: 100 

statistic = 1.1303, observed rank = 96, p-value = 0.96
alternative hypothesis: greater

> summary(sim3$res)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.7883  0.9357  0.9938  0.9900  1.0340  1.1900 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geary.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geary.test")
> ### * geary.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geary.test
> ### Title: Geary's C test for spatial autocorrelation
> ### Aliases: geary.test
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"))

	Geary's C test under randomisation

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb, style = "W") 

Geary C statistic standard deviate = 4.7605, p-value = 9.655e-07
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
       0.52986993        1.00000000        0.00975278 

> geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
+  randomisation=FALSE)

	Geary's C test under normality

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb, style = "W") 

Geary C statistic standard deviate = 4.6388, p-value = 1.752e-06
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
       0.52986993        1.00000000        0.01027137 

> colold.lags <- nblag(COL.nb, 3)
> geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
+  style="W"))

	Geary's C test under randomisation

data:  COL.OLD$CRIME 
weights: nb2listw(colold.lags[[2]], style = "W") 

Geary C statistic standard deviate = 2.2896, p-value = 0.01102
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      0.811285136       1.000000000       0.006793327 

> geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
+  style="W"), alternative="greater")

	Geary's C test under randomisation

data:  COL.OLD$CRIME 
weights: nb2listw(colold.lags[[3]], style = "W") 

Geary C statistic standard deviate = -1.5667, p-value = 0.9414
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      1.130277918       1.000000000       0.006914551 

> print(is.symmetric.nb(COL.nb))
[1] TRUE
> coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y)
> COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4))
> print(is.symmetric.nb(COL.k4.nb))
[1] FALSE
> geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"))

	Geary's C test under randomisation

data:  COL.OLD$CRIME 
weights: nb2listw(COL.k4.nb, style = "W") 

Geary C statistic standard deviate = 6.4415, p-value = 5.916e-11
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      0.399254423       1.000000000       0.008697812 

> geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"),
+  randomisation=FALSE)

	Geary's C test under normality

data:  COL.OLD$CRIME 
weights: nb2listw(COL.k4.nb, style = "W") 

Geary C statistic standard deviate = 6.2873, p-value = 1.615e-10
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      0.399254423       1.000000000       0.009129529 

> cat("Note non-symmetric weights matrix - use listw2U()\n")
Note non-symmetric weights matrix - use listw2U()
> geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
+  style="W")))

	Geary's C test under randomisation

data:  COL.OLD$CRIME 
weights: listw2U(nb2listw(COL.k4.nb, style = "W")) 

Geary C statistic standard deviate = 6.4415, p-value = 5.916e-11
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      0.399254423       1.000000000       0.008697812 

> geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
+  style="W")), randomisation=FALSE)

	Geary's C test under normality

data:  COL.OLD$CRIME 
weights: listw2U(nb2listw(COL.k4.nb, style = "W")) 

Geary C statistic standard deviate = 6.2873, p-value = 1.615e-10
alternative hypothesis: Expectation greater than statistic
sample estimates:
Geary C statistic       Expectation          Variance 
      0.399254423       1.000000000       0.009129529 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geary.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getisord")
> ### * getisord
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getisord
> ### Title: Getis-Ord remote sensing example data
> ### Aliases: getisord x y xyz
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(getisord)
> image(x, y, t(matrix(xyz$val, nrow=16, ncol=16, byrow=TRUE)), asp=1)
> text(xyz$x, xyz$y, xyz$val, cex=0.7)
> polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
> title(main="Getis-Ord 1996 remote sensing data")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getisord", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("globalG.test")
> ### * globalG.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: globalG.test
> ### Title: Global G test for spatial autocorrelation
> ### Aliases: globalG.test
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(nc.sids)

nc.sds> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

nc.sds> nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],
nc.sds+   ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

nc.sds> rn <- sapply(slot(nc.sids, "polygons"), function(x) slot(x, "ID"))

nc.sds> ncCC89_nb <- read.gal(system.file("etc/weights/ncCC89.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ncCR85_nb <- read.gal(system.file("etc/weights/ncCR85.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ## Not run: 
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCR85_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCC89_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ## End(Not run)
nc.sds> 
nc.sds> 
nc.sds> 
> sidsrate79 <- (1000*nc.sids$SID79)/nc.sids$BIR79
> dists <- c(10, 20, 30, 33, 40, 50, 60, 70, 80, 90, 100)
> ndists <- length(dists)
> ZG <- vector(mode="list", length=ndists)
> names(ZG) <- as.character(dists)
> milesxy <- cbind(nc.sids$east, nc.sids$north)
> for (i in 1:ndists) {
+   thisnb <- dnearneigh(milesxy, 0, dists[i])
+   thislw <- nb2listw(thisnb, style="B", zero.policy=TRUE)
+   ZG[[i]] <- globalG.test(sidsrate79, thislw, zero.policy=TRUE)
+ }
> t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value))))
    Global G statistic standard deviate   p.value
10         0.000612124       0.81651489 0.2071029
20         0.014698945       0.27046614 0.3934008
30         0.039947466      -0.11849772 0.5471634
33         0.053122713       0.40157023 0.3440002
40         0.074002794      -0.04345713 0.5173314
50         0.114717434       0.58686472 0.2786473
60         0.154575526      -0.35823892 0.6399177
70         0.198390232      -0.27864299 0.6097406
80         0.246069725      -0.18791364 0.5745278
90         0.300734634       0.11457610 0.4543906
100        0.348799963       0.31591356 0.3760341
> for (i in 1:ndists) {
+   thisnb <- dnearneigh(milesxy, 0, dists[i])
+   thislw <- nb2listw(thisnb, style="B", zero.policy=TRUE)
+   ZG[[i]] <- globalG.test(sidsrate79, thislw, zero.policy=TRUE, alternative="two.sided")
+ }
> t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value))))
    Global G statistic standard deviate   p.value
10         0.000612124       0.81651489 0.4142057
20         0.014698945       0.27046614 0.7868017
30         0.039947466      -0.11849772 0.9056733
33         0.053122713       0.40157023 0.6880003
40         0.074002794      -0.04345713 0.9653371
50         0.114717434       0.58686472 0.5572946
60         0.154575526      -0.35823892 0.7201645
70         0.198390232      -0.27864299 0.7805188
80         0.246069725      -0.18791364 0.8509443
90         0.300734634       0.11457610 0.9087811
100        0.348799963       0.31591356 0.7520681
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("globalG.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("graphneigh")
> ### * graphneigh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: graphneigh
> ### Title: Graph based spatial weights
> ### Aliases: gabrielneigh relativeneigh soi.graph plot.Gabriel
> ###   plot.relative graph2nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> par(mfrow=c(2,2))
> col.tri.nb<-tri2nb(coords)

     PLEASE NOTE:  The components "delsgs" and "summary" of the
 object returned by deldir() are now DATA FRAMES rather than
 matrices (as they were prior to release 0.0-18).
 See help("deldir").
 
     PLEASE NOTE: The process that deldir() uses for determining
 duplicated points has changed from that used in version
 0.0-9 of this package (and previously). See help("deldir").


> col.gab.nb<-graph2nb(gabrielneigh(coords), sym=TRUE)
> col.rel.nb<- graph2nb(relativeneigh(coords), sym=TRUE)
> col.soi.nb<- graph2nb(soi.graph(col.tri.nb,coords), sym=TRUE)
> plot(columbus, border="grey")
> plot(col.tri.nb,coords,add=TRUE)
> title(main="Delaunay Triangulation")
> plot(columbus, border="grey")
> plot(col.gab.nb, coords, add=TRUE)
> title(main="Gabriel Graph")
> plot(columbus, border="grey")
> plot(col.rel.nb, coords, add=TRUE)
> title(main="Relative Neighbor Graph")
> plot(columbus, border="grey")
> plot(col.soi.nb, coords, add=TRUE)
> title(main="Sphere of Influence Graph")
> par(mfrow=c(1,1))
> dx <- rep(0.25*0:4,5)
> dy <- c(rep(0,5),rep(0.25,5),rep(0.5,5), rep(0.75,5),rep(1,5))
> m <- cbind(c(dx, dx, 3+dx, 3+dx), c(dy, 3+dy, dy, 3+dy))
> try(res <- gabrielneigh(m))
Error in gabrielneigh(m) : number of neighbours overrun - increase nnmult
> res <- gabrielneigh(m, nnmult=4)
> summary(graph2nb(res))
Neighbour list object:
Number of regions: 100 
Number of nonzero links: 342 
Percentage nonzero weights: 3.42 
Average number of links: 3.42 
1 region with no links:
100
Non-symmetric neighbours list
Link number distribution:

 0  1  2  3  4  5 
 1  8 10 18 55  8 
8 least connected regions:
46 47 48 49 96 97 98 99 with 1 link
8 most connected regions:
10 15 20 25 30 35 40 45 with 5 links
> grd <- as.matrix(expand.grid(x=1:5, y=1:5)) #gridded data
> r2 <- gabrielneigh(grd)
> set.seed(1)
> grd1 <- as.matrix(expand.grid(x=1:5, y=1:5)) + matrix(runif(50, .0001, .0006), nrow=25)
> r3 <- gabrielneigh(grd1)
> opar <- par(mfrow=c(1,2))
> plot(r2, show=TRUE, linecol=2)
> plot(r3, show=TRUE, linecol=2)
> par(opar)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("graphneigh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:maptools’

> nameEx("gstsls")
> ### * gstsls
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: gstsls
> ### Title: Spatial simultaneous autoregressive SAC model estimation by GMM
> ### Aliases: gstsls
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.errW.GM <- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb, style="W"))
> summary(COL.errW.GM)

Call:
gstsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"))

Residuals:
      Min        1Q    Median        3Q       Max 
-37.87710  -5.74981  -0.21447   6.19490  22.85527 

Type: GM SARAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
Rho_Wy       0.454171   0.185680  2.4460   0.01445
(Intercept) 43.782818  10.923192  4.0082 6.117e-05
INC         -0.994831   0.382774 -2.5990   0.00935
HOVAL       -0.267076   0.091984 -2.9035   0.00369

Lambda: 0.016647
Residual variance (sigma squared): 103.36, (sigma: 10.167)
GM argmin sigma squared: 93.729
Number of observations: 49 
Number of parameters estimated: 6 

> aa <- GMargminImage(COL.errW.GM)
> levs <- quantile(aa$z, seq(0, 1, 1/12))
> image(aa, breaks=levs, xlab="lambda", ylab="s2")
> points(COL.errW.GM$lambda, COL.errW.GM$s2, pch=3, lwd=2)
> contour(aa, levels=signif(levs, 4), add=TRUE)
> COL.errW.GM <- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb, style="W"), scaleU=TRUE)
> summary(COL.errW.GM)

Call:
gstsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), scaleU = TRUE)

Residuals:
      Min        1Q    Median        3Q       Max 
-37.87710  -5.74981  -0.21447   6.19490  22.85527 

Type: GM SARAR estimator
Coefficients: (GM standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
Rho_Wy       0.454171   0.185680  2.4460   0.01445
(Intercept) 43.782818  10.923192  4.0082 6.117e-05
INC         -0.994831   0.382774 -2.5990   0.00935
HOVAL       -0.267076   0.091984 -2.9035   0.00369

Lambda: 0.016647
Residual variance (sigma squared): 103.36, (sigma: 10.167)
(scaled) GM argmin sigma squared: 0.96653
Number of observations: 49 
Number of parameters estimated: 6 

> listw <- nb2listw(COL.nb)
> W <- as(listw, "CsparseMatrix")
> trMat <- trW(W, type="mult")
> impacts(COL.errW.GM, tr=trMat)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.0543769 -0.7682309 -1.8226078
HOVAL -0.2830618 -0.2062420 -0.4893038
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("gstsls", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hopkins")
> ### * hopkins
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hopkins
> ### Title: Hopkins burnt savanna herb remains
> ### Aliases: hopkins
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(hopkins)
> image(1:32, 1:32, hopkins[5:36,36:5], breaks=c(-0.5, 3.5, 20),
+  col=c("white", "black"))
> box()
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hopkins", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("house")
> ### * house
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: house
> ### Title: Lucas county OH housing
> ### Aliases: house LO_nb trMat
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # house <- read.table("house.dat", header=FALSE)
> ##D # names(house) <- c("price", "yrbuilt", "stories", "TLA", "wall", "beds",
> ##D #   "baths", "halfbaths", "frontage", "depth", "garage", "garagesqft", "rooms",
> ##D #   "lotsize", "sdate", "avalue", "long", "lat", "s1993", "s1994", "s1995",
> ##D #   "s1996", "s1997", "s1998")
> ##D # house$syear <- 1992 + house$s1993 + 2*house$s1994 + 3*house$s1995 +
> ##D # 4*house$s1996 + 5*house$s1997 + 6*house$s1998
> ##D # house$syear <- factor(house$syear)
> ##D # house$age <- (1999 - house$yrbuilt)/100
> ##D # house$stories <- factor(house$stories, levels=1:7, labels=c("one",
> ##D #  "bilevel", "multilvl", "one+half", "two", "two+half", "three"))
> ##D # house$wall <- factor(house$wall, levels=1:7, labels=c("stucdrvt",
> ##D #  "ccbtile", "metlvnyl", "brick", "stone", "wood", "partbrk"))
> ##D # house$garage <- factor(house$garage, levels=0:4, labels=c("no garage",
> ##D #  "basement", "attached", "detached", "carport"))
> ##D # library(sp)
> ##D # coordinates(house) <- c("long", "lat")
> ##D # proj4string(house) <- CRS("+proj=longlat")
> ##D # library(rgdal)
> ##D # house <- spTransform(house, CRS("+init=epsg:2834"))
> ##D # library(spdep)
> ##D # LO_nb <- graph2nb(soi.graph(tri2nb(coordinates(house)), coordinates(house)))
> ##D # W <- as(nb2listw(LO_nb), "CsparseMatrix")
> ##D # trMat <- trW(W, type="mult")
> ## End(Not run)
> data(house)
> ## maybe str(house) ; plot(house) ...
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("house", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("huddersfield")
> ### * huddersfield
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: huddersfield
> ### Title: Prevalence of respiratory symptoms
> ### Aliases: huddersfield
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(huddersfield)
> str(huddersfield)
'data.frame':	71 obs. of  2 variables:
 $ cases: int  21 22 47 3 8 25 31 26 12 5 ...
 $ total: int  49 76 166 14 24 81 92 57 45 17 ...
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("huddersfield", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("impacts.sarlm")
> ### * impacts.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: impacts
> ### Title: Impacts in spatial lag models
> ### Aliases: impacts impacts.sarlm impacts.stsls impacts.gmsar
> ###   plot.lagImpact print.lagImpact summary.lagImpact
> ###   print.summary.lagImpact HPDinterval.lagImpact intImpacts
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> listw <- nb2listw(col.gal.nb)
> lobj <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw)
> summary(lobj)

Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw)

Residuals:
        Min          1Q      Median          3Q         Max 
-37.4497093  -5.4565567   0.0016387   6.7159553  24.7107978 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 46.851431   7.314754  6.4051 1.503e-10
INC         -1.073533   0.310872 -3.4533 0.0005538
HOVAL       -0.269997   0.090128 -2.9957 0.0027381

Rho: 0.40389, LR test value: 8.4179, p-value: 0.0037154
Asymptotic standard error: 0.12071
    z-value: 3.3459, p-value: 0.00082027
Wald statistic: 11.195, p-value: 0.00082027

Log likelihood: -183.1683 for lag model
ML residual variance (sigma squared): 99.164, (sigma: 9.9581)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 376.34, (AIC for lm: 382.75)
LM test for residual autocorrelation
test value: 0.19184, p-value: 0.66139

> mobj <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type="mixed")
> summary(mobj)

Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw, 
    type = "mixed")

Residuals:
      Min        1Q    Median        3Q       Max 
-37.15904  -6.62594  -0.39823   6.57561  23.62757 

Type: mixed 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 45.592893  13.128679  3.4728 0.0005151
INC         -0.939088   0.338229 -2.7765 0.0054950
HOVAL       -0.299605   0.090843 -3.2980 0.0009736
lag.INC     -0.618375   0.577052 -1.0716 0.2838954
lag.HOVAL    0.266615   0.183971  1.4492 0.1472760

Rho: 0.38251, LR test value: 4.1648, p-value: 0.041272
Asymptotic standard error: 0.16237
    z-value: 2.3557, p-value: 0.018488
Wald statistic: 5.5493, p-value: 0.018488

Log likelihood: -182.0161 for mixed model
ML residual variance (sigma squared): 95.051, (sigma: 9.7494)
Number of observations: 49 
Number of parameters estimated: 7 
AIC: 378.03, (AIC for lm: 380.2)
LM test for residual autocorrelation
test value: 0.101, p-value: 0.75063

> W <- as(listw, "CsparseMatrix")
> trMatc <- trW(W, type="mult")
> trMC <- trW(W, type="MC")
> impacts(lobj, listw=listw)
Impact measures (lag, exact):
          Direct   Indirect      Total
INC   -1.1225156 -0.6783818 -1.8008973
HOVAL -0.2823163 -0.1706152 -0.4529315
> impacts(lobj, tr=trMatc)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.1225156 -0.6783818 -1.8008973
HOVAL -0.2823163 -0.1706152 -0.4529315
> impacts(lobj, tr=trMC)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.1199681 -0.6809292 -1.8008973
HOVAL -0.2816756 -0.1712559 -0.4529315
> lobj1 <- stsls(CRIME ~ INC + HOVAL, columbus, listw)
> loobj1 <- impacts(lobj1, tr=trMatc, R=200)
> summary(loobj1, zstats=TRUE, short=TRUE)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.0687585 -0.7790438 -1.8478023
HOVAL -0.2858263 -0.2083456 -0.4941719
========================================================
Simulation results (asymptotic IV variance matrix):
========================================================
Simulated z-values:
         Direct   Indirect      Total
INC   -2.454864 -0.6628772 -1.3977000
HOVAL -1.862901 -0.1869283 -0.2921031

Simulated p-values:
      Direct   Indirect Total  
INC   0.014094 0.50741  0.16220
HOVAL 0.062476 0.85172  0.77021
> lobj1r <- stsls(CRIME ~ INC + HOVAL, columbus, listw, robust=TRUE)
> loobj1r <- impacts(lobj1r, tr=trMatc, R=200)
> summary(loobj1r, zstats=TRUE, short=TRUE)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.0687585 -0.7790438 -1.8478023
HOVAL -0.2858263 -0.2083456 -0.4941719
========================================================
Simulation results (HC0 IV variance matrix):
========================================================
Simulated z-values:
         Direct   Indirect     Total
INC   -1.993299 -0.7981011 -1.378948
HOVAL -1.482875 -0.9784889 -1.318319

Simulated p-values:
      Direct   Indirect Total  
INC   0.046229 0.42481  0.16791
HOVAL 0.138108 0.32783  0.18740
> lobjIQ5 <- impacts(lobj, tr=trMatc, R=200, Q=5)
> summary(lobjIQ5, zstats=TRUE, short=TRUE)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.1225156 -0.6783818 -1.8008973
HOVAL -0.2823163 -0.1706152 -0.4529315
========================================================
Simulation results (asymptotic variance matrix):
========================================================
Simulated z-values:
         Direct  Indirect     Total
INC   -3.297143 -1.674283 -2.871887
HOVAL -2.712325 -1.417221 -2.219718

Simulated p-values:
      Direct     Indirect Total    
INC   0.00097674 0.094075 0.0040803
HOVAL 0.00668131 0.156418 0.0264379
> summary(lobjIQ5, zstats=TRUE, short=TRUE, reportQ=TRUE)
Impact measures (lag, trace):
          Direct   Indirect      Total
INC   -1.1225156 -0.6783818 -1.8008973
HOVAL -0.2823163 -0.1706152 -0.4529315
=================================
Impact components
$direct
            INC         HOVAL
Q1 -1.073533465 -0.2699971236
Q2  0.000000000  0.0000000000
Q3 -0.038985415 -0.0098049573
Q4 -0.005269654 -0.0013253350
Q5 -0.003276079 -0.0008239444

$indirect
           INC        HOVAL
Q1  0.00000000  0.000000000
Q2 -0.43358910 -0.109049054
Q3 -0.13613675 -0.034238831
Q4 -0.06546038 -0.016463497
Q5 -0.02529105 -0.006360781

$total
           INC        HOVAL
Q1 -1.07353347 -0.269997124
Q2 -0.43358910 -0.109049054
Q3 -0.17512216 -0.044043788
Q4 -0.07073004 -0.017788832
Q5 -0.02856713 -0.007184726

========================================================
Simulation results (asymptotic variance matrix):
========================================================
Simulated z-values:
         Direct  Indirect     Total
INC   -3.297143 -1.674283 -2.871887
HOVAL -2.712325 -1.417221 -2.219718

Simulated p-values:
      Direct     Indirect Total    
INC   0.00097674 0.094075 0.0040803
HOVAL 0.00668131 0.156418 0.0264379
========================================================
Simulated impact components z-values:
$Direct
         INC      HOVAL
Q1 -3.229315 -2.7271218
Q2       NaN        NaN
Q3 -1.589148 -1.3641845
Q4 -1.104976 -0.9963169
Q5 -0.814162 -0.7628893

$Indirect
         INC      HOVAL
Q1       NaN        NaN
Q2 -2.505958 -1.9869278
Q3 -1.589148 -1.3641845
Q4 -1.104976 -0.9963169
Q5 -0.814162 -0.7628893

$Total
         INC      HOVAL
Q1 -3.229315 -2.7271218
Q2 -2.505958 -1.9869278
Q3 -1.589148 -1.3641845
Q4 -1.104976 -0.9963169
Q5 -0.814162 -0.7628893


Simulated impact components p-values:
$Direct
   INC       HOVAL    
Q1 0.0012409 0.0063889
Q2 NA        NA       
Q3 0.1120271 0.1725095
Q4 0.2691700 0.3190962
Q5 0.4155522 0.4455294

$Indirect
   INC      HOVAL  
Q1 NA       NA     
Q2 0.012212 0.04693
Q3 0.112027 0.17251
Q4 0.269170 0.31910
Q5 0.415552 0.44553

$Total
   INC       HOVAL    
Q1 0.0012409 0.0063889
Q2 0.0122120 0.0469304
Q3 0.1120271 0.1725095
Q4 0.2691700 0.3190962
Q5 0.4155522 0.4455294

> impacts(mobj, listw=listw)
Impact measures (mixed, exact):
          Direct   Indirect       Total
INC   -1.0418080 -1.4804246 -2.52223256
HOVAL -0.2836325  0.2302055 -0.05342697
> impacts(mobj, tr=trMatc)
Impact measures (mixed, trace):
          Direct   Indirect       Total
INC   -1.0418080 -1.4804246 -2.52223256
HOVAL -0.2836325  0.2302055 -0.05342697
> impacts(mobj, tr=trMC)
Impact measures (mixed, trace):
          Direct   Indirect       Total
INC   -1.0367875 -1.4854450 -2.52223256
HOVAL -0.2844132  0.2309862 -0.05342697
> summary(impacts(mobj, tr=trMatc, R=200), zstats=TRUE)
Impact measures (mixed, trace):
          Direct   Indirect       Total
INC   -1.0418080 -1.4804246 -2.52223256
HOVAL -0.2836325  0.2302055 -0.05342697
========================================================
Simulation results (asymptotic variance matrix):
Direct:

Iterations = 1:200
Thinning interval = 1 
Number of chains = 1 
Sample size per chain = 200 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

        Mean     SD Naive SE Time-series SE
INC   -1.022 0.3072 0.021722       0.021722
HOVAL -0.286 0.1007 0.007121       0.007121

2. Quantiles for each variable:

         2.5%     25%     50%     75%    97.5%
INC   -1.6501 -1.2163 -1.0095 -0.8196 -0.39056
HOVAL -0.4753 -0.3621 -0.2793 -0.2218 -0.09573

========================================================
Indirect:

Iterations = 1:200
Thinning interval = 1 
Number of chains = 1 
Sample size per chain = 200 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

         Mean     SD Naive SE Time-series SE
INC   -1.5112 1.0453  0.07392        0.07392
HOVAL  0.2464 0.4073  0.02880        0.02880

2. Quantiles for each variable:

         2.5%     25%     50%     75%  97.5%
INC   -3.0058 -2.0656 -1.4620 -1.0549 0.1635
HOVAL -0.3762  0.0421  0.2292  0.4482 0.8577

========================================================
Total:

Iterations = 1:200
Thinning interval = 1 
Number of chains = 1 
Sample size per chain = 200 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

          Mean     SD Naive SE Time-series SE
INC   -2.53306 1.1068  0.07826        0.08742
HOVAL -0.03966 0.4455  0.03150        0.03150

2. Quantiles for each variable:

         2.5%     25%      50%     75%   97.5%
INC   -4.1568 -3.0674 -2.50840 -2.0026 -0.9447
HOVAL -0.6641 -0.2693 -0.04279  0.1696  0.7027

========================================================
Simulated z-values:
         Direct   Indirect       Total
INC   -3.326518 -1.4456460 -2.28873543
HOVAL -2.840030  0.6048861 -0.08902145

Simulated p-values:
      Direct     Indirect Total   
INC   0.00087938 0.14828  0.022095
HOVAL 0.00451093 0.54525  0.929065
> ## Not run: 
> ##D mobj1 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type="mixed", 
> ##D method="Matrix", control=list(fdHess=TRUE))
> ##D summary(mobj1)
> ##D summary(impacts(mobj1, tr=trMatc, R=1000), zstats=TRUE, short=TRUE)
> ##D summary(impacts(mobj, tr=trMatc, R=1000), zstats=TRUE, short=TRUE)
> ##D mobj2 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type="mixed", 
> ##D method="Matrix", control=list(fdHess=TRUE, optimHess=TRUE))
> ##D summary(impacts(mobj2, tr=trMatc, R=1000), zstats=TRUE, short=TRUE)
> ##D mobj3 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type="mixed", 
> ##D method="spam", control=list(fdHess=TRUE))
> ##D summary(impacts(mobj3, tr=trMatc, R=1000), zstats=TRUE, short=TRUE)
> ##D data(boston)
> ##D Wb <- as(nb2listw(boston.soi), "CsparseMatrix")
> ##D trMatb <- trW(Wb, type="mult")
> ##D gp2mMi <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
> ##D I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), 
> ##D data=boston.c, nb2listw(boston.soi), type="mixed", method="Matrix", 
> ##D control=list(fdHess=TRUE), trs=trMatb)
> ##D summary(gp2mMi)
> ##D summary(impacts(gp2mMi, tr=trMatb, R=1000), zstats=TRUE, short=TRUE)
> ##D data(house)
> ##D lw <- nb2listw(LO_nb)
> ##D form <- formula(log(price) ~ age + I(age^2) + I(age^3) + log(lotsize) +
> ##D    rooms + log(TLA) + beds + syear)
> ##D lobj <- lagsarlm(form, house, lw, method="Matrix",
> ##D  control=list(fdHess=TRUE), trs=trMat)
> ##D summary(lobj)
> ##D loobj <- impacts(lobj, tr=trMat, R=1000)
> ##D summary(loobj, zstats=TRUE, short=TRUE)
> ##D lobj1 <- stsls(form, house, lw)
> ##D loobj1 <- impacts(lobj1, tr=trMat, R=1000)
> ##D summary(loobj1, zstats=TRUE, short=TRUE)
> ##D mobj <- lagsarlm(form, house, lw, type="mixed",
> ##D  method="Matrix", control=list(fdHess=TRUE), trs=trMat)
> ##D summary(mobj)
> ##D moobj <- impacts(mobj, tr=trMat, R=1000)
> ##D summary(moobj, zstats=TRUE, short=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("impacts.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("include.self")
> ### * include.self
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: include.self
> ### Title: Include self in neighbours list
> ### Aliases: include.self
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> summary(col.gal.nb, coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Link number distribution:

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 2 links
1 most connected region:
20 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1276  0.3613  0.4566  0.4694  0.5536  0.8924 

  The decimal point is 1 digit(s) to the left of the |

  1 | 3344
  1 | 99
  2 | 000011333344
  2 | 556677779999
  3 | 000011222222223344444444
  3 | 556666777777888888889999999999
  4 | 00001111112233333333334444
  4 | 55666666666666777777777788888899
  5 | 0011112222222222222233334444
  5 | 556666667788
  6 | 000000112244
  6 | 5577889999
  7 | 11112244
  7 | 557777
  8 | 1144
  8 | 55999999

> summary(include.self(col.gal.nb), coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 279 
Percentage nonzero weights: 11.62016 
Average number of links: 5.693878 
Link number distribution:

 3  4  5  6  7  8  9 10 11 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 3 links
1 most connected region:
20 with 11 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.2576  0.4073  0.3870  0.5232  0.8924 

  The decimal point is 1 digit(s) to the left of the |

  0 | 0000000000000000000000000000000000000000000000000
  0 | 
  1 | 3344
  1 | 99
  2 | 000011333344
  2 | 556677779999
  3 | 000011222222223344444444
  3 | 556666777777888888889999999999
  4 | 00001111112233333333334444
  4 | 55666666666666777777777788888899
  5 | 0011112222222222222233334444
  5 | 556666667788
  6 | 000000112244
  6 | 5577889999
  7 | 11112244
  7 | 557777
  8 | 1144
  8 | 55999999

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("include.self", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("invIrM")
> ### * invIrM
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: invIrM
> ### Title: Compute SAR generating operator
> ### Aliases: invIrM invIrW powerWeights
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> nb7rt <- cell2nb(7, 7, torus=TRUE)
> set.seed(1)
> x <- matrix(rnorm(500*length(nb7rt)), nrow=length(nb7rt))
> res0 <- apply(invIrM(nb7rt, rho=0.0, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> res2 <- apply(invIrM(nb7rt, rho=0.2, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> res4 <- apply(invIrM(nb7rt, rho=0.4, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> res6 <- apply(invIrM(nb7rt, rho=0.6, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> res8 <- apply(invIrM(nb7rt, rho=0.8, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> res9 <- apply(invIrM(nb7rt, rho=0.9, method="chol",
+  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x))
> plot(density(res9), col="red", xlim=c(-0.01, max(density(res9)$x)),
+   ylim=range(density(res0)$y),
+   xlab="estimated variance of the mean",
+   main=expression(paste("Effects of spatial autocorrelation for different ",
+     rho, " values")))
> lines(density(res0), col="black")
> lines(density(res2), col="brown")
> lines(density(res4), col="green")
> lines(density(res6), col="orange")
> lines(density(res8), col="pink")
> legend(c(-0.02, 0.01), c(7, 25),
+  legend=c("0.0", "0.2", "0.4", "0.6", "0.8", "0.9"),
+  col=c("black", "brown", "green", "orange", "pink", "red"), lty=1, bty="n")
> ## Not run: 
> ##D x <- matrix(rnorm(length(nb7rt)), ncol=1)
> ##D system.time(e <- invIrM(nb7rt, rho=0.9, method="chol", feasible=TRUE) %*% x)
> ##D system.time(e <- invIrM(nb7rt, rho=0.9, method="chol", feasible=NULL) %*% x)
> ##D system.time(e <- invIrM(nb7rt, rho=0.9, method="solve", feasible=TRUE) %*% x)
> ##D system.time(e <- invIrM(nb7rt, rho=0.9, method="solve", feasible=NULL) %*% x)
> ##D W <- as(nb2listw(nb7rt), "CsparseMatrix")
> ##D system.time(ee <- powerWeights(W, rho=0.9, X=x))
> ##D all.equal(e, as(ee, "matrix"), check.attributes=FALSE)
> ##D system.time(e <- invIrM(nb7rt, rho=0.98, method="solve", feasible=NULL) %*% x)
> ##D system.time(ee <- powerWeights(W, rho=0.98, X=x))
> ##D str(attr(ee, "internal"))
> ##D all.equal(e, as(ee, "matrix"), check.attributes=FALSE)
> ##D system.time(ee <- powerWeights(W, rho=0.98, order=1000, X=x))
> ##D all.equal(e, as(ee, "matrix"), check.attributes=FALSE)
> ##D nb60rt <- cell2nb(60, 60, torus=TRUE)
> ##D W <- as(nb2listw(nb60rt), "CsparseMatrix")
> ##D set.seed(1)
> ##D x <- matrix(rnorm(dim(W)[1]), ncol=1)
> ##D system.time(ee <- powerWeights(W, rho=0.3, X=x))
> ##D str(as(ee, "matrix"))
> ##D obj <- errorsarlm(as(ee, "matrix")[,1] ~ 1, listw=nb2listw(nb60rt), method="Matrix")
> ##D coefficients(obj)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("invIrM", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("joincount.mc")
> ### * joincount.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: joincount.mc
> ### Title: Permutation test for same colour join count statistics
> ### Aliases: joincount.mc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
> names(HICRIME) <- rownames(COL.OLD)
> joincount.mc(HICRIME, nb2listw(COL.nb, style="B"), nsim=99)

	Monte-Carlo simulation of join-count statistic

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 
number of simulations + 1: 100 

Join-count statistic for low = 34, rank of observed statistic = 86,
p-value = 0.14
alternative hypothesis: greater
sample estimates:
    mean of simulation variance of simulation 
              29.01010               19.29582 


	Monte-Carlo simulation of join-count statistic

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 
number of simulations + 1: 100 

Join-count statistic for high = 54, rank of observed statistic = 100,
p-value = 0.01
alternative hypothesis: greater
sample estimates:
    mean of simulation variance of simulation 
              27.82828               18.06205 

> joincount.test(HICRIME, nb2listw(COL.nb, style="B"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 

Std. deviate for low = 1.0141, p-value = 0.1553
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
             34.00000              29.59184              18.89550 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 

Std. deviate for high = 6.3307, p-value = 1.22e-10
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
             54.00000              27.22449              17.88838 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("joincount.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("joincount.multi")
> ### * joincount.multi
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: joincount.multi
> ### Title: BB, BW and Jtot join count statistic for k-coloured factors
> ### Aliases: joincount.multi print.jcmulti
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
> names(HICRIME) <- rownames(COL.OLD)
> joincount.multi(HICRIME, nb2listw(COL.nb, style="B"))
          Joincount Expected Variance z-value
low:low      34.000   29.592   18.895  1.0141
high:high    54.000   27.224   17.888  6.3307
high:low     28.000   59.184   26.233 -6.0884
Jtot         28.000   59.184   26.233 -6.0884
> ## Not run: 
> ##D data(hopkins)
> ##D image(1:32, 1:32, hopkins[5:36,36:5], breaks=c(-0.5, 3.5, 20),
> ##D  col=c("white", "black"))
> ##D box()
> ##D hopkins.rook.nb <- cell2nb(32, 32, type="rook")
> ##D unlist(spweights.constants(nb2listw(hopkins.rook.nb, style="B")))
> ##D hopkins.queen.nb <- cell2nb(32, 32, type="queen")
> ##D hopkins.bishop.nb <- diffnb(hopkins.rook.nb, hopkins.queen.nb, verbose=FALSE)
> ##D hopkins4 <- hopkins[5:36,36:5]
> ##D hopkins4[which(hopkins4 > 3, arr.ind=TRUE)] <- 4
> ##D hopkins4.f <- factor(hopkins4)
> ##D table(hopkins4.f)
> ##D joincount.multi(hopkins4.f, nb2listw(hopkins.rook.nb, style="B"))
> ##D cat("replicates Upton & Fingleton table 3.4 (p. 166)\n")
> ##D joincount.multi(hopkins4.f, nb2listw(hopkins.bishop.nb, style="B"))
> ##D cat("replicates Upton & Fingleton table 3.6 (p. 168)\n")
> ##D joincount.multi(hopkins4.f, nb2listw(hopkins.queen.nb, style="B"))
> ##D cat("replicates Upton & Fingleton table 3.7 (p. 169)\n")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("joincount.multi", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("joincount.test")
> ### * joincount.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: joincount.test
> ### Title: BB join count statistic for k-coloured factors
> ### Aliases: joincount.test print.jclist
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
> names(HICRIME) <- rownames(COL.OLD)
> joincount.test(HICRIME, nb2listw(COL.nb, style="B"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 

Std. deviate for low = 1.0141, p-value = 0.1553
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
             34.00000              29.59184              18.89550 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "B") 

Std. deviate for high = 6.3307, p-value = 1.22e-10
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
             54.00000              27.22449              17.88838 

> joincount.test(HICRIME, nb2listw(COL.nb, style="C"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "C") 

Std. deviate for low = 1.0141, p-value = 0.1553
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            7.1810345             6.2500000             0.8428969 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "C") 

Std. deviate for high = 6.3307, p-value = 1.22e-10
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
           11.4051724             5.7500000             0.7979712 

> joincount.test(HICRIME, nb2listw(COL.nb, style="S"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "S") 

Std. deviate for low = 2.5786, p-value = 0.00496
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            8.2425673             6.2500000             0.5971141 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "S") 

Std. deviate for high = 6.1736, p-value = 3.337e-10
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
           10.4249914             5.7500000             0.5734265 

> joincount.test(HICRIME, nb2listw(COL.nb, style="W"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "W") 

Std. deviate for low = 4.6675, p-value = 1.524e-06
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            9.5190476             6.2500000             0.4905378 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.nb, style = "W") 

Std. deviate for high = 5.1205, p-value = 1.523e-07
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            9.2920635             5.7500000             0.4784979 

> by(card(COL.nb), HICRIME, summary)
HICRIME: low
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.00    4.00    3.84    4.00   10.00 
------------------------------------------------------------ 
HICRIME: high
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  3.000   4.750   6.000   5.667   7.000   9.000 
> print(is.symmetric.nb(COL.nb))
[1] TRUE
> coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y)
> COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4))
> print(is.symmetric.nb(COL.k4.nb))
[1] FALSE
> joincount.test(HICRIME, nb2listw(COL.k4.nb, style="B"))

	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.k4.nb, style = "B") 

Std. deviate for low = 4.3698, p-value = 6.217e-06
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            36.500000             25.000000              6.925749 


	Join count test under nonfree sampling

data:  HICRIME 
weights: nb2listw(COL.k4.nb, style = "B") 

Std. deviate for high = 6.7293, p-value = 8.523e-12
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            40.500000             23.000000              6.762918 

> cat("Note non-symmetric weights matrix - use listw2U()\n")
Note non-symmetric weights matrix - use listw2U()
> joincount.test(HICRIME, listw2U(nb2listw(COL.k4.nb, style="B")))

	Join count test under nonfree sampling

data:  HICRIME 
weights: listw2U(nb2listw(COL.k4.nb, style = "B")) 

Std. deviate for low = 4.3698, p-value = 6.217e-06
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            36.500000             25.000000              6.925749 


	Join count test under nonfree sampling

data:  HICRIME 
weights: listw2U(nb2listw(COL.k4.nb, style = "B")) 

Std. deviate for high = 6.7293, p-value = 8.523e-12
alternative hypothesis: greater
sample estimates:
Same colour statistic           Expectation              Variance 
            40.500000             23.000000              6.762918 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("joincount.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("knearneigh")
> ### * knearneigh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: knearneigh
> ### Title: K nearest neighbours for spatial weights
> ### Aliases: knearneigh
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col.knn <- knearneigh(coords, k=4)
> plot(columbus, border="grey")
> plot(knn2nb(col.knn), coords, add=TRUE)
> title(main="K nearest neighbours, k = 4")
> data(state)
> us48.fipsno <- read.geoda(system.file("etc/weights/us48.txt",
+  package="spdep")[1])
> if (as.numeric(paste(version$major, version$minor, sep="")) < 19) {
+  m50.48 <- match(us48.fipsno$"State.name", state.name)
+ } else {
+  m50.48 <- match(us48.fipsno$"State_name", state.name)
+ }
> xy <- as.matrix(as.data.frame(state.center))[m50.48,]
> llk4.nb <- knn2nb(knearneigh(xy, k=4, longlat=FALSE))
> gck4.nb <- knn2nb(knearneigh(xy, k=4, longlat=TRUE))
> plot(llk4.nb, xy)
> plot(diffnb(llk4.nb, gck4.nb), xy, add=TRUE, col="red", lty=2)
> title(main="Differences between Euclidean and Great Circle k=4 neighbours")
> summary(llk4.nb, xy, longlat=TRUE)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 192 
Percentage nonzero weights: 8.333333 
Average number of links: 4 
Non-symmetric neighbours list
Link number distribution:

 4 
48 
48 least connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
48 most connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  297.60  393.50  414.50  513.00  955.90 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 6677889999
  3 | 00000111112222222233333333334444
  3 | 556666777788899999
  4 | 0000001111233
  4 | 555555666666677788888899
  5 | 0000111111122222222344444
  5 | 55666679
  6 | 00233
  6 | 5667
  7 | 011234
  7 | 5889
  8 | 022
  8 | 79
  9 | 
  9 | 56

> summary(gck4.nb, xy, longlat=TRUE)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 192 
Percentage nonzero weights: 8.333333 
Average number of links: 4 
Non-symmetric neighbours list
Link number distribution:

 4 
48 
48 least connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
48 most connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  297.00  393.50  410.20  508.10  952.40 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 66778899999
  3 | 000000111112222222233333333334444
  3 | 5566677778888999
  4 | 0000001111233
  4 | 5555556666666777788888899
  5 | 00000111111122222223444444
  5 | 56667899
  6 | 00233
  6 | 56
  7 | 0001124
  7 | 55899
  8 | 022
  8 | 9
  9 | 
  9 | 5

> 
> xy1 <- SpatialPoints((as.data.frame(state.center))[m50.48,],
+   proj4string=CRS("+proj=longlat"))
> gck4a.nb <- knn2nb(knearneigh(xy1, k=4))
> summary(gck4a.nb, xy1)
Neighbour list object:
Number of regions: 48 
Number of nonzero links: 192 
Percentage nonzero weights: 8.333333 
Average number of links: 4 
Non-symmetric neighbours list
Link number distribution:

 4 
48 
48 least connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
48 most connected regions:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  93.59  297.00  393.50  410.20  508.10  952.40 

  The decimal point is 2 digit(s) to the right of the |

  0 | 99
  1 | 00112233
  1 | 666699
  2 | 00112222334444444444
  2 | 66778899999
  3 | 000000111112222222233333333334444
  3 | 5566677778888999
  4 | 0000001111233
  4 | 5555556666666777788888899
  5 | 00000111111122222223444444
  5 | 56667899
  6 | 00233
  6 | 56
  7 | 0001124
  7 | 55899
  8 | 022
  8 | 9
  9 | 
  9 | 5

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("knearneigh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("knn2nb")
> ### * knn2nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: knn2nb
> ### Title: Neighbours list from knn object
> ### Aliases: knn2nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col.knn <- knearneigh(coords, k=4)
> plot(columbus, border="grey")
> plot(knn2nb(col.knn), coords, add=TRUE)
> title(main="K nearest neighbours, k = 4")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("knn2nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("lag.listw")
> ### * lag.listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lag.listw
> ### Title: Spatial lag of a numeric vector
> ### Aliases: lag.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> Vx <- lag.listw(nb2listw(COL.nb, style="W"), COL.OLD$CRIME)
> plot(Vx, COL.OLD$CRIME)
> plot(ecdf(COL.OLD$CRIME))
> plot(ecdf(Vx), add=TRUE, col.points="red", col.hor="red")
> is.na(COL.OLD$CRIME[5]) <- TRUE
> VxNA <- lag.listw(nb2listw(COL.nb, style="W"), COL.OLD$CRIME, NAOK=TRUE)
Warning in lag.listw(nb2listw(COL.nb, style = "W"), COL.OLD$CRIME, NAOK = TRUE) :
  NAs in lagged values
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lag.listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lagmess")
> ### * lagmess
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lagmess
> ### Title: Matrix exponential spatial lag model
> ### Aliases: lagmess print.lagmess print.summary.lagmess summary.lagmess
> ###   residuals.lagmess deviance.lagmess coef.lagmess fitted.lagmess
> ###   logLik.lagmess
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(baltimore)
> baltimore$AGE <- ifelse(baltimore$AGE < 1, 1, baltimore$AGE)
> lw <- nb2listw(knn2nb(knearneigh(cbind(baltimore$X, baltimore$Y), k=7)))
> obj1 <- lm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw, log(AGE)),
+  data=baltimore)
> lm.morantest(obj1, lw)

	Global Moran's I for regression residuals

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

Moran I statistic standard deviate = 5.2296, p-value = 8.494e-08
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.166678349       -0.009863538        0.001139613 

> lm.LMtests(obj1, lw, test="all")

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

LMerr = 22.505, df = 1, p-value = 2.096e-06


	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

LMlag = 36.316, df = 1, p-value = 1.678e-09


	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

RLMerr = 0.95306, df = 1, p-value = 0.3289


	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

RLMlag = 14.764, df = 1, p-value = 0.0001218


	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + lag(lw,
log(AGE)), data = baltimore)
weights: lw

SARMA = 37.269, df = 2, p-value = 8.074e-09

> obj2 <- lagmess(log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + 
+  lag(lw, log(AGE)), data=baltimore, listw=lw)
> summary(obj2)
Matrix exponential spatial lag model:

Call:
lagmess(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + 
    lag(lw, log(AGE)), data = baltimore, listw = lw)

Residuals:
      Min        1Q    Median        3Q       Max 
-1.889790 -0.160725  0.026273  0.211905  1.141046 

Coefficients:
                   Estimate Std. Error t value  Pr(>|t|)
(Intercept)        2.629014   0.281063  9.3538 < 2.2e-16
PATIO              0.274705   0.084703  3.2432 0.0013791
log(AGE)          -0.101240   0.038581 -2.6241 0.0093381
log(SQFT)          0.292936   0.070287  4.1677 4.528e-05
lag(lw, log(AGE)) -0.267042   0.069328 -3.8519 0.0001565

Residual standard error: 0.40607 on 206 degrees of freedom
Multiple R-squared:  0.30304,	Adjusted R-squared:  0.28951 
F-statistic: 22.393 on 4 and 206 DF,  p-value: 2.2819e-15

Alpha: -0.46998, standard error: 0.10878
    z-value: -4.3207, p-value: 1.5557e-05
LR test value: 22.469, p-value: 2.1357e-06
Implied rho: 0.3749857 

> obj3 <- lagsarlm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + 
+  lag(lw, log(AGE)), data=baltimore, listw=lw)
> summary(obj3)

Call:lagsarlm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT) + 
    lag(lw, log(AGE)), data = baltimore, listw = lw)

Residuals:
      Min        1Q    Median        3Q       Max 
-1.878631 -0.152699  0.025122  0.205868  1.135627 

Type: lag 
Coefficients: (asymptotic standard errors) 
                   Estimate Std. Error z value  Pr(>|z|)
(Intercept)        2.342829   0.504754  4.6415 3.459e-06
PATIO              0.264588   0.082640  3.2017  0.001366
log(AGE)          -0.096382   0.037986 -2.5373  0.011172
log(SQFT)          0.280615   0.069354  4.0461 5.207e-05
lag(lw, log(AGE)) -0.239519   0.077477 -3.0915  0.001992

Rho: 0.43527, LR test value: 24.336, p-value: 8.0917e-07
Asymptotic standard error: 0.086836
    z-value: 5.0125, p-value: 5.3718e-07
Wald statistic: 25.125, p-value: 5.3718e-07

Log likelihood: -105.771 for lag model
ML residual variance (sigma squared): 0.1553, (sigma: 0.39408)
Number of observations: 211 
Number of parameters estimated: 7 
AIC: 225.54, (AIC for lm: 247.88)
LM test for residual autocorrelation
test value: 4.5566, p-value: 0.032791

> data(boston)
> lw <- nb2listw(boston.soi)
> gp2 <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)
+  +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
+  data=boston.c, lw, method="Matrix")
> summary(gp2)

Call:lagsarlm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
    I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + 
    log(LSTAT), data = boston.c, listw = lw, method = "Matrix")

Residuals:
       Min         1Q     Median         3Q        Max 
-0.5262308 -0.0749699 -0.0044237  0.0713409  0.7122121 

Type: lag 
Coefficients: (asymptotic standard errors) 
               Estimate  Std. Error  z value  Pr(>|z|)
(Intercept)  2.2796e+00  1.7495e-01  13.0302 < 2.2e-16
CRIM        -7.1045e-03  9.6236e-04  -7.3824 1.554e-13
ZN           3.7985e-04  3.8510e-04   0.9864 0.3239507
INDUS        1.2572e-03  1.7986e-03   0.6990 0.4845472
CHAS1        7.3677e-03  2.5416e-02   0.2899 0.7719058
I(NOX^2)    -2.6892e-01  8.8026e-02  -3.0550 0.0022508
I(RM^2)      6.7243e-03  1.0039e-03   6.6985 2.106e-11
AGE         -2.7682e-04  4.0062e-04  -0.6910 0.4895829
log(DIS)    -1.5830e-01  2.5554e-02  -6.1947 5.841e-10
log(RAD)     7.0689e-02  1.4616e-02   4.8363 1.323e-06
TAX         -3.6569e-04  9.3744e-05  -3.9009 9.582e-05
PTRATIO     -1.2011e-02  3.9599e-03  -3.0330 0.0024211
B            2.8432e-04  7.9402e-05   3.5807 0.0003427
log(LSTAT)  -2.3216e-01  2.0425e-02 -11.3663 < 2.2e-16

Rho: 0.48537, LR test value: 214.06, p-value: < 2.22e-16
Asymptotic standard error: 0.029426
    z-value: 16.494, p-value: < 2.22e-16
Wald statistic: 272.06, p-value: < 2.22e-16

Log likelihood: 264.0089 for lag model
ML residual variance (sigma squared): 0.019276, (sigma: 0.13884)
Number of observations: 506 
Number of parameters estimated: 16 
AIC: -496.02, (AIC for lm: -283.96)
LM test for residual autocorrelation
test value: 10.74, p-value: 0.0010486

> gp2a <- lagmess(CMEDV ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)
+  +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
+  data=boston.c, lw)
> summary(gp2a)
Matrix exponential spatial lag model:

Call:
lagmess(formula = CMEDV ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
    I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + 
    log(LSTAT), data = boston.c, listw = lw)

Residuals:
      Min        1Q    Median        3Q       Max 
-17.03755  -2.05386  -0.30295   1.67710  21.82120 

Coefficients:
              Estimate Std. Error  t value  Pr(>|t|)
(Intercept) 35.3206850  3.0128759  11.7232 < 2.2e-16
CRIM        -0.0986056  0.0242819  -4.0609 5.688e-05
ZN           0.0198500  0.0098638   2.0124 0.0447222
INDUS        0.0071211  0.0461104   0.1544 0.8773301
CHAS1        0.8158059  0.6477224   1.2595 0.2084473
I(NOX^2)    -9.2592911  2.2072427  -4.1950 3.238e-05
I(RM^2)      0.2434745  0.0256001   9.5107 < 2.2e-16
AGE         -0.0040683  0.0102667  -0.3963 0.6920816
log(DIS)    -5.3974116  0.6514323  -8.2855 1.125e-15
log(RAD)     1.7142905  0.3732772   4.5925 5.569e-06
TAX         -0.0087053  0.0023933  -3.6373 0.0003046
PTRATIO     -0.4118524  0.0977997  -4.2112 3.021e-05
B            0.0056141  0.0020116   2.7908 0.0054614
log(LSTAT)  -6.1484203  0.4878957 -12.6019 < 2.2e-16

Residual standard error: 3.5594 on 492 degrees of freedom
Multiple R-squared:  0.76221,	Adjusted R-squared:  0.75593 
F-statistic: 121.31 on 13 and 492 DF,  p-value: < 2.22e-16

Alpha: -0.41361, standard error: 0.038521
    z-value: -10.737, p-value: < 2.22e-16
LR test value: 121.4, p-value: < 2.22e-16
Implied rho: 0.3387434 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lagmess", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lagsarlm")
> ### * lagsarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lagsarlm
> ### Title: Spatial simultaneous autoregressive lag model estimation
> ### Aliases: lagsarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"), method="eigen", quiet=FALSE)

Spatial lag model
Jacobian calculated using neighbourhood matrix eigenvalues
Computing eigenvalues ...

rho:	 -0.5674437 	function value:	 -202.2909 
rho:	 0.03126655 	function value:	 -186.749 
rho:	 0.4012898 	function value:	 -182.419 
rho:	 0.6138418 	function value:	 -183.5636 
rho:	 0.4157662 	function value:	 -182.398 
rho:	 0.4295565 	function value:	 -182.3905 
rho:	 0.4311288 	function value:	 -182.3904 
rho:	 0.4310273 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
> summary(COL.lag.eig, correlation=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), method = "eigen", quiet = FALSE)

Residuals:
      Min        1Q    Median        3Q       Max 
-37.68585  -5.35636   0.05421   6.02013  23.20555 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 45.079251   7.177347  6.2808 3.369e-10
INC         -1.031616   0.305143 -3.3808 0.0007229
HOVAL       -0.265926   0.088499 -3.0049 0.0026570

Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588
Asymptotic standard error: 0.11768
    z-value: 3.6626, p-value: 0.00024962
Wald statistic: 13.415, p-value: 0.00024962

Log likelihood: -182.3904 for lag model
ML residual variance (sigma squared): 95.494, (sigma: 9.7721)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 374.78, (AIC for lm: 382.75)
LM test for residual autocorrelation
test value: 0.31955, p-value: 0.57188

 Correlation of coefficients 
            sigma rho   (Intercept) INC  
rho         -0.14                        
(Intercept)  0.12 -0.83                  
INC         -0.05  0.35 -0.61            
HOVAL       -0.01  0.08 -0.25       -0.44

> COL.lag.eig$fdHess
[1] FALSE
> COL.lag.eig$resvar
                   sigma           rho (Intercept)         INC         HOVAL
sigma       379.77510363 -0.3236306318  16.3015079 -0.29590801 -0.0202478459
rho          -0.32363063  0.0138487533  -0.6975717  0.01266245  0.0008664428
(Intercept)  16.30150787 -0.6975716740  51.5143034 -1.32602704 -0.1616379856
INC          -0.29590801  0.0126624511  -1.3260270  0.09311223 -0.0117959715
HOVAL        -0.02024785  0.0008664428  -0.1616380 -0.01179597  0.0078320057
> W <- as(nb2listw(COL.nb), "CsparseMatrix")
> trMatc <- trW(W, type="mult")
> COL.lag.eig1 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"), control=list(fdHess=TRUE), trs=trMatc)
> COL.lag.eig1$fdHess
                   sigma2           rho (Intercept)         INC         HOVAL
sigma2      380.748984027 -0.3653047755  19.9505937 -0.47944318 -0.0067846611
rho          -0.365304776  0.0156320670  -0.8537228  0.02051626  0.0002903282
(Intercept)  19.950593697 -0.8537228058  63.0019564 -1.80867625 -0.1338504953
INC          -0.479443180  0.0205162605  -1.8086763  0.10846097 -0.0122071533
HOVAL        -0.006784661  0.0002903282  -0.1338505 -0.01220715  0.0077831892
> system.time(COL.lag.M <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb), method="Matrix", quiet=FALSE))

Spatial lag model
Jacobian calculated using sparse matrix Cholesky decomposition
rho:	 -0.2364499 	function value:	 -192.9523 
rho:	 0.2354499 	function value:	 -183.542 
rho:	 0.5271001 	function value:	 -182.7039 
rho:	 0.4455543 	function value:	 -182.3974 
rho:	 0.4267907 	function value:	 -182.391 
rho:	 0.4311986 	function value:	 -182.3904 
rho:	 0.4310114 	function value:	 -182.3904 
rho:	 0.4310231 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
rho:	 0.4310232 	function value:	 -182.3904 
Computing eigenvalues ...

   user  system elapsed 
  0.144   0.000   0.144 
> summary(COL.lag.M)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    method = "Matrix", quiet = FALSE)

Residuals:
      Min        1Q    Median        3Q       Max 
-37.68585  -5.35636   0.05421   6.02013  23.20555 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 45.079249   7.177346  6.2808 3.369e-10
INC         -1.031616   0.305143 -3.3808 0.0007229
HOVAL       -0.265926   0.088499 -3.0049 0.0026570

Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588
Asymptotic standard error: 0.11768
    z-value: 3.6626, p-value: 0.00024962
Wald statistic: 13.415, p-value: 0.00024962

Log likelihood: -182.3904 for lag model
ML residual variance (sigma squared): 95.494, (sigma: 9.7721)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 374.78, (AIC for lm: 382.75)
LM test for residual autocorrelation
test value: 0.31954, p-value: 0.57188

> impacts(COL.lag.M, listw=nb2listw(COL.nb))
Impact measures (lag, exact):
          Direct   Indirect      Total
INC   -1.0860220 -0.7270848 -1.8131068
HOVAL -0.2799509 -0.1874254 -0.4673763
> ## Not run: 
> ##D system.time(COL.lag.sp <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
> ##D  nb2listw(COL.nb), method="spam", quiet=FALSE))
> ##D summary(COL.lag.sp)
> ## End(Not run)
> COL.lag.B <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="B"))
> summary(COL.lag.B, correlation=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "B"))

Residuals:
     Min       1Q   Median       3Q      Max 
-33.6975  -4.7996  -1.4808   5.3648  25.8922 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 52.403878   5.961310  8.7907 < 2.2e-16
INC         -1.175261   0.300473 -3.9114 9.178e-05
HOVAL       -0.252680   0.087613 -2.8840  0.003926

Rho: 0.051981, LR test value: 12.764, p-value: 0.00035336
Asymptotic standard error: 0.014428
    z-value: 3.6028, p-value: 0.00031482
Wald statistic: 12.98, p-value: 0.00031482

Log likelihood: -180.9953 for lag model
ML residual variance (sigma squared): 93.29, (sigma: 9.6587)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 371.99, (AIC for lm: 382.75)
LM test for residual autocorrelation
test value: 0.0028047, p-value: 0.95776

 Correlation of coefficients 
            sigma rho   (Intercept) INC  
rho         -0.04                        
(Intercept)  0.03 -0.74                  
INC         -0.01  0.34 -0.63            
HOVAL        0.00  0.10 -0.30       -0.43

> COL.mixed.B <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="B"), type="mixed", tol.solve=1e-9)
> summary(COL.mixed.B, correlation=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "B"), type = "mixed", tol.solve = 1e-09)

Residuals:
      Min        1Q    Median        3Q       Max 
-34.45813  -5.25361  -0.14753   5.20581  23.81568 

Type: mixed 
Coefficients: (asymptotic standard errors) 
                 Estimate Std. Error z value  Pr(>|z|)
(Intercept)     54.179690   5.817611  9.3130 < 2.2e-16
INC             -0.942199   0.327149 -2.8800  0.003976
HOVAL           -0.287421   0.087377 -3.2894  0.001004
lag.(Intercept) -2.124907   2.756294 -0.7709  0.440749
lag.INC         -0.124606   0.135599 -0.9189  0.358134
lag.HOVAL        0.052373   0.040246  1.3013  0.193150

Rho: 0.08115, LR test value: 3.993, p-value: 0.04569
Asymptotic standard error: 0.033436
    z-value: 2.427, p-value: 0.015224
Wald statistic: 5.8904, p-value: 0.015224

Log likelihood: -179.4932 for mixed model
ML residual variance (sigma squared): 85.779, (sigma: 9.2617)
Number of observations: 49 
Number of parameters estimated: 8 
AIC: 374.99, (AIC for lm: 376.98)
LM test for residual autocorrelation
test value: 0.84013, p-value: 0.35936

 Correlation of coefficients 
                sigma rho   (Intercept) INC   HOVAL lag.(Intercept) lag.INC
rho             -0.16                                                      
(Intercept)      0.02 -0.14                                                
INC             -0.03  0.17 -0.52                                          
HOVAL            0.01 -0.05 -0.28       -0.41                              
lag.(Intercept)  0.14 -0.86 -0.15        0.07  0.12                        
lag.INC         -0.08  0.48  0.00       -0.33  0.10 -0.60                  
lag.HOVAL       -0.03  0.16  0.09        0.11 -0.28 -0.35           -0.39  

> COL.mixed.W <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb, style="W"), type="mixed")
> summary(COL.mixed.W, correlation=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), type = "mixed")

Residuals:
      Min        1Q    Median        3Q       Max 
-37.47829  -6.46731  -0.33835   6.05200  22.62969 

Type: mixed 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 42.822415  12.667205  3.3806 0.0007233
INC         -0.914223   0.331094 -2.7612 0.0057586
HOVAL       -0.293738   0.089212 -3.2926 0.0009927
lag.INC     -0.520284   0.565129 -0.9206 0.3572355
lag.HOVAL    0.245640   0.178917  1.3729 0.1697756

Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494
Asymptotic standard error: 0.15623
    z-value: 2.7288, p-value: 0.0063561
Wald statistic: 7.4465, p-value: 0.0063561

Log likelihood: -181.3935 for mixed model
ML residual variance (sigma squared): 91.791, (sigma: 9.5808)
Number of observations: 49 
Number of parameters estimated: 7 
AIC: 376.79, (AIC for lm: 380.16)
LM test for residual autocorrelation
test value: 0.28919, p-value: 0.59074

 Correlation of coefficients 
            sigma rho   (Intercept) INC   HOVAL lag.INC
rho         -0.18                                      
(Intercept)  0.16 -0.89                                
INC         -0.03  0.14 -0.19                          
HOVAL        0.02 -0.09  0.03       -0.45              
lag.INC     -0.09  0.49 -0.53       -0.36  0.05        
lag.HOVAL   -0.04  0.19 -0.36        0.19 -0.24 -0.41  

> NA.COL.OLD <- COL.OLD
> NA.COL.OLD$CRIME[20:25] <- NA
> COL.lag.NA <- lagsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,
+  nb2listw(COL.nb), na.action=na.exclude, 
+  control=list(tol.opt=.Machine$double.eps^0.4))
> COL.lag.NA$na.action
1020 1021 1022 1023 1024 1025 
  20   21   22   23   24   25 
attr(,"class")
[1] "exclude"
> COL.lag.NA

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = NA.COL.OLD, listw = nb2listw(COL.nb), 
    na.action = na.exclude, control = list(tol.opt = .Machine$double.eps^0.4))
Type: lag 

Coefficients:
        rho (Intercept)         INC       HOVAL 
  0.4537820  43.1054975  -0.9267352  -0.2715541 

Log likelihood: -160.8867 
> resid(COL.lag.NA)
       1001        1002        1003        1004        1005        1006 
 -4.4352945 -13.2750948  -2.9233555 -37.3067542   1.3568011  -3.8828027 
       1007        1008        1009        1010        1011        1012 
  5.9980436 -12.8113318  -4.0482558  18.1813323   5.9714203   1.0035599 
       1013        1014        1015        1016        1017        1018 
 -1.7490666  -1.7490651   5.8456328  10.1074158  -4.3706895   3.3713771 
       1019        1020        1021        1022        1023        1024 
 -4.0823022          NA          NA          NA          NA          NA 
       1025        1026        1027        1028        1029        1030 
         NA  -6.0553296 -11.5813311  -8.0011389  -1.9047478   3.9744243 
       1031        1032        1033        1034        1035        1036 
  4.8148614   6.0673483  10.2059847  22.7419913  -2.0830998   0.1422777 
       1037        1038        1039        1040        1041        1042 
  8.6436388   8.8150864   6.4974685  15.4121789   9.4182148   5.6427603 
       1043        1044        1045        1046        1047        1048 
 -7.5727123  -7.5983733  -9.7792620 -10.0870764  -3.1242393   3.4921796 
       1049 
  0.7173251 
> ## Not run: 
> ##D data(boston)
> ##D gp2mM <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
> ##D I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), 
> ##D data=boston.c, nb2listw(boston.soi), type="mixed", method="Matrix")
> ##D summary(gp2mM)
> ##D W <- as(nb2listw(boston.soi), "CsparseMatrix")
> ##D trMatb <- trW(W, type="mult")
> ##D gp2mMi <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
> ##D I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), 
> ##D data=boston.c, nb2listw(boston.soi), type="mixed", method="Matrix", 
> ##D trs=trMatb)
> ##D summary(gp2mMi)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lagsarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lee")
> ### * lee
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lee
> ### Title: Compute Lee's statistic
> ### Aliases: lee
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(boston)
> lw<-nb2listw(boston.soi)
> 
> x<-boston.c$CMEDV
> y<-boston.c$CRIM
> z<-boston.c$RAD
> 
> Lxy<-lee(x, y, lw, length(x), zero.policy=TRUE)
> Lxz<-lee(x, z, lw, length(x), zero.policy=TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lee", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lee.mc")
> ### * lee.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lee.mc
> ### Title: Permutation test for Lee's L statistic
> ### Aliases: lee.mc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(boston)
> lw<-nb2listw(boston.soi)
> 
> x<-boston.c$CMEDV
> y<-boston.c$CRIM
> 
> lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative="less")

	Monte-Carlo simulation of Lee's L

data:  x ,  y 
weights: lw  
number of simulations + 1: 100 

statistic = -0.3263, observed rank = 1, p-value = 0.01
alternative hypothesis: less

> 
> #Test with missing values
> x[1:5]<-NA
> y[3:7]<-NA
> 
> lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative="less", 
+    na.action=na.omit)

	Monte-Carlo simulation of Lee's L

data:  x ,  y 
weights: lw 
omitted: 1, 2, 3, 4, 5, 6, 7 
number of simulations + 1: 100 

statistic = -0.32447, observed rank = 1, p-value = 0.01
alternative hypothesis: less

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lee.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lee.test")
> ### * lee.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lee.test
> ### Title: Lee's L test for spatial autocorrelation
> ### Aliases: lee.test
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> col.W <- nb2listw(COL.nb, style="W")
> crime <- COL.OLD$CRIME
> 
> lee.test(crime, crime, col.W, zero.policy=TRUE)

	Lee's L statistic randomisation

data:  crime ,  crime 
weights: col.W  

Lee's L statistic standard deviate = 5.2343, p-value = 8.279e-08
alternative hypothesis: greater
sample estimates:
Lee's L statistic       Expectation          Variance 
      0.547064219       0.239417989       0.003454459 

> 
> #Test with missing values
> x<-crime
> y<-crime
> x[1:5]<-NA
> y[3:7]<-NA
> 
> lee.test(x, y, col.W, zero.policy=TRUE, na.action=na.omit)

	Lee's L statistic randomisation

data:  x ,  y 
weights: col.W 
omitted: 1, 2, 3, 4, 5, 6, 7 

Lee's L statistic standard deviate = 6.6873, p-value = 1.137e-11
alternative hypothesis: greater
sample estimates:
Lee's L statistic       Expectation          Variance 
      0.706469726       0.260143244       0.004454563 

> #  lee.test(x, y, col.W, zero.policy=TRUE)#Stops with an error
> 
> 
> 
> data(boston)
> lw<-nb2listw(boston.soi)
> 
> x<-boston.c$CMEDV
> y<-boston.c$CRIM
> 
> lee.test(x, y, lw, zero.policy=TRUE, alternative="less")

	Lee's L statistic randomisation

data:  x ,  y 
weights: lw  

Lee's L statistic standard deviate = -11.54, p-value < 2.2e-16
alternative hypothesis: less
sample estimates:
Lee's L statistic       Expectation          Variance 
     -0.326297206      -0.105040316       0.000367637 

> 
> #Test with missing values
> x[1:5]<-NA
> y[3:7]<-NA
> 
> lee.test(x, y, lw, zero.policy=TRUE, alternative="less", na.action=na.omit)

	Lee's L statistic randomisation

data:  x ,  y 
weights: lw 
omitted: 1, 2, 3, 4, 5, 6, 7 

Lee's L statistic standard deviate = -11.284, p-value < 2.2e-16
alternative hypothesis: less
sample estimates:
Lee's L statistic       Expectation          Variance 
    -0.3244748280     -0.1053154332      0.0003772109 

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lee.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lextrB")
> ### * lextrB
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lextrB
> ### Title: Find extreme eigenvalues of binary symmetric spatial weights
> ### Aliases: lextrB lextrW lextrS l_max
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(boston)
> ab.listb <- nb2listw(boston.soi, style="B")
> er <- range(eigenw(ab.listb))
> er
[1] -3.039465  5.306204
> res_1 <- lextrB(ab.listb)
> c(res_1)
 lambda_n  lambda_1 
-3.039374  5.306203 
> if (require(igraph)) {
+   B <- as(ab.listb, "symmetricMatrix")
+   n <- length(boston.soi)
+   f2 <- function(x, extra=NULL) {as.vector(B %*% x)}
+   ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="LA", maxiter=200))
+   print(ar1$values)
+   arn <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="SA", maxiter=200))
+   print(arn$values)
+ #  ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=2, ncv=8,
+ #    which="BE", maxiter=300))
+ # "BE" gives: At line 558 of file dsaup2.f: Fortran runtime error: 
+ # Index '9' of dimension 1 of array 'bounds' above upper bound of 8
+ # "BE" 
+ #  print(ar1$values)
+ }
Loading required package: igraph

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

Note: method with signature ‘Matrix#numLike’ chosen for function ‘%*%’,
 target signature ‘dsTMatrix#numeric’.
 "TsparseMatrix#ANY" would also be valid
Note: method with signature ‘sparseMatrix#matrix’ chosen for function ‘%*%’,
 target signature ‘dsTMatrix#matrix’.
 "TsparseMatrix#ANY" would also be valid
[1] 5.306204
[1] -3.039465
> k5 <- knn2nb(knearneigh(boston.utm, k=5))
> c(l_max(nb2listw(k5, style="B")))
[1] 5
> max(Re(eigenw(nb2listw(k5, style="B"))))
[1] 5
> c(l_max(nb2listw(k5, style="C")))
[1] 1
> max(Re(eigenw(nb2listw(k5, style="C"))))
[1] 1
> ab.listw <- nb2listw(boston.soi, style="W")
> er <- range(eigenw(similar.listw(ab.listw)))
> er
[1] -0.9708644  1.0000000
> res_1 <- lextrW(ab.listw)
> c(res_1)
  lambda_n   lambda_1 
-0.9708644  0.9999991 
> if (require(igraph)) {
+   B <- as(similar.listw(ab.listw), "symmetricMatrix")
+   ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="LA", maxiter=400))
+   print(ar1$values)
+   arn <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="SA", maxiter=400))
+   print(arn$values)
+ #  ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=2, ncv=8,
+ #    which="BE", maxiter=300))
+ # "BE" gives: At line 558 of file dsaup2.f: Fortran runtime error: 
+ # Index '9' of dimension 1 of array 'bounds' above upper bound of 8
+ #  print(ar1$values)
+ }
[1] 1
[1] -0.9708644
> ab.listw <- nb2listw(boston.soi, style="S")
> er <- range(eigenw(similar.listw(ab.listw)))
> er
[1] -0.723495  1.110373
> res_1 <- lextrS(ab.listw)
> c(res_1)
  lambda_n   lambda_1 
-0.7230376  1.1103694 
> if (require(igraph)) {
+   B <- as(similar.listw(ab.listw), "symmetricMatrix")
+   ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="LA", maxiter=300))
+   print(ar1$values)
+   arn <- arpack(f2, sym=TRUE, options=list(n=n, nev=1, ncv=8,
+     which="SA", maxiter=300))
+   print(arn$values)
+ #  ar1 <- arpack(f2, sym=TRUE, options=list(n=n, nev=2, ncv=8,
+ #    which="BE", maxiter=300))
+ # "BE" gives: At line 558 of file dsaup2.f: Fortran runtime error: 
+ # Index '9' of dimension 1 of array 'bounds' above upper bound of 8
+ #  print(ar1$values)
+ }
[1] 1.110373
[1] -0.723495
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lextrB", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:igraph’

> nameEx("listw2sn")
> ### * listw2sn
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: listw2sn
> ### Title: Spatial neighbour sparse representation
> ### Aliases: listw2sn sn2listw as.spam.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> col.listw <- nb2listw(col.gal.nb)
> col.listw$neighbours[[1]]
[1] 2 3
> col.listw$weights[[1]]
[1] 0.5 0.5
> col.sn <- listw2sn(col.listw)
> str(col.sn)
Classes ‘spatial.neighbour’ and 'data.frame':	230 obs. of  3 variables:
 $ from   : int  1 1 2 2 2 3 3 3 3 4 ...
 $ to     : int  2 3 1 3 4 1 2 4 5 2 ...
 $ weights: num  0.5 0.5 0.333 0.333 0.333 ...
 - attr(*, "n")= int 49
 - attr(*, "region.id")= chr  "1" "2" "3" "4" ...
 - attr(*, "neighbours.attrs")= chr  "class" "region.id" "GeoDa" "gal" ...
 - attr(*, "weights.attrs")= chr  "mode" "W" "comp"
 - attr(*, "GeoDa")=List of 2
  ..$ shpfile: chr NA
  ..$ ind    : chr NA
 - attr(*, "listw.call")= language nb2listw(neighbours = col.gal.nb)
> ## Not run: 
> ##D col.sp <- as.spam.listw(col.listw)
> ##D str(col.sp)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("listw2sn", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("lm.LMtests")
> ### * lm.LMtests
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lm.LMtests
> ### Title: Lagrange Multiplier diagnostics for spatial dependence in linear
> ###   models
> ### Aliases: lm.LMtests print.LMtestlist summary.LMtestlist
> ###   print.LMtestlist.summary
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> oldcrime.lm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD)
> summary(oldcrime.lm)

Call:
lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)

Residuals:
    Min      1Q  Median      3Q     Max 
-34.418  -6.388  -1.580   9.052  28.649 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  68.6190     4.7355  14.490  < 2e-16 ***
HOVAL        -0.2739     0.1032  -2.654   0.0109 *  
INC          -1.5973     0.3341  -4.780 1.83e-05 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 11.43 on 46 degrees of freedom
Multiple R-squared:  0.5524,	Adjusted R-squared:  0.5329 
F-statistic: 28.39 on 2 and 46 DF,  p-value: 9.341e-09

> res <- lm.LMtests(oldcrime.lm, nb2listw(COL.nb), test=c("LMerr", "LMlag",
+   "RLMerr", "RLMlag", "SARMA"))
> summary(res)
	Lagrange multiplier diagnostics for spatial dependence
data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)
weights: nb2listw(COL.nb)
 
       statistic parameter  p.value   
LMerr   5.723131         1 0.016743 * 
LMlag   9.363684         1 0.002213 **
RLMerr  0.079495         1 0.777983   
RLMlag  3.720048         1 0.053763 . 
SARMA   9.443178         2 0.008901 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> lm.LMtests(oldcrime.lm, nb2listw(COL.nb))

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)
weights: nb2listw(COL.nb)

LMErr = 5.7231, df = 1, p-value = 0.01674

> lm.LMtests(residuals(oldcrime.lm), nb2listw(COL.nb))

	Lagrange multiplier diagnostics for spatial dependence

data:  
residuals: residuals(oldcrime.lm)
weights: nb2listw(COL.nb)

LMErr = 5.7231, df = 1, p-value = 0.01674

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lm.LMtests", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lm.morantest")
> ### * lm.morantest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lm.morantest
> ### Title: Moran's I test for residual spatial autocorrelation
> ### Aliases: lm.morantest listw2U
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> oldcrime1.lm <- lm(CRIME ~ 1, data = COL.OLD)
> oldcrime.lm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD)
> lm.morantest(oldcrime.lm, nb2listw(COL.nb, style="W"))

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)
weights: nb2listw(COL.nb, style = "W")

Moran I statistic standard deviate = 2.9539, p-value = 0.001569
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.235638354       -0.033302866        0.008289408 

> lm.LMtests(oldcrime.lm, nb2listw(COL.nb, style="W"))

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)
weights: nb2listw(COL.nb, style = "W")

LMErr = 5.7231, df = 1, p-value = 0.01674

> lm.morantest(oldcrime.lm, nb2listw(COL.nb, style="S"))

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD)
weights: nb2listw(COL.nb, style = "S")

Moran I statistic standard deviate = 3.1745, p-value = 0.0007504
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.239317561       -0.033431740        0.007381982 

> lm.morantest(oldcrime1.lm, nb2listw(COL.nb, style="W"))

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ 1, data = COL.OLD)
weights: nb2listw(COL.nb, style = "W")

Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.510951264       -0.020833333        0.008779831 

> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
+  randomisation=FALSE)

	Moran's I test under normality

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "W")  

Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.510951264      -0.020833333       0.008779831 

> oldcrime.wlm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD,
+  weights = I(1/AREA_PL))
> lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style="W"),
+  resfun=weighted.residuals)

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD, weights =
I(1/AREA_PL))
weights: nb2listw(COL.nb, style = "W")

Moran I statistic standard deviate = 3.0141, p-value = 0.001289
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.241298974       -0.032224366        0.008235091 

> lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style="W"),
+  resfun=rstudent)

	Global Moran's I for regression residuals

data:  
model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD, weights =
I(1/AREA_PL))
weights: nb2listw(COL.nb, style = "W")

Moran I statistic standard deviate = 2.822, p-value = 0.002387
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.223860298       -0.032224366        0.008235091 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lm.morantest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lm.morantest.exact")
> ### * lm.morantest.exact
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lm.morantest.exact
> ### Title: Exact global Moran's I test
> ### Aliases: lm.morantest.exact print.moranex
> ### Keywords: spatial
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> eire <- readShapePoly(system.file("etc/shapes/eire.shp", package="spdep")[1],
+   ID="names", proj4string=CRS("+proj=utm +zone=30 +units=km"))
> eire.nb <- poly2nb(eire)
> #data(eire)
> e.lm <- lm(OWNCONS ~ ROADACC, data=eire)
> lm.morantest(e.lm, nb2listw(eire.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 3.2575, p-value = 0.0005619
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.33660565        -0.05877741         0.01473183 

> lm.morantest.sad(e.lm, nb2listw(eire.nb))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 2.9395, p-value = 0.001644
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.3366057 

> lm.morantest.exact(e.lm, nb2listw(eire.nb))

	Global Moran's I statistic with exact p-value

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Exact standard deviate = 2.9316, p-value = 0.001686
alternative hypothesis: greater
sample estimates:
[1] 0.3366057

> lm.morantest.exact(e.lm, nb2listw(eire.nb), useTP=TRUE)

	Global Moran's I statistic with exact p-value

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Exact standard deviate = 2.9315, p-value = 0.001686
alternative hypothesis: greater
sample estimates:
[1] 0.3366057

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lm.morantest.exact", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("lm.morantest.sad")
> ### * lm.morantest.sad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lm.morantest.sad
> ### Title: Saddlepoint approximation of global Moran's I test
> ### Aliases: lm.morantest.sad print.moransad summary.moransad
> ###   print.summary.moransad
> ### Keywords: spatial
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> eire <- readShapePoly(system.file("etc/shapes/eire.shp", package="spdep")[1],
+   ID="names", proj4string=CRS("+proj=utm +zone=30 +units=km"))
> eire.nb <- poly2nb(eire)
> #data(eire)
> e.lm <- lm(OWNCONS ~ ROADACC, data=eire)
> lm.morantest(e.lm, nb2listw(eire.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 3.2575, p-value = 0.0005619
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.33660565        -0.05877741         0.01473183 

> lm.morantest.sad(e.lm, nb2listw(eire.nb))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 2.9395, p-value = 0.001644
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.3366057 

> summary(lm.morantest.sad(e.lm, nb2listw(eire.nb)))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 2.9395, p-value = 0.001644
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.3366057 

 Expectation     Variance Std. deviate     Skewness     Kurtosis      Minimum 
 -0.05877741   0.01473183   3.25753938   0.31336881   3.05047361  -0.67545810 
     Maximum        omega        sad.r        sad.u 
  0.89091555   0.76549075   2.77616585   4.36854629 
      f.root         iter   estim.prec 
6.945659e-14 1.100000e+01           NA 
> e.wlm <- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE)
> lm.morantest(e.wlm, nb2listw(eire.nb), resfun=rstudent)

	Global Moran's I for regression residuals

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire, weights = RETSALE)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 3.1385, p-value = 0.0008491
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.34500329        -0.04049313         0.01508687 

> lm.morantest.sad(e.wlm, nb2listw(eire.nb), resfun=rstudent)

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = OWNCONS ~ ROADACC, data = eire, weights = RETSALE)
weights: nb2listw(eire.nb)

Saddlepoint approximation = 2.8708, p-value = 0.002047
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.3450033 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lm.morantest.sad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("localG")
> ### * localG
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: localG
> ### Title: G and Gstar local spatial statistics
> ### Aliases: localG
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(getisord)
> xycoords <- cbind(xyz$x, xyz$y)
> nb30 <- dnearneigh(xycoords, 0, 30)
> G30 <- localG(xyz$val, nb2listw(nb30, style="B"))
> G30[length(xyz$val)-136]
[1] 1.221979
> nb60 <- dnearneigh(xycoords, 0, 60)
> G60 <- localG(xyz$val, nb2listw(nb60, style="B"))
> G60[length(xyz$val)-136]
[1] 1.748098
> nb90 <- dnearneigh(xycoords, 0, 90)
> G90 <- localG(xyz$val, nb2listw(nb90, style="B"))
> G90[length(xyz$val)-136]
[1] 1.986135
> nb120 <- dnearneigh(xycoords, 0, 120)
> G120 <- localG(xyz$val, nb2listw(nb120, style="B"))
> G120[length(xyz$val)-136]
[1] 1.893374
> nb150 <- dnearneigh(xycoords, 0, 150)
> G150 <- localG(xyz$val, nb2listw(nb150, style="B"))
> G150[length(xyz$val)-136]
[1] 1.237454
> brks <- seq(-5,5,1)
> cm.col <- cm.colors(length(brks)-1)
> image(x, y, t(matrix(G30, nrow=16, ncol=16, byrow=TRUE)),
+   breaks=brks, col=cm.col, asp=1)
> text(xyz$x, xyz$y, round(G30, digits=1), cex=0.7)
> polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
> title(main=expression(paste("Values of the ", G[i], " statistic")))
> G30s <- localG(xyz$val, nb2listw(include.self(nb30),
+  style="B"))
> cat("value according to Getis and Ord's eq. 14.2, p. 263 (1996)\n")
value according to Getis and Ord's eq. 14.2, p. 263 (1996)
> G30s[length(xyz$val)-136]
[1] 1.45078
> cat(paste("value given by Getis and Ord (1996), p. 267",
+   "(division by n-1 rather than n \n in variance)\n"))
value given by Getis and Ord (1996), p. 267 (division by n-1 rather than n 
 in variance)
> G30s[length(xyz$val)-136] *
+   (sqrt(sum(scale(xyz$val, scale=FALSE)^2)/length(xyz$val)) /
+   sqrt(var(xyz$val)))
[1] 1.447943
> image(x, y, t(matrix(G30s, nrow=16, ncol=16, byrow=TRUE)),
+   breaks=brks, col=cm.col, asp=1)
> text(xyz$x, xyz$y, round(G30s, digits=1), cex=0.7)
> polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
> title(main=expression(paste("Values of the ", G[i]^"*", " statistic")))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("localG", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("localmoran")
> ### * localmoran
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: localmoran
> ### Title: Local Moran's I statistic
> ### Aliases: localmoran
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(afcon)
> oid <- order(afcon$id)
> resI <- localmoran(afcon$totcon, nb2listw(paper.nb))
> printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
+  check.names=FALSE)
                                 Ii       E.Ii     Var.Ii       Z.Ii Pr.z...0.
THE GAMBIA                0.3752254 -0.0243902  0.8707799  0.4282410    0.3342
MALI                      0.4636340 -0.0243902  0.1084938  1.4816272    0.0692
SENEGAL                   0.2567014 -0.0243902  0.2037796  0.6226838    0.2667
BENIN                     0.1941194 -0.0243902  0.2037796  0.4840501    0.3142
MAURITANIA                0.0970535 -0.0243902  0.2037796  0.2690263    0.3940
NIGER                     0.2307143 -0.0243902  0.1084938  0.7744898    0.2193
IVORY COAST               0.2900359 -0.0243902  0.1593129  0.7877586    0.2154
GUINEA                    0.1826275 -0.0243902  0.1593129  0.5186592    0.3020
BURKINA FASO              0.5082778 -0.0243902  0.1296684  1.4792430    0.0695
LIBERIA                   0.1856475 -0.0243902  0.2778907  0.3984375    0.3452
SIERRA LEONE              0.2652337 -0.0243902  0.4261130  0.4436823    0.3286
GHANA                     0.1476406 -0.0243902  0.2778907  0.3263392    0.3721
TOGO                      0.2193448 -0.0243902  0.2778907  0.4623607    0.3219
CAMEROON                  0.2592454 -0.0243902  0.1593129  0.7106167    0.2387
NIGERIA                   0.1137709 -0.0243902  0.2037796  0.3060593    0.3798
GABON                     0.2036649 -0.0243902  0.4261130  0.3493635    0.3634
CENTRAL AFRICAN REPUBLIC -0.4420567 -0.0243902  0.1593129 -1.0464153    0.8523
CHAD                     -0.1052846 -0.0243902  0.1296684 -0.2246472    0.5889
CONGO                     0.0113803 -0.0243902  0.2037796  0.0792401    0.4684
ZAIRE                     0.7097807 -0.0243902  0.0802610  2.5914625    0.0048
ANGOLA                    0.1179749 -0.0243902  0.2778907  0.2700640    0.3936
UGANDA                    1.9425080 -0.0243902  0.1593129  4.9278382    0.0000
KENYA                     1.1969287 -0.0243902  0.1593129  3.0598747    0.0011
TANZANIA                  0.2718545 -0.0243902  0.0926129  0.9734529    0.1652
BURUNDI                  -0.4842787 -0.0243902  0.2778907 -0.8723997    0.8085
RWANDA                   -0.7523578 -0.0243902  0.2037796 -1.6126187    0.9466
SOMALIA                   0.4527658 -0.0243902  0.4261130  0.7309674    0.2324
ETHIOPIA                  0.7251240 -0.0243902  0.2778907  1.4218143    0.0775
ZAMBIA                    0.0421598 -0.0243902  0.0926129  0.2186818    0.4134
ZIMBABWE                 -0.0095068 -0.0243902  0.2037796  0.0329703    0.4868
MALAWI                   -0.2288840 -0.0243902  0.2778907 -0.3879207    0.6510
MOZAMBIQUE                0.0167900 -0.0243902  0.1296684  0.1143594    0.4545
SOUTH AFRICA             -0.1825396 -0.0243902  0.1084938 -0.4801368    0.6844
LESOTHO                  -0.4193478 -0.0243902  0.8707799 -0.4232493    0.6639
BOTSWANA                 -0.0039316 -0.0243902  0.2778907  0.0388096    0.4845
SWAZILAND                 0.0166842 -0.0243902  0.4261130  0.0629231    0.4749
MOROCCO                  -0.0969607 -0.0243902  0.4261130 -0.1111725    0.5443
ALGERIA                  -0.0100369 -0.0243902  0.1296684  0.0398599    0.4841
TUNISIA                   0.0053873 -0.0243902  0.4261130  0.0456170    0.4818
LIBYA                     0.8038237 -0.0243902  0.1296684  2.2999872    0.0107
SUDAN                     2.9877738 -0.0243902  0.0926129  9.8978982    0.0000
EGYPT                     6.9467291 -0.0243902  0.4261130 10.6792343    0.0000
> hist(resI[,5])
> resI <- localmoran(afcon$totcon, nb2listw(paper.nb),
+  p.adjust.method="bonferroni")
> printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
+  check.names=FALSE)
                                 Ii       E.Ii     Var.Ii       Z.Ii Pr.z...0.
THE GAMBIA                0.3752254 -0.0243902  0.8707799  0.4282410    0.6685
MALI                      0.4636340 -0.0243902  0.1084938  1.4816272    0.5538
SENEGAL                   0.2567014 -0.0243902  0.2037796  0.6226838    1.0000
BENIN                     0.1941194 -0.0243902  0.2037796  0.4840501    1.0000
MAURITANIA                0.0970535 -0.0243902  0.2037796  0.2690263    1.0000
NIGER                     0.2307143 -0.0243902  0.1084938  0.7744898    1.0000
IVORY COAST               0.2900359 -0.0243902  0.1593129  0.7877586    1.0000
GUINEA                    0.1826275 -0.0243902  0.1593129  0.5186592    1.0000
BURKINA FASO              0.5082778 -0.0243902  0.1296684  1.4792430    0.4868
LIBERIA                   0.1856475 -0.0243902  0.2778907  0.3984375    1.0000
SIERRA LEONE              0.2652337 -0.0243902  0.4261130  0.4436823    0.9859
GHANA                     0.1476406 -0.0243902  0.2778907  0.3263392    1.0000
TOGO                      0.2193448 -0.0243902  0.2778907  0.4623607    1.0000
CAMEROON                  0.2592454 -0.0243902  0.1593129  0.7106167    1.0000
NIGERIA                   0.1137709 -0.0243902  0.2037796  0.3060593    1.0000
GABON                     0.2036649 -0.0243902  0.4261130  0.3493635    1.0000
CENTRAL AFRICAN REPUBLIC -0.4420567 -0.0243902  0.1593129 -1.0464153    1.0000
CHAD                     -0.1052846 -0.0243902  0.1296684 -0.2246472    1.0000
CONGO                     0.0113803 -0.0243902  0.2037796  0.0792401    1.0000
ZAIRE                     0.7097807 -0.0243902  0.0802610  2.5914625    0.0478
ANGOLA                    0.1179749 -0.0243902  0.2778907  0.2700640    1.0000
UGANDA                    1.9425080 -0.0243902  0.1593129  4.9278382    0.0000
KENYA                     1.1969287 -0.0243902  0.1593129  3.0598747    0.0066
TANZANIA                  0.2718545 -0.0243902  0.0926129  0.9734529    1.0000
BURUNDI                  -0.4842787 -0.0243902  0.2778907 -0.8723997    1.0000
RWANDA                   -0.7523578 -0.0243902  0.2037796 -1.6126187    1.0000
SOMALIA                   0.4527658 -0.0243902  0.4261130  0.7309674    0.6972
ETHIOPIA                  0.7251240 -0.0243902  0.2778907  1.4218143    0.3102
ZAMBIA                    0.0421598 -0.0243902  0.0926129  0.2186818    1.0000
ZIMBABWE                 -0.0095068 -0.0243902  0.2037796  0.0329703    1.0000
MALAWI                   -0.2288840 -0.0243902  0.2778907 -0.3879207    1.0000
MOZAMBIQUE                0.0167900 -0.0243902  0.1296684  0.1143594    1.0000
SOUTH AFRICA             -0.1825396 -0.0243902  0.1084938 -0.4801368    1.0000
LESOTHO                  -0.4193478 -0.0243902  0.8707799 -0.4232493    1.0000
BOTSWANA                 -0.0039316 -0.0243902  0.2778907  0.0388096    1.0000
SWAZILAND                 0.0166842 -0.0243902  0.4261130  0.0629231    1.0000
MOROCCO                  -0.0969607 -0.0243902  0.4261130 -0.1111725    1.0000
ALGERIA                  -0.0100369 -0.0243902  0.1296684  0.0398599    1.0000
TUNISIA                   0.0053873 -0.0243902  0.4261130  0.0456170    1.0000
LIBYA                     0.8038237 -0.0243902  0.1296684  2.2999872    0.0751
SUDAN                     2.9877738 -0.0243902  0.0926129  9.8978982    0.0000
EGYPT                     6.9467291 -0.0243902  0.4261130 10.6792343    0.0000
> hist(resI[,5])
> totcon <-afcon$totcon
> is.na(totcon) <- sample(1:length(totcon), 5)
> totcon
 [1] 1363 1421 1861 2355 5246  811  299   NA  895 4751 1878   NA  347 1130  241
[16]   NA 1015  998 2122 1090  848  618   NA  423  980 3087 2273 3134 1142  824
[31] 2881  487  604 1528 1554   NA  792  795 1266 1875  147  363
> resI.na <- localmoran(totcon, nb2listw(paper.nb), na.action=na.exclude,
+  zero.policy=TRUE)
> if (class(attr(resI.na, "na.action")) == "exclude") {
+  print(data.frame(resI.na[oid,], row.names=afcon$name[oid]), digits=2)
+ } else print(resI.na, digits=2)
                              Ii   E.Ii Var.Ii     Z.Ii Pr.z...0.
THE GAMBIA                0.0000  0.000  0.000      NaN       NaN
MALI                      0.4726 -0.028  0.202  1.11364   1.3e-01
SENEGAL                       NA     NA     NA       NA        NA
BENIN                     0.2259 -0.028  0.276  0.48257   3.1e-01
MAURITANIA                0.1201 -0.028  0.276  0.28125   3.9e-01
NIGER                         NA     NA     NA       NA        NA
IVORY COAST                   NA     NA     NA       NA        NA
GUINEA                    0.2847 -0.028  0.276  0.59444   2.8e-01
BURKINA FASO              0.5273 -0.028  0.202  1.23523   1.1e-01
LIBERIA                   0.2546 -0.028  0.425  0.43318   3.3e-01
SIERRA LEONE              0.3450 -0.028  0.425  0.57183   2.8e-01
GHANA                     0.2269 -0.028  0.425  0.39060   3.5e-01
TOGO                      0.2852 -0.028  0.276  0.59551   2.8e-01
CAMEROON                      NA     NA     NA       NA        NA
NIGERIA                   0.1183 -0.028  0.425  0.22411   4.1e-01
GABON                     0.1418 -0.028  0.871  0.18168   4.3e-01
CENTRAL AFRICAN REPUBLIC -0.6398 -0.028  0.202 -1.36207   9.1e-01
CHAD                     -0.3194 -0.028  0.202 -0.64892   7.4e-01
CONGO                    -0.0149 -0.028  0.276  0.02448   4.9e-01
ZAIRE                     0.5103 -0.028  0.078  1.92726   2.7e-02
ANGOLA                    0.0460 -0.028  0.276  0.14027   4.4e-01
UGANDA                    1.5980 -0.028  0.157  4.09940   2.1e-05
KENYA                     0.9448 -0.028  0.157  2.45251   7.1e-03
TANZANIA                  0.2823 -0.028  0.106  0.95116   1.7e-01
BURUNDI                  -0.4492 -0.028  0.276 -0.80181   7.9e-01
RWANDA                   -0.7107 -0.028  0.202 -1.51973   9.4e-01
SOMALIA                   0.3232 -0.028  0.425  0.53830   3.0e-01
ETHIOPIA                  0.5257 -0.028  0.276  1.05296   1.5e-01
ZAMBIA                    0.0250 -0.028  0.106  0.16189   4.4e-01
ZIMBABWE                  0.0357 -0.028  0.202  0.14121   4.4e-01
MALAWI                        NA     NA     NA       NA        NA
MOZAMBIQUE               -0.0029 -0.028  0.157  0.06262   4.8e-01
SOUTH AFRICA             -0.1704 -0.028  0.106 -0.43759   6.7e-01
LESOTHO                  -0.3519 -0.028  0.871 -0.34725   6.4e-01
BOTSWANA                  0.0049 -0.028  0.276  0.06219   4.8e-01
SWAZILAND                 0.1088 -0.028  0.425  0.20946   4.2e-01
MOROCCO                  -0.1034 -0.028  0.425 -0.11600   5.5e-01
ALGERIA                   0.0019 -0.028  0.157  0.07481   4.7e-01
TUNISIA                  -0.0273 -0.028  0.425  0.00073   5.0e-01
LIBYA                     0.8883 -0.028  0.157  2.30998   1.0e-02
SUDAN                     2.4774 -0.028  0.090  8.33526   3.9e-17
EGYPT                     6.0584 -0.028  0.425  9.33517   5.0e-21
> resG <- localG(afcon$totcon, nb2listw(include.self(paper.nb)))
> print(data.frame(resG[oid], row.names=afcon$name[oid]), digits=2)
                         resG.oid.
THE GAMBIA                  -0.984
MALI                        -1.699
SENEGAL                     -1.463
BENIN                       -1.301
MAURITANIA                  -0.605
NIGER                       -1.049
IVORY COAST                 -1.417
GUINEA                      -1.449
BURKINA FASO                -1.751
LIBERIA                     -1.041
SIERRA LEONE                -0.870
GHANA                       -1.103
TOGO                        -0.991
CAMEROON                    -1.133
NIGERIA                     -1.173
GABON                       -0.789
CENTRAL AFRICAN REPUBLIC     1.173
CHAD                         0.463
CONGO                       -0.203
ZAIRE                        2.023
ANGOLA                       1.235
UGANDA                       3.336
KENYA                        3.503
TANZANIA                     1.098
BURUNDI                      0.774
RWANDA                       1.457
SOMALIA                      1.183
ETHIOPIA                     2.627
ZAMBIA                       0.753
ZIMBABWE                    -0.200
MALAWI                       0.212
MOZAMBIQUE                  -0.288
SOUTH AFRICA                -0.868
LESOTHO                     -0.298
BOTSWANA                     0.041
SWAZILAND                   -0.659
MOROCCO                      0.022
ALGERIA                     -0.363
TUNISIA                      0.579
LIBYA                        2.553
SUDAN                        4.039
EGYPT                        4.421
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("localmoran", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("localmoran.exact")
> ### * localmoran.exact
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: localmoran.exact
> ### Title: Exact local Moran's Ii tests
> ### Aliases: localmoran.exact localmoran.exact.alt print.localmoranex
> ###   as.data.frame.localmoranex
> ### Keywords: spatial
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> eire <- readShapePoly(system.file("etc/shapes/eire.shp", package="spdep")[1],
+   ID="names", proj4string=CRS("+proj=utm +zone=30 +units=km"))
> eire.nb <- poly2nb(eire)
> #data(eire)
> e.lm <- lm(OWNCONS ~ ROADACC, data=eire)
> localmoran.sad(e.lm, nb=eire.nb)
             Local Morans I Saddlepoint    Pr. (Sad)
1 Carlow         0.21699668  0.95074844 1.708660e-01
2 Cavan         -0.37257361 -1.00603119 8.427997e-01
3 Clare          0.23197510  0.67166518 2.508984e-01
4 Cork           0.78193548  1.74761575 4.026529e-02
5 Donegal       -1.69064059 -1.72031078 9.573120e-01
6 Dublin        -0.16069692 -0.35212627 6.376282e-01
7 Galway         1.31371473  2.66849536 3.809592e-03
8 Kerry          0.36534866  0.78073279 2.174798e-01
9 Kildare       -0.02557544  0.04167665 4.833782e-01
10 Kilkenny      0.57684331  1.70897697 4.372761e-02
11 Laoghis      -0.05951798 -0.12155465 5.483741e-01
12 Leitrim       0.38484587  1.47227033 7.047395e-02
13 Limerick      0.11817987  0.45727712 3.237359e-01
14 Longford      1.41643200  2.51113769 6.017137e-03
15 Louth         0.56242920  1.07441571 1.413182e-01
16 Mayo          0.87572704  2.05251226 2.005995e-02
17 Meath         0.00367856  0.12813539 4.490209e-01
18 Monaghan      0.55098311  1.23999193 1.074892e-01
19 Offaly        0.15155556  0.80786519 2.095841e-01
20 Roscommon     2.04368839  4.53187292 2.923151e-06
21 Sligo        -0.47579871 -0.94578114 8.278699e-01
22 Tipperary    -0.03454106 -0.06919691 5.275836e-01
23 Waterford     0.85723423  1.91385108 2.781959e-02
24 Westmeath     0.45138572  1.36017204 8.688774e-02
25 Wexford       0.64371834  1.63188492 5.135187e-02
26 Wicklow       0.02441950  0.21197000 4.160652e-01
> localmoran.exact(e.lm, nb=eire.nb)
             Local Morans I    Exact SD  Pr. (exact)
1 Carlow         0.21699668  1.02706083 1.521959e-01
2 Cavan         -0.37257361 -1.04864802 8.528299e-01
3 Clare          0.23197510  0.76362894 2.225442e-01
4 Cork           0.78193548  1.77727656 3.776137e-02
5 Donegal       -1.69064059 -1.74428756 9.594455e-01
6 Dublin        -0.16069692 -0.44236119 6.708861e-01
7 Galway         1.31371473  2.69199974 3.551250e-03
8 Kerry          0.36534866  0.85742696 1.956045e-01
9 Kildare       -0.02557544 -0.03475476 5.138624e-01
10 Kilkenny      0.57684331  1.74146177 4.080133e-02
11 Laoghis      -0.05951798 -0.21824035 5.863791e-01
12 Leitrim       0.38484587  1.51434641 6.496900e-02
13 Limerick      0.11817987  0.56922630 2.846013e-01
14 Longford      1.41643200  2.53491837 5.623677e-03
15 Louth         0.56242920  1.12775107 1.297125e-01
16 Mayo          0.87572704  2.08125803 1.870515e-02
17 Meath         0.00367856  0.16372685 4.349731e-01
18 Monaghan      0.55098311  1.28435459 9.950896e-02
19 Offaly        0.15155556  0.89537870 1.852923e-01
20 Roscommon     2.04368839  4.55244870 2.651255e-06
21 Sligo        -0.47579871 -0.98101752 8.367079e-01
22 Tipperary    -0.03454106 -0.16132608 5.640817e-01
23 Waterford     0.85723423  1.94188723 2.607538e-02
24 Westmeath     0.45138572  1.40091422 8.061986e-02
25 Wexford       0.64371834  1.66488051 4.796830e-02
26 Wicklow       0.02441950  0.29717701 3.831657e-01
> localmoran.exact(e.lm, nb=eire.nb, useTP=TRUE)
             Local Morans I    Exact SD  Pr. (exact)
1 Carlow         0.21699668  1.02706127 1.521958e-01
2 Cavan         -0.37257361 -1.04864834 8.528300e-01
3 Clare          0.23197510  0.76362936 2.225441e-01
4 Cork           0.78193548  1.77727666 3.776137e-02
5 Donegal       -1.69064059 -1.74428741 9.594455e-01
6 Dublin        -0.16069692 -0.44236158 6.708862e-01
7 Galway         1.31371473  2.69199162 3.551337e-03
8 Kerry          0.36534866  0.85742736 1.956044e-01
9 Kildare       -0.02557544 -0.03540278 5.141207e-01
10 Kilkenny      0.57684331  1.74146192 4.080132e-02
11 Laoghis      -0.05951798 -0.21823772 5.863780e-01
12 Leitrim       0.38484587  1.51434680 6.496895e-02
13 Limerick      0.11817987  0.56922674 2.846011e-01
14 Longford      1.41643200  2.53491383 5.623749e-03
15 Louth         0.56242920  1.12775145 1.297125e-01
16 Mayo          0.87572704  2.08125778 1.870516e-02
17 Meath         0.00367856  0.15714487 4.375653e-01
18 Monaghan      0.55098311  1.28435495 9.950889e-02
19 Offaly        0.15155556  0.89537914 1.852922e-01
20 Roscommon     2.04368839  4.53362873 2.898945e-06
21 Sligo        -0.47579871 -0.98101780 8.367080e-01
22 Tipperary    -0.03454106 -0.16116590 5.640186e-01
23 Waterford     0.85723423  1.94188711 2.607538e-02
24 Westmeath     0.45138572  1.40091457 8.061981e-02
25 Wexford       0.64371834  1.66488069 4.796828e-02
26 Wicklow       0.02441950  0.29790569 3.828876e-01
> e.errorsar <- errorsarlm(OWNCONS ~ ROADACC, data=eire,
+  listw=nb2listw(eire.nb))
> lm.target <- lm(e.errorsar$tary ~ e.errorsar$tarX - 1)
> localmoran.exact.alt(lm.target, nb=eire.nb)
             Local Morans I    Exact SD Pr. (exact)
1 Carlow         0.17958462  0.83313548 0.202384163
2 Cavan         -0.24752628 -0.82861508 0.796338874
3 Clare         -0.27901334 -0.72313220 0.765200665
4 Cork           0.37808655  1.15083938 0.124899160
5 Donegal       -1.01894688 -1.50937607 0.934398648
6 Dublin        -0.18171297 -0.50995181 0.694957388
7 Galway         1.02193390  2.27605549 0.011421344
8 Kerry         -0.94967914 -1.46954733 0.929157803
9 Kildare        0.07005053  0.56174770 0.287143966
10 Kilkenny      0.43022231  1.39078833 0.082144811
11 Laoghis      -0.12239133 -0.45750046 0.676344316
12 Leitrim      -0.24203970 -0.84925558 0.802130454
13 Limerick     -0.03214546 -0.13098232 0.552105354
14 Longford      0.38307454  1.17909760 0.119179658
15 Louth         0.21301552  0.62068302 0.267404102
16 Mayo          0.93971200  1.94079901 0.026141330
17 Meath         0.12484415  0.78747315 0.215502469
18 Monaghan     -0.16109919 -0.48277561 0.685372466
19 Offaly       -0.00632492  0.03008421 0.487999946
20 Roscommon     1.02089429  2.64333471 0.004104692
21 Sligo        -2.01629233 -2.54211789 0.994490850
22 Tipperary    -0.10810709 -0.51063241 0.695195761
23 Waterford     0.44099279  1.28152280 0.100005048
24 Westmeath    -0.06329661 -0.26575204 0.604784909
25 Wexford       0.30764883  1.02115599 0.153590270
26 Wicklow      -0.01696406 -0.04109885 0.516391453
> Omega <- invIrW(nb2listw(eire.nb), rho=0.6)
> Omega1 <- tcrossprod(Omega)
> localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1)
             Local Morans I    Exact SD Pr. (exact)
1 Carlow         0.17958462  0.23106310  0.40863289
2 Cavan         -0.24752628 -1.23468946  0.89152695
3 Clare         -0.27901334 -1.23568141  0.89171149
4 Cork           0.37808655  0.37129164  0.35521016
5 Donegal       -1.01894688 -1.84902973  0.96777324
6 Dublin        -0.18171297 -0.98014854  0.83649360
7 Galway         1.02193390  1.60349636  0.05441256
8 Kerry         -0.94967914 -2.12070807  0.98302681
9 Kildare        0.07005053  0.10764694  0.45713788
10 Kilkenny      0.43022231  0.72290576  0.23486889
11 Laoghis      -0.12239133 -0.87106287  0.80814009
12 Leitrim      -0.24203970 -1.37942752  0.91611851
13 Limerick     -0.03214546 -0.68255487  0.75255592
14 Longford      0.38307454  0.47071571  0.31892188
15 Louth         0.21301552  0.02198178  0.49123125
16 Mayo          0.93971200  1.30000024  0.09680044
17 Meath         0.12484415  0.15994490  0.43646224
18 Monaghan     -0.16109919 -1.05555833  0.85441498
19 Offaly       -0.00632492 -0.29850266  0.61734023
20 Roscommon     1.02089429  1.58863478  0.05607144
21 Sligo        -2.01629233 -3.26456072  0.99945183
22 Tipperary    -0.10810709 -0.98217198  0.83699244
23 Waterford     0.44099279  0.66779678  0.25213166
24 Westmeath    -0.06329661 -0.70911718  0.76087412
25 Wexford       0.30764883  0.37769998  0.35282674
26 Wicklow      -0.01696406 -0.54705602  0.70782988
> localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1, useTP=TRUE)
             Local Morans I    Exact SD Pr. (exact)
1 Carlow         0.17958462  0.23106345  0.40863276
2 Cavan         -0.24752628 -1.23468995  0.89152704
3 Clare         -0.27901334 -1.23568183  0.89171157
4 Cork           0.37808655  0.37129179  0.35521011
5 Donegal       -1.01894688 -1.84902980  0.96777324
6 Dublin        -0.18171297 -0.98014903  0.83649372
7 Galway         1.02193390  1.60349632  0.05441256
8 Kerry         -0.94967914 -2.12070821  0.98302682
9 Kildare        0.07005053  0.10764406  0.45713902
10 Kilkenny      0.43022231  0.72290590  0.23486885
11 Laoghis      -0.12239133 -0.87106429  0.80814047
12 Leitrim      -0.24203970 -1.37942813  0.91611860
13 Limerick     -0.03214546 -0.68260211  0.75257085
14 Longford      0.38307454  0.47071586  0.31892183
15 Louth         0.21301552  0.02198203  0.49123115
16 Mayo          0.93971200  1.30000026  0.09680044
17 Meath         0.12484415  0.15994587  0.43646186
18 Monaghan     -0.16109919 -1.05555896  0.85441512
19 Offaly       -0.00632492 -0.29479749  0.61592571
20 Roscommon     1.02089429  1.58863472  0.05607144
21 Sligo        -2.01629233 -3.26455056  0.99945181
22 Tipperary    -0.10810709 -0.98217470  0.83699310
23 Waterford     0.44099279  0.66779690  0.25213162
24 Westmeath    -0.06329661 -0.70910521  0.76087041
25 Wexford       0.30764883  0.37770018  0.35282667
26 Wicklow      -0.01696406 -0.54778213  0.70807925
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("localmoran.exact", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("localmoran.sad")
> ### * localmoran.sad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: localmoran.sad
> ### Title: Saddlepoint approximation of local Moran's Ii tests
> ### Aliases: localmoran.sad listw2star print.summary.localmoransad
> ###   summary.localmoransad print.localmoransad as.data.frame.localmoransad
> ### Keywords: spatial
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> eire <- readShapePoly(system.file("etc/shapes/eire.shp", package="spdep")[1],
+   ID="names", proj4string=CRS("+proj=utm +zone=30 +units=km"))
> eire.nb <- poly2nb(eire)
> #data(eire)
> e.lm <- lm(OWNCONS ~ ROADACC, data=eire)
> e.locmor <- summary(localmoran.sad(e.lm, nb=eire.nb))
> e.locmor
             Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint
1 Carlow         0.21699668      0.74177148 2.291129e-01  0.95074844
2 Cavan         -0.37257361     -0.81297374 7.918834e-01 -1.00603119
3 Clare          0.23197510      0.49502499 3.102912e-01  0.67166518
4 Cork           0.78193548      1.75999915 3.920398e-02  1.74761575
5 Donegal       -1.69064059     -1.98244914 9.762855e-01 -1.72031078
6 Dublin        -0.16069692     -0.15041940 5.597831e-01 -0.35212627
7 Galway         1.31371473      3.34305297 4.143104e-04  2.66849536
8 Kerry          0.36534866      0.58147812 2.804591e-01  0.78073279
9 Kildare       -0.02557544      0.15146558 4.398042e-01  0.04167665
10 Kilkenny      0.57684331      1.62868431 5.168993e-02  1.70897697
11 Laoghis      -0.05951798      0.01724651 4.931200e-01 -0.12155465
12 Leitrim       0.38484587      1.27548777 1.010683e-01  1.47227033
13 Limerick      0.11817987      0.34038037 3.667850e-01  0.45727712
14 Longford      1.41643200      3.10732224 9.439524e-04  2.51113769
15 Louth         0.56242920      0.87665682 1.903365e-01  1.07441571
16 Mayo          0.87572704      2.02375701 2.149758e-02  2.05251226
17 Meath         0.00367856      0.16081712 4.361187e-01  0.12813539
18 Monaghan      0.55098311      1.06684464 1.430210e-01  1.23999193
19 Offaly        0.15155556      0.61933942 2.678464e-01  0.80786519
20 Roscommon     2.04368839      6.66107106 1.359196e-11  4.53187292
21 Sligo        -0.47579871     -0.73430274 7.686179e-01 -0.94578114
22 Tipperary    -0.03454106      0.04843351 4.806854e-01 -0.06919691
23 Waterford     0.85723423      1.98516133 2.356326e-02  1.91385108
24 Westmeath     0.45138572      1.20305006 1.144785e-01  1.36017204
25 Wexford       0.64371834      1.55468550 6.001049e-02  1.63188492
26 Wicklow       0.02441950      0.21823347 4.136236e-01  0.21197000
                Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum
1 Carlow     1.708660e-01 -0.06471134 0.14423085 -0.7895263 7.059116  -5.461326
2 Cavan      8.427997e-01 -0.04030838 0.16703857 -0.4622793 6.813004  -5.567356
3 Clare      2.508984e-01 -0.04219377 0.30674823 -0.3579185 6.761932  -7.406885
4 Cork       4.026529e-02 -0.04363826 0.22003250 -0.4363325 6.799081  -6.360927
5 Donegal    9.573120e-01 -0.11935726 0.62821008 -0.7004303 6.979051 -11.236382
6 Dublin     6.376282e-01 -0.08240217 0.27093033 -0.7352902 7.009201  -7.420687
7 Galway     3.809592e-03 -0.04389010 0.16491503 -0.5059997 6.838308  -5.573707
8 Kerry      2.174798e-01 -0.03212369 0.46724761 -0.2212594 6.714810  -8.915104
9 Kildare    4.833782e-01 -0.07623733 0.11187546 -1.0416026 7.339962  -4.999621
10 Kilkenny  4.372761e-02 -0.05911601 0.15247016 -0.7040737 6.982131  -5.538889
11 Laoghis   5.483741e-01 -0.06620117 0.15016408 -0.7915137 7.061015  -5.574277
12 Leitrim   7.047395e-02 -0.06828680 0.12621127 -0.8864130 7.157471  -5.186756
13 Limerick  3.237359e-01 -0.04172917 0.22070746 -0.4167943 6.789132  -6.348870
14 Longford  6.017137e-03 -0.04055162 0.21985521 -0.4059156 6.783792  -6.324457
15 Louth     1.413182e-01 -0.04386717 0.47831137 -0.2983105 6.738631  -9.149779
16 Mayo      2.005995e-02 -0.10340651 0.23408152 -0.9804377 7.264328  -7.165847
17 Meath     4.490209e-01 -0.04799533 0.10324707 -0.6949022 6.974408  -4.551176
18 Monaghan  1.074892e-01 -0.04136950 0.30828917 -0.3501006 6.758633  -7.415047
19 Offaly    2.095841e-01 -0.04662212 0.10238870 -0.6782821 6.960676  -4.519986
20 Roscommon 2.923151e-06 -0.04435301 0.09826301 -0.6591526 6.945294  -4.414164
21 Sligo     8.278699e-01 -0.11041170 0.24760301 -1.0156782 7.307311  -7.409091
22 Tipperary 5.275836e-01 -0.04872132 0.08571886 -0.7716947 7.042300  -4.198353
23 Waterford 2.781959e-02 -0.05435079 0.21086415 -0.5533724 6.868342  -6.353514
24 Westmeath 8.688774e-02 -0.04181671 0.16806722 -0.4779156 6.821788  -5.599610
25 Wexford   5.135187e-02 -0.05432673 0.20159596 -0.5654870 6.876461  -6.225016
26 Wicklow   4.160652e-01 -0.07022471 0.18808122 -0.7515626 7.023792  -6.198974
              Maximum        omega       sad.r       sad.u
1 Carlow     3.908254  0.071122863  0.71853146  0.84900467
2 Cavan      4.599954 -0.051532330 -0.69003582 -0.85816092
3 Clare      6.394234  0.031939551  0.46982957  0.51656357
4 Cork       5.313609  0.083281515  1.43928884  2.24323856
5 Donegal    8.371808 -0.039371561 -1.39288713 -2.19776923
6 Dublin     5.443035 -0.010354512 -0.14127218 -0.14554367
7 Galway     4.520344  0.134873939  2.39189491  4.63522665
8 Kerry      8.144135  0.028431952  0.54051534  0.61545648
9 Kildare    3.169925  0.018723213  0.14926096  0.14688325
10 Kilkenny  4.120105  0.105365819  1.40668493  2.15214600
11 Laoghis   3.985449  0.001724096  0.01660985  0.01657177
12 Leitrim   3.547872  0.109608339  1.18229964  1.66578026
13 Limerick  5.347370  0.027585567  0.32820959  0.34241163
14 Longford  5.351218  0.108368224  2.22687206  4.19385821
15 Louth     8.096967  0.037745731  0.78968254  0.98878788
16 Mayo      4.684091  0.105317102  1.75922892  2.94711915
17 Meath     3.399289  0.020074178  0.15693992  0.15623206
18 Monaghan  6.422179  0.053418031  0.94193428  1.24723730
19 Offaly    3.401055  0.071432961  0.59871278  0.67858124
20 Roscommon 3.349691  0.357114199  4.33885200 10.02517077
21 Sligo     4.759210 -0.036185300 -0.60775394 -0.74635955
22 Tipperary 3.029041  0.006482570  0.04683010  0.04657633
23 Waterford 5.049095  0.093409563  1.61022194  2.62552879
24 Westmeath 4.596009  0.080097979  1.05978192  1.45704611
25 Wexford   4.921174  0.085478829  1.32647942  1.98902088
26 Wicklow   4.513581  0.020437514  0.21417067  0.21406975
> mean(e.locmor[,1])
[1] 0.3366057
> lm.morantest(e.lm, nb2listw(eire.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = OWNCONS ~ ROADACC, data = eire)
weights: nb2listw(eire.nb)

Moran I statistic standard deviate = 3.2575, p-value = 0.0005619
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
        0.33660565        -0.05877741         0.01473183 

> hist(e.locmor[,"Pr. (Sad)"])
> e.wlm <- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE)
> e.locmorw1 <- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=weighted.residuals))
> e.locmorw1
             Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint
1 Carlow        0.160490657      0.41009538 3.408680e-01  0.57729730
2 Cavan        -0.144663771     -0.27825575 6.095920e-01 -0.45305168
3 Clare         0.301676582      0.59021701 2.775226e-01  0.78987327
4 Cork          1.520488153      3.49016956 2.413571e-04  2.83665634
5 Donegal      -0.435899664     -0.44665946 6.724395e-01 -0.67136090
6 Dublin       -0.340222996     -0.60886675 7.286936e-01 -0.85658016
7 Galway        1.469009037      3.64546192 1.334560e-04  2.82274510
8 Kerry         0.268957279      0.49517211 3.102393e-01  0.66861012
9 Kildare       0.002996577      0.12659200 4.496317e-01  0.09978249
10 Kilkenny     0.497968801      1.20610829 1.138879e-01  1.34091379
11 Laoghis     -0.026328708     -0.01713904 5.068372e-01 -0.06511750
12 Leitrim      0.277306386      0.80644537 2.099930e-01  1.01176491
13 Limerick     0.263122939      0.67591893 2.495461e-01  0.87759628
14 Longford     0.605211711      1.23874274 1.077204e-01  1.35375850
15 Louth        0.359469683      0.53572990 2.960726e-01  0.73280188
16 Mayo         1.742480472      3.68118786 1.160749e-04  3.01500163
17 Meath       -0.112171618     -0.26680698 6.051911e-01 -0.45470531
18 Monaghan     0.241044892      0.46013751 3.227088e-01  0.64094159
19 Offaly       0.129191178      0.40988983 3.409434e-01  0.57205532
20 Roscommon    1.469671750      4.39927211 5.430728e-06  3.13215267
21 Sligo        0.095559559      0.31036587 3.781414e-01  0.38503064
22 Tipperary    0.088352646      0.39958273 3.447319e-01  0.52592105
23 Waterford    1.212658861      2.69846035 3.483052e-03  2.29292584
24 Westmeath    0.256165310      0.61222265 2.701952e-01  0.81620859
25 Wexford      0.619197906      1.31967483 9.347180e-02  1.42553832
26 Wicklow      0.006531073      0.13142161 4.477209e-01  0.10986725
                Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum
1 Carlow     0.2818693197 -0.01840558 0.19029731 -0.1986977 6.709176  -5.665283
2 Cavan      0.6747442370 -0.02184465 0.19482455 -0.2329761 6.717975  -5.769371
3 Clare      0.2148008928 -0.02782578 0.31166901 -0.2346279 6.718435  -7.299407
4 Cork       0.0022794326 -0.07147410 0.20805228 -0.7280203 7.002789  -6.495227
5 Donegal    0.7490046749 -0.07638800 0.64784767 -0.4450323 6.803659 -10.931345
6 Dublin     0.8041615226 -0.11187469 0.14065367 -1.3324828 7.767845  -5.846924
7 Galway     0.0023807205 -0.04407925 0.17227545 -0.4973247 6.833103  -5.688263
8 Kerry      0.2518721070 -0.05644300 0.43184063 -0.4031537 6.782459  -8.859407
9 Kildare    0.4602585046 -0.04145378 0.12329287 -0.5519841 6.867423  -4.857131
10 Kilkenny  0.0899742229 -0.02321457 0.18672759 -0.2528322 6.723714  -5.669156
11 Laoghis   0.5259597777 -0.01882531 0.19166504 -0.2024943 6.710081  -5.689691
12 Leitrim   0.1558252365 -0.03314655 0.14819776 -0.4041387 6.782933  -5.190860
13 Limerick  0.1900814236 -0.04800976 0.21188592 -0.4885390 6.827925  -6.298874
14 Longford  0.0879067180 -0.01321709 0.24923967 -0.1247567 6.694960  -6.392250
15 Louth     0.2318396371 -0.02272663 0.50895713 -0.1500895 6.699098  -9.179410
16 Mayo      0.0012848894 -0.09458039 0.24904116 -0.8745463 7.144787  -7.272523
17 Meath     0.6753393701 -0.02548973 0.10555100 -0.3685280 6.766525  -4.353122
18 Monaghan  0.2607803159 -0.02333303 0.33012248 -0.1912612 6.707452  -7.451275
19 Offaly    0.2836422486 -0.01927989 0.13120470 -0.2505068 6.723017  -4.750083
20 Roscommon 0.0008676481 -0.02385522 0.11525625 -0.3302939 6.750604  -4.517676
21 Sligo     0.3501073587 -0.06927688 0.28207107 -0.6087587 6.906925  -7.416881
22 Tipperary 0.2994715317 -0.03719246 0.09871568 -0.5534442 6.868390  -4.347214
23 Waterford 0.0109261375 -0.04027429 0.21558757 -0.4070996 6.784366  -6.264083
24 Westmeath 0.2071904211 -0.01522814 0.19650786 -0.1618342 6.701275  -5.716689
25 Wexford   0.0770008257 -0.02786850 0.24041626 -0.2674357 6.728234  -6.450174
26 Wicklow   0.4562573299 -0.04751424 0.16911517 -0.5404006 6.859847  -5.677417
              Maximum        omega       sad.r       sad.u
1 Carlow     5.223549  0.033637462  0.38794383  0.41751442
2 Cavan      5.245099 -0.022294725 -0.26091513 -0.27432856
3 Clare      6.631589  0.035302524  0.54866959  0.62630505
4 Cork       4.779848  0.134384022  2.56890121  5.11058941
5 Donegal    9.098033 -0.017507303 -0.40402088 -0.45010348
6 Dublin     3.161931 -0.040828131 -0.50710580 -0.60543071
7 Galway     4.630361  0.138454493  2.55314856  5.08170760
8 Kerry      7.504775  0.027195108  0.47167584  0.51758880
9 Kildare    3.862240  0.014230854  0.12280697  0.12246022
10 Kilkenny  5.112007  0.071351828  1.03314661  1.41988761
11 Laoghis   5.237883 -0.001502568 -0.01645549 -0.01646868
12 Leitrim   4.395343  0.066207108  0.74158109  0.90609823
13 Limerick  5.146640  0.050265468  0.63703133  0.74253221
14 Longford  6.075040  0.060534639  1.04112815  1.44165700
15 Louth     8.633971  0.025231866  0.49793592  0.55971045
16 Mayo      5.002594  0.135902733  2.75603129  5.62669411
17 Meath     3.741368 -0.028724497 -0.24912602 -0.26221742
18 Monaghan  6.891283  0.028042744  0.43280552  0.47360371
19 Offaly    4.287365  0.040883462  0.38909358  0.41780262
20 Roscommon 3.945151  0.180270100  2.87643937  6.00202551
21 Sligo     5.754236  0.023145822  0.30299868  0.31062426
22 Tipperary 3.454595  0.048932861  0.38768333  0.40902706
23 Waterford 5.297500  0.101874758  1.99944904  3.59542986
24 Westmeath 5.351214  0.044919886  0.56403221  0.65024353
25 Wexford   5.781330  0.066083430  1.11524637  1.57637406
26 Wicklow   4.537075  0.012609906  0.12748740  0.12720134
> e.locmorw2 <- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=rstudent))
> e.locmorw2
             Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint
1 Carlow        0.121997164      0.32185426 3.737816e-01  0.45871930
2 Cavan        -0.110588620     -0.20105599 5.796726e-01 -0.34808741
3 Clare         0.308759283      0.60290381 2.732863e-01  0.80379674
4 Cork          1.404203115      3.23522979 6.077244e-04  2.69598105
5 Donegal      -0.421182109     -0.42837428 6.658107e-01 -0.65187732
6 Dublin       -0.443534307     -0.88433550 8.117424e-01 -1.05167518
7 Galway        1.376190254      3.42183495 3.110003e-04  2.70663064
8 Kerry         0.241623387      0.45357724 3.250666e-01  0.61515126
9 Kildare       0.008842913      0.14324202 4.430495e-01  0.12690939
10 Kilkenny     0.382893124      0.93980330 1.736592e-01  1.12810394
11 Laoghis     -0.019904450     -0.00246494 5.009834e-01 -0.04176108
12 Leitrim      0.200483743      0.60688769 2.719627e-01  0.80241456
13 Limerick     0.238810092      0.62310059 2.666092e-01  0.81824678
14 Longford     0.466942853      0.96178354 1.680792e-01  1.14088225
15 Louth        0.271710988      0.41271732 3.399069e-01  0.58520655
16 Mayo         1.705850161      3.60778634 1.544103e-04  2.97346461
17 Meath       -0.160603054     -0.41587901 6.612507e-01 -0.63254531
18 Monaghan     0.181378604      0.35629110 3.608113e-01  0.50697175
19 Offaly       0.107919508      0.35116431 3.627325e-01  0.49312417
20 Roscommon    1.249826037      3.75170355 8.781854e-05  2.81402777
21 Sligo        0.079431883      0.27999953 3.897389e-01  0.33741411
22 Tipperary    0.085153638      0.38940098 3.484898e-01  0.51126046
23 Waterford    1.022922345      2.28982205 1.101582e-02  2.06385578
24 Westmeath    0.201539331      0.48899468 3.124227e-01  0.67791734
25 Wexford      0.481114325      1.03805702 1.496218e-01  1.21094348
26 Wicklow     -0.011694661      0.08710223 4.652951e-01  0.03786608
               Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum
1 Carlow     0.323217876 -0.01840558 0.19029731 -0.1986977 6.709176  -5.665283
2 Cavan      0.636112729 -0.02184465 0.19482455 -0.2329761 6.717975  -5.769371
3 Clare      0.210757187 -0.02782578 0.31166901 -0.2346279 6.718435  -7.299407
4 Cork       0.003509083 -0.07147410 0.20805228 -0.7280203 7.002789  -6.495227
5 Donegal    0.742759841 -0.07638800 0.64784767 -0.4450323 6.803659 -10.931345
6 Dublin     0.853525699 -0.11187469 0.14065367 -1.3324828 7.767845  -5.846924
7 Galway     0.003398492 -0.04407925 0.17227545 -0.4973247 6.833103  -5.688263
8 Kerry      0.269227417 -0.05644300 0.43184063 -0.4031537 6.782459  -8.859407
9 Kildare    0.449506058 -0.04145378 0.12329287 -0.5519841 6.867423  -4.857131
10 Kilkenny  0.129638014 -0.02321457 0.18672759 -0.2528322 6.723714  -5.669156
11 Laoghis   0.516655419 -0.01882531 0.19166504 -0.2024943 6.710081  -5.689691
12 Leitrim   0.211156597 -0.03314655 0.14819776 -0.4041387 6.782933  -5.190860
13 Limerick  0.206608144 -0.04800976 0.21188592 -0.4885390 6.827925  -6.298874
14 Longford  0.126959464 -0.01321709 0.24923967 -0.1247567 6.694960  -6.392250
15 Louth     0.279204420 -0.02272663 0.50895713 -0.1500895 6.699098  -9.179410
16 Mayo      0.001472292 -0.09458039 0.24904116 -0.8745463 7.144787  -7.272523
17 Meath     0.736484694 -0.02548973 0.10555100 -0.3685280 6.766525  -4.353122
18 Monaghan  0.306087322 -0.02333303 0.33012248 -0.1912612 6.707452  -7.451275
19 Offaly    0.310962427 -0.01927989 0.13120470 -0.2505068 6.723017  -4.750083
20 Roscommon 0.002446250 -0.02385522 0.11525625 -0.3302939 6.750604  -4.517676
21 Sligo     0.367902373 -0.06927688 0.28207107 -0.6087587 6.906925  -7.416881
22 Tipperary 0.304584343 -0.03719246 0.09871568 -0.5534442 6.868390  -4.347214
23 Waterford 0.019515696 -0.04027429 0.21558757 -0.4070996 6.784366  -6.264083
24 Westmeath 0.248912051 -0.01522814 0.19650786 -0.1618342 6.701275  -5.716689
25 Wexford   0.112958534 -0.02786850 0.24041626 -0.2674357 6.728234  -6.450174
26 Wicklow   0.484897230 -0.04751424 0.16911517 -0.5404006 6.859847  -5.677417
              Maximum         omega        sad.r        sad.u
1 Carlow     5.223549  0.0272472954  0.306852385  0.321490350
2 Cavan      5.245099 -0.0166242430 -0.190223798 -0.196022741
3 Clare      6.631589  0.0358559846  0.559584155  0.641527095
4 Cork       4.779848  0.1283688794  2.421993662  4.702934834
5 Donegal    9.098033 -0.0169574018 -0.388662370 -0.430528174
6 Dublin     3.161931 -0.0507848831 -0.696824139 -0.892299501
7 Galway     4.630361  0.1333224875  2.431707338  4.745166958
8 Kerry      7.504775  0.0252982005  0.433626352  0.469138111
9 Kildare    3.862240  0.0161278548  0.139072871  0.138837812
10 Kilkenny  5.112007  0.0622219791  0.835166590  1.066654825
11 Laoghis   5.237883 -0.0002164925 -0.002368023 -0.002368244
12 Leitrim   4.395343  0.0543844388  0.571625643  0.652237768
13 Limerick  5.146640  0.0473787285  0.590605630  0.675595582
14 Longford  6.075040  0.0528365356  0.840671447  1.082014178
15 Louth     8.633971  0.0204960239  0.389078238  0.419930705
16 Mayo      5.002594  0.1340509166  2.712635049  5.503894365
17 Meath     3.741368 -0.0415411327 -0.379736494 -0.417998694
18 Monaghan  6.891283  0.0226076552  0.338579266  0.358443998
19 Offaly    4.287365  0.0357600182  0.335019324  0.353243066
20 Roscommon 3.945151  0.1623235556  2.543240406  5.063795948
21 Sligo     5.754236  0.0209568244  0.273376649  0.278204612
22 Tipperary 3.454595  0.0478130890  0.377982061  0.397511387
23 Waterford 5.297500  0.0941811771  1.762051071  2.998984773
24 Westmeath 5.351214  0.0379323563  0.457473561  0.506014991
25 Wexford   5.781330  0.0582538352  0.911459483  1.197527949
26 Wicklow   4.537075  0.0083101099  0.084281843  0.083952776
> e.errorsar <- errorsarlm(OWNCONS ~ ROADACC, data=eire,
+   listw=nb2listw(eire.nb))
> e.errorsar

Call:
errorsarlm(formula = OWNCONS ~ ROADACC, data = eire, listw = nb2listw(eire.nb))
Type: error 

Coefficients:
     lambda (Intercept)     ROADACC 
0.783970989 2.892719571 0.002800913 

Log likelihood: -64.12465 
> lm.target <- lm(e.errorsar$tary ~ e.errorsar$tarX - 1)
> e.clocmor <- summary(localmoran.sad(lm.target, nb=eire.nb))
> e.clocmor
             Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint
1 Carlow         0.17958462      0.56174229 0.2871458075  0.74311184
2 Cavan         -0.24752628     -0.54457549 0.7069772411 -0.76634552
3 Clare         -0.27901334     -0.43264864 0.6673649767 -0.64997174
4 Cork           0.37808655      0.89537162 0.1852942343  1.09629836
5 Donegal       -1.01894688     -1.41532264 0.9215130399 -1.47672572
6 Dublin        -0.18171297     -0.22284440 0.5881716957 -0.41975782
7 Galway         1.02193390      2.60812242 0.0045520194  2.25118872
8 Kerry         -0.94967914     -1.39524786 0.9185294457 -1.43836641
9 Kildare        0.07005053      0.36203417 0.3586632484  0.44291406
10 Kilkenny      0.43022231      1.17948522 0.1191025086  1.34852957
11 Laoghis      -0.12239133     -0.17323034 0.5687648117 -0.36469163
12 Leitrim      -0.24203970     -0.56771064 0.7148842674 -0.78867247
13 Limerick     -0.03214546      0.01233947 0.4950773904 -0.05175538
14 Longford      0.38307454      0.92458240 0.1775915865  1.12546245
15 Louth         0.21301552      0.37117047 0.3552552838  0.51573768
16 Mayo          0.93971200      2.03036593 0.0211596788  1.91345045
17 Meath         0.12484415      0.52386764 0.3001853022  0.68855942
18 Monaghan     -0.16109919     -0.21508273 0.5851485906 -0.38437351
19 Offaly       -0.00632492      0.11490854 0.4542588089  0.06560121
20 Roscommon     1.02089429      3.23166765 0.0006153505  2.61965541
21 Sligo        -2.01629233     -3.62770962 0.9998570267 -2.51961018
22 Tipperary    -0.10810709     -0.20863416 0.5826330798 -0.42729531
23 Waterford     0.44099279      1.04893077 0.1471049904  1.23465693
24 Westmeath    -0.06329661     -0.04366127 0.5174127933 -0.16534708
25 Wexford       0.30764883      0.74971555 0.2267130201  0.95567980
26 Wicklow      -0.01696406      0.06575479 0.4737865263  0.01467158
               Pr. (Sad) Expectation   Variance   Skewness Kurtosis   Minimum
1 Carlow     0.228706986 -0.04641263 0.16185720 -0.5395900 6.859323 -5.553488
2 Cavan      0.778264630 -0.02990887 0.15968757 -0.3516764 6.759292 -5.338182
3 Clare      0.742144763 -0.04143709 0.30153335 -0.3545492 6.760501 -7.339215
4 Cork       0.136474113 -0.04269357 0.22085324 -0.4261941 6.793861 -6.361468
5 Donegal    0.930125412  0.01915741 0.53798611  0.1230814 6.694714 -8.928571
6 Dublin     0.662668811 -0.06203664 0.28841181 -0.5402894 6.859775 -7.414090
7 Galway     0.012186793 -0.03782741 0.16510498 -0.4366334 6.799237 -5.510360
8 Kerry      0.924834941 -0.01871710 0.44520622 -0.1321820 6.696094 -8.555627
9 Kildare    0.328913950 -0.05796732 0.12503796 -0.7605716 7.032012 -5.061656
10 Kilkenny  0.088744058 -0.04722085 0.16385449 -0.5455330 6.863184 -5.593276
11 Laoghis   0.642329195 -0.05277064 0.16152087 -0.6127109 6.909821 -5.616186
12 Leitrim   0.784848269 -0.02748254 0.14283411 -0.3417436 6.755188 -5.039612
13 Limerick  0.520638197 -0.03789818 0.21734670 -0.3817349 6.772433 -6.261369
14 Longford  0.130196561 -0.04758318 0.21695678 -0.4786318 6.822198 -6.362923
15 Louth     0.303018817 -0.04296993 0.47564588 -0.2930511 6.736780 -9.115467
16 Mayo      0.027845206 -0.04338607 0.23444720 -0.4204191 6.790943 -6.547680
17 Meath     0.245550282 -0.04467397 0.10471023 -0.6435267 6.933063 -4.544997
18 Monaghan  0.649649185 -0.04163075 0.30852854 -0.3521611 6.759495 -7.420673
19 Offaly    0.473847663 -0.04232019 0.09812651 -0.6300431 6.922750 -4.390023
20 Roscommon 0.004400933 -0.03739910 0.10724049 -0.5342497 6.855890 -4.516330
21 Sligo     0.994125757 -0.06026877 0.29072550 -0.5230640 6.848812 -7.422010
22 Tipperary 0.665417875 -0.04674977 0.08648921 -0.7382332 7.011816 -4.194704
23 Waterford 0.108479106 -0.04756842 0.21694233 -0.4785010 6.822123 -6.362567
24 Westmeath 0.565664597 -0.04555720 0.16507661 -0.5246842 6.849828 -5.594259
25 Wexford   0.169617016 -0.04133723 0.21668215 -0.4166978 6.789084 -6.290601
26 Wicklow   0.494147095 -0.04702822 0.20904683 -0.4818751 6.824059 -6.249351
              Maximum        omega       sad.r       sad.u
1 Carlow     4.439585  0.050743822  0.53824871  0.60099586
2 Cavan      4.620369 -0.041432192 -0.48750887 -0.55849397
3 Clare      6.344725 -0.025400357 -0.39431837 -0.43614182
4 Cork       5.336823  0.058250958  0.81595694  1.02567695
5 Donegal    9.388349 -0.043987520 -1.16123609 -1.67504993
6 Dublin     5.925211 -0.014558099 -0.20806672 -0.21743602
7 Galway     4.602502  0.115590766  1.95635481  3.48296066
8 Kerry      8.106417 -0.045101427 -1.11656929 -1.59930575
9 Kildare    3.670440  0.041451789  0.35687414  0.36800208
10 Kilkenny  4.459975  0.081961941  1.05146785  1.43697181
11 Laoghis   4.349690 -0.015403709 -0.16261464 -0.16804704
12 Leitrim   4.380031 -0.045194092 -0.50663277 -0.58445336
13 Limerick  5.351813  0.001020469  0.01186507  0.01185612
14 Longford  5.220926  0.060826054  0.84453478  1.07066915
15 Louth     8.084188  0.019866036  0.35447505  0.37532846
16 Mayo      5.506414  0.085770551  1.60763075  2.62848243
17 Meath     3.472822  0.061249624  0.50837359  0.55714098
18 Monaghan  6.421535 -0.013889650 -0.20234436 -0.20993617
19 Offaly    3.374338  0.014533693  0.11158977  0.11101857
20 Roscommon 3.618752  0.165774850  2.34104363  4.49443134
21 Sligo     5.975559 -0.079042159 -2.23065790 -4.24970790
22 Tipperary 3.072710 -0.024616720 -0.19398400 -0.20296517
23 Waterford 5.220925  0.065452562  0.94280206  1.24142814
24 Westmeath 4.500886 -0.004077335 -0.04176313 -0.04197924
25 Wexford   5.298507  0.052375394  0.69527510  0.83327231
26 Wicklow   5.120674  0.005608952  0.06348624  0.06328980
> hist(e.clocmor[,"Pr. (Sad)"])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("localmoran.sad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("mat2listw")
> ### * mat2listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mat2listw
> ### Title: Convert a square spatial weights matrix to a weights list object
> ### Aliases: mat2listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col005 <- dnearneigh(coords, 0, 0.5, attr(col.gal.nb, "region.id"))
> summary(col005)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 170 
Percentage nonzero weights: 7.080383 
Average number of links: 3.469388 
4 regions with no links:
1 3 6 21
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
 4 11  5  8  3  9  2  2  3  2 
11 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 with 1 link
2 most connected regions:
11 16 with 9 links
> col005.w.mat <- nb2mat(col005, zero.policy=TRUE)
> col005.w.b <- mat2listw(col005.w.mat)
> summary(col005.w.b$neighbours)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 170 
Percentage nonzero weights: 7.080383 
Average number of links: 3.469388 
4 regions with no links:
1 3 6 21
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
 4 11  5  8  3  9  2  2  3  2 
11 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 with 1 link
2 most connected regions:
11 16 with 9 links
> diffnb(col005, col005.w.b$neighbours)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
> col005.w.mat.3T <- kronecker(diag(3), col005.w.mat)
> col005.w.b.3T <- mat2listw(col005.w.mat.3T, style="W")
Warning in nb2listw(res$neighbours, glist = res$weights, style = style,  :
  zero sum general weights
> summary(col005.w.b.3T$neighbours)
Neighbour list object:
Number of regions: 147 
Number of nonzero links: 510 
Percentage nonzero weights: 2.360128 
Average number of links: 3.469388 
12 regions with no links:
1 3 6 21 50 52 55 70 99 101 104 119
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
12 33 15 24  9 27  6  6  9  6 
33 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 51 54 58 59 80 83 85 88 91 95 96 100 103 107 108 129 132 134 137 140 144 145 with 1 link
6 most connected regions:
11 16 60 65 109 114 with 9 links
> W <- as(nb2listw(col005, style="W", zero.policy=TRUE), "CsparseMatrix")
> col005.spM <- mat2listw(W)
Warning in sn2listw(df) : 1, 3, 6, 21 are not origins
> summary(col005.spM$neighbours)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 170 
Percentage nonzero weights: 7.080383 
Average number of links: 3.469388 
4 regions with no links:
1 3 6 21
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
 4 11  5  8  3  9  2  2  3  2 
11 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 with 1 link
2 most connected regions:
11 16 with 9 links
> diffnb(col005, col005.spM$neighbours)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
> IW <- kronecker(Diagonal(3), W)
Note: method with signature ‘diagonalMatrix#Matrix’ chosen for function ‘kronecker’,
 target signature ‘ddiMatrix#dgCMatrix’.
 "ANY#sparseMatrix" would also be valid
Note: method with signature ‘dsparseMatrix#dsparseMatrix’ chosen for function ‘kronecker’,
 target signature ‘dtTMatrix#dgCMatrix’.
 "TsparseMatrix#sparseMatrix" would also be valid
> col005.spM.3T <- mat2listw(IW, style="W")
Warning in sn2listw(df) :
  1, 3, 6, 21, 50, 52, 55, 70, 99, 101, 104, 119 are not origins
Warning in nb2listw(res$neighbours, glist = res$weights, style = style,  :
  zero sum general weights
> summary(col005.spM.3T$neighbours)
Neighbour list object:
Number of regions: 147 
Number of nonzero links: 510 
Percentage nonzero weights: 2.360128 
Average number of links: 3.469388 
12 regions with no links:
1 3 6 21 50 52 55 70 99 101 104 119
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
12 33 15 24  9 27  6  6  9  6 
33 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 51 54 58 59 80 83 85 88 91 95 96 100 103 107 108 129 132 134 137 140 144 145 with 1 link
6 most connected regions:
11 16 60 65 109 114 with 9 links
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mat2listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("moran")
> ### * moran
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran
> ### Title: Compute Moran's I
> ### Aliases: moran
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> col.W <- nb2listw(COL.nb, style="W")
> crime <- COL.OLD$CRIME
> str(moran(crime, col.W, length(COL.nb), Szero(col.W)))
List of 2
 $ I: num 0.511
 $ K: num 2.23
> is.na(crime) <- sample(1:length(crime), 10)
> str(moran(crime, col.W, length(COL.nb), Szero(col.W), NAOK=TRUE))
Warning in lag.listw(listw, z, zero.policy = zero.policy, NAOK = NAOK) :
  NAs in lagged values
List of 2
 $ I: num 0.349
 $ K: num 2.65
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("moran.mc")
> ### * moran.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran.mc
> ### Title: Permutation test for Moran's I statistic
> ### Aliases: moran.mc
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> colw <- nb2listw(COL.nb, style="W")
> nsim <- 99
> set.seed(1234)
> sim1 <- moran.mc(COL.OLD$CRIME, listw=colw, nsim=nsim)
> sim1

	Monte-Carlo simulation of Moran's I

data:  COL.OLD$CRIME 
weights: colw  
number of simulations + 1: 100 

statistic = 0.51095, observed rank = 100, p-value = 0.01
alternative hypothesis: greater

> mean(sim1$res[1:nsim])
[1] -0.01735822
> var(sim1$res[1:nsim])
[1] 0.008938155
> summary(sim1$res[1:nsim])
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
-0.238200 -0.083270 -0.007406 -0.017360  0.039720  0.259400 
> colold.lags <- nblag(COL.nb, 3)
> set.seed(1234)
> sim2 <- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
+  style="W"), nsim=nsim)
> summary(sim2$res[1:nsim])
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-0.18440 -0.06090 -0.01837 -0.01522  0.02860  0.23550 
> sim3 <- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
+  style="W"), nsim=nsim)
> summary(sim3$res[1:nsim])
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-0.16810 -0.06701 -0.02035 -0.01733  0.02200  0.14340 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("moran.plot")
> ### * moran.plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran.plot
> ### Title: Moran scatterplot
> ### Aliases: moran.plot
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(afcon)
> moran.plot(afcon$totcon, nb2listw(paper.nb),
+  labels=as.character(afcon$name), pch=19)
> moran.plot(as.vector(scale(afcon$totcon)), nb2listw(paper.nb),
+  labels=as.character(afcon$name), xlim=c(-2, 4), ylim=c(-2,4), pch=19)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran.plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("moran.test")
> ### * moran.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran.test
> ### Title: Moran's I test for spatial autocorrelation
> ### Aliases: moran.test
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y)
> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "W")  

Moran I statistic standard deviate = 5.6341, p-value = 8.797e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.510951264      -0.020833333       0.008908762 

> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="B"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "B")  

Moran I statistic standard deviate = 6.2116, p-value = 2.622e-10
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.52063815       -0.02083333        0.00759872 

> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="C"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "C")  

Moran I statistic standard deviate = 6.2116, p-value = 2.622e-10
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.52063815       -0.02083333        0.00759872 

> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="S"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "S")  

Moran I statistic standard deviate = 5.9786, p-value = 1.125e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.512957470      -0.020833333       0.007971504 

> moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
+  randomisation=FALSE)

	Moran's I test under normality

data:  COL.OLD$CRIME  
weights: nb2listw(COL.nb, style = "W")  

Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.510951264      -0.020833333       0.008779831 

> colold.lags <- nblag(COL.nb, 3)
> moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
+  style="W"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(colold.lags[[2]], style = "W")  

Moran I statistic standard deviate = 2.6076, p-value = 0.004559
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.168485742      -0.020833333       0.005271314 

> moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
+  style="W"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(colold.lags[[3]], style = "W")  

Moran I statistic standard deviate = -1.7896, p-value = 0.9632
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
     -0.138930745      -0.020833333       0.004354683 

> print(is.symmetric.nb(COL.nb))
[1] TRUE
> COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4))
> print(is.symmetric.nb(COL.k4.nb))
[1] FALSE
> moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: nb2listw(COL.k4.nb, style = "W")  

Moran I statistic standard deviate = 7.2183, p-value = 2.632e-13
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.624933667      -0.020833333       0.008003503 

> moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"),
+  randomisation=FALSE)

	Moran's I test under normality

data:  COL.OLD$CRIME  
weights: nb2listw(COL.k4.nb, style = "W")  

Moran I statistic standard deviate = 7.2711, p-value = 1.782e-13
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.624933667      -0.020833333       0.007887613 

> cat("Note: non-symmetric weights matrix, use listw2U()")
Note: non-symmetric weights matrix, use listw2U()> moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
+  style="W")))

	Moran's I test under randomisation

data:  COL.OLD$CRIME  
weights: listw2U(nb2listw(COL.k4.nb, style = "W"))  

Moran I statistic standard deviate = 7.2183, p-value = 2.632e-13
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.624933667      -0.020833333       0.008003503 

> moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
+  style="W")), randomisation=FALSE)

	Moran's I test under normality

data:  COL.OLD$CRIME  
weights: listw2U(nb2listw(COL.k4.nb, style = "W"))  

Moran I statistic standard deviate = 7.2711, p-value = 1.782e-13
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.624933667      -0.020833333       0.007887613 

> ranks <- rank(COL.OLD$CRIME)
> names(ranks) <- rownames(COL.OLD)
> moran.test(ranks, nb2listw(COL.nb, style="W"), rank=TRUE)

	Moran's I test under randomisation

data:  ranks using rank correction 
weights: nb2listw(COL.nb, style = "W")  

Moran I statistic standard deviate = 6.3815, p-value = 8.766e-11
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.584333495      -0.020833333       0.008992923 

> crime <- COL.OLD$CRIME
> is.na(crime) <- sample(1:length(crime), 10)
> res <- try(moran.test(crime, nb2listw(COL.nb, style="W"),
+  na.action=na.fail))
Error in na.fail.default(x) : missing values in object
> res
[1] "Error in na.fail.default(x) : missing values in object\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in na.fail.default(x): missing values in object>
> moran.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
+  na.action=na.omit)

	Moran's I test under randomisation

data:  crime  
weights: nb2listw(COL.nb, style = "W") 
omitted: 3, 10, 14, 18, 26, 27, 28, 40, 41, 42 

Moran I statistic standard deviate = 4.3361, p-value = 7.252e-06
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.48158092       -0.02631579        0.01372000 

> moran.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
+  na.action=na.exclude)

	Moran's I test under randomisation

data:  crime  
weights: nb2listw(COL.nb, style = "W") 
omitted: 3, 10, 14, 18, 26, 27, 28, 40, 41, 42 

Moran I statistic standard deviate = 4.3361, p-value = 7.252e-06
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
       0.48158092       -0.02631579        0.01372000 

> moran.test(crime, nb2listw(COL.nb, style="W"), na.action=na.pass)
Warning in lag.listw(listw, z, zero.policy = zero.policy, NAOK = NAOK) :
  NAs in lagged values

	Moran's I test under randomisation

data:  crime  
weights: nb2listw(COL.nb, style = "W")  

Moran I statistic standard deviate = 3.9351, p-value = 4.158e-05
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.348817433      -0.020833333       0.008824189 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mstree")
> ### * mstree
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mstree
> ### Title: Find the minimal spanning tree
> ### Aliases: mstree
> ### Keywords: graphs spatial
> 
> ### ** Examples
> 
> ### loading data
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> bh <- readShapePoly(system.file("etc/shapes/bhicv.shp",
+       package="spdep")[1])
> ### data padronized
> dpad <- data.frame(scale(bh@data[,5:8]))
> 
> ### neighboorhod list 
> bh.nb <- poly2nb(bh)
> 
> ### calculing costs
> lcosts <- nbcosts(bh.nb, dpad)
> 
> ### making listw
> nb.w <- nb2listw(bh.nb, lcosts, style="B")
> 
> ### find a minimum spanning tree
> system.time(mst.bh <- mstree(nb.w,5))
   user  system elapsed 
  0.003   0.000   0.003 
> 
> dim(mst.bh)
[1] 97  3
> 
> head(mst.bh)
     [,1] [,2]      [,3]
[1,]    5   12 1.2951120
[2,]   12   13 0.6141101
[3,]   13   11 0.7913745
[4,]   13    6 0.9775650
[5,]   11   31 0.9965625
[6,]   31   39 0.6915158
> tail(mst.bh)
      [,1] [,2]      [,3]
[92,]   89   90 2.5743702
[93,]   26   56 2.6235317
[94,]   86   87 2.6471303
[95,]   87   72 0.7874461
[96,]   49   36 2.8743677
[97,]   24   25 3.4675168
> 
> ### the mstree plot
> par(mar=c(0,0,0,0))
> plot(mst.bh, coordinates(bh), col=2, 
+      cex.lab=.7, cex.circles=0.035, fg="blue")
> plot(bh, border=gray(.5), add=TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mstree", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:maptools’

> nameEx("nb2INLA")
> ### * nb2INLA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2INLA
> ### Title: Output spatial neighbours for INLA
> ### Aliases: nb2INLA
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> td <- tempdir()
> x <- nb2INLA(paste(td, "columbus-INLA.adj", sep="/"), col.gal.nb)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2INLA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nb2WB")
> ### * nb2WB
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2WB
> ### Title: Output spatial weights for WinBUGS
> ### Aliases: nb2WB listw2WB
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> x <- nb2WB(col.gal.nb)
> dput(x, control=NULL)
list(adj = c(2, 3, 1, 3, 4, 1, 2, 4, 5, 2, 3, 5, 8, 3, 4, 6, 
8, 9, 11, 15, 5, 9, 8, 12, 13, 14, 4, 5, 7, 11, 12, 13, 5, 6, 
10, 15, 20, 22, 25, 26, 9, 17, 20, 22, 5, 8, 12, 15, 16, 7, 8, 
11, 13, 14, 16, 7, 8, 12, 14, 7, 12, 13, 16, 18, 19, 5, 9, 11, 
16, 25, 26, 11, 12, 14, 15, 18, 24, 25, 10, 20, 23, 14, 16, 19, 
24, 14, 18, 24, 9, 10, 17, 22, 23, 27, 32, 33, 35, 40, 24, 30, 
34, 9, 10, 20, 26, 27, 28, 17, 20, 32, 16, 18, 19, 21, 25, 29, 
30, 9, 15, 16, 24, 26, 28, 29, 9, 15, 22, 25, 28, 29, 20, 22, 
28, 33, 22, 25, 26, 27, 29, 33, 35, 37, 38, 24, 25, 26, 28, 30, 
37, 38, 21, 24, 29, 37, 34, 36, 20, 23, 40, 41, 20, 27, 28, 35, 
21, 31, 36, 42, 20, 28, 33, 38, 40, 43, 44, 31, 34, 39, 42, 46, 
28, 29, 30, 38, 43, 45, 28, 29, 35, 37, 43, 44, 36, 46, 20, 32, 
35, 41, 47, 32, 40, 47, 34, 36, 35, 37, 38, 44, 45, 48, 35, 38, 
43, 48, 49, 37, 43, 48, 49, 36, 39, 40, 41, 43, 44, 45, 49, 44, 
45, 48), weights = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1), num = c(2, 3, 4, 4, 7, 2, 4, 6, 8, 4, 5, 6, 
4, 6, 6, 7, 3, 4, 3, 10, 3, 6, 3, 7, 7, 6, 4, 9, 7, 4, 2, 4, 
4, 4, 7, 5, 6, 6, 2, 5, 3, 2, 6, 5, 4, 2, 2, 4, 3))
> x <- listw2WB(nb2listw(col.gal.nb))
> dput(x, control=NULL)
list(adj = c(2, 3, 1, 3, 4, 1, 2, 4, 5, 2, 3, 5, 8, 3, 4, 6, 
8, 9, 11, 15, 5, 9, 8, 12, 13, 14, 4, 5, 7, 11, 12, 13, 5, 6, 
10, 15, 20, 22, 25, 26, 9, 17, 20, 22, 5, 8, 12, 15, 16, 7, 8, 
11, 13, 14, 16, 7, 8, 12, 14, 7, 12, 13, 16, 18, 19, 5, 9, 11, 
16, 25, 26, 11, 12, 14, 15, 18, 24, 25, 10, 20, 23, 14, 16, 19, 
24, 14, 18, 24, 9, 10, 17, 22, 23, 27, 32, 33, 35, 40, 24, 30, 
34, 9, 10, 20, 26, 27, 28, 17, 20, 32, 16, 18, 19, 21, 25, 29, 
30, 9, 15, 16, 24, 26, 28, 29, 9, 15, 22, 25, 28, 29, 20, 22, 
28, 33, 22, 25, 26, 27, 29, 33, 35, 37, 38, 24, 25, 26, 28, 30, 
37, 38, 21, 24, 29, 37, 34, 36, 20, 23, 40, 41, 20, 27, 28, 35, 
21, 31, 36, 42, 20, 28, 33, 38, 40, 43, 44, 31, 34, 39, 42, 46, 
28, 29, 30, 38, 43, 45, 28, 29, 35, 37, 43, 44, 36, 46, 20, 32, 
35, 41, 47, 32, 40, 47, 34, 36, 35, 37, 38, 44, 45, 48, 35, 38, 
43, 48, 49, 37, 43, 48, 49, 36, 39, 40, 41, 43, 44, 45, 49, 44, 
45, 48), weights = c(0.5, 0.5, 0.333333333333333, 0.333333333333333, 
0.333333333333333, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 
0.25, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.25, 
0.25, 0.25, 0.25, 0.2, 0.2, 0.2, 0.2, 0.2, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.25, 0.25, 0.25, 0.25, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.333333333333333, 0.333333333333333, 
0.333333333333333, 0.25, 0.25, 0.25, 0.25, 0.333333333333333, 
0.333333333333333, 0.333333333333333, 0.1, 0.1, 0.1, 0.1, 0.1, 
0.1, 0.1, 0.1, 0.1, 0.1, 0.333333333333333, 0.333333333333333, 
0.333333333333333, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.333333333333333, 
0.333333333333333, 0.333333333333333, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.25, 0.25, 0.25, 0.25, 
0.111111111111111, 0.111111111111111, 0.111111111111111, 0.111111111111111, 
0.111111111111111, 0.111111111111111, 0.111111111111111, 0.111111111111111, 
0.111111111111111, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 
0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143, 
0.142857142857143, 0.142857142857143, 0.2, 0.2, 0.2, 0.2, 0.2, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.5, 0.5, 0.2, 0.2, 0.2, 0.2, 0.2, 0.333333333333333, 0.333333333333333, 
0.333333333333333, 0.5, 0.5, 0.166666666666667, 0.166666666666667, 
0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667, 
0.2, 0.2, 0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5, 
0.5, 0.25, 0.25, 0.25, 0.25, 0.333333333333333, 0.333333333333333, 
0.333333333333333), num = c(2, 3, 4, 4, 7, 2, 4, 6, 8, 4, 5, 
6, 4, 6, 6, 7, 3, 4, 3, 10, 3, 6, 3, 7, 7, 6, 4, 9, 7, 4, 2, 
4, 4, 4, 7, 5, 6, 6, 2, 5, 3, 2, 6, 5, 4, 2, 2, 4, 3))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2WB", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nb2blocknb")
> ### * nb2blocknb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2blocknb
> ### Title: Block up neighbour list for location-less observations
> ### Aliases: nb2blocknb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(boston)
> ##D summary(as.vector(table(boston.c$TOWN)))
> ##D townaggr <- aggregate(boston.utm, list(town=boston.c$TOWN), mean)
> ##D block.rel <- graph2nb(relativeneigh(as.matrix(townaggr[,2:3])),
> ##D  as.character(townaggr[,1]), sym=TRUE)
> ##D block.rel
> ##D print(is.symmetric.nb(block.rel))
> ##D plot(block.rel, as.matrix(townaggr[,2:3]))
> ##D points(boston.utm, pch=18, col="lightgreen")
> ##D block.nb <- nb2blocknb(block.rel, as.character(boston.c$TOWN))
> ##D block.nb
> ##D print(is.symmetric.nb(block.nb))
> ##D plot(block.nb, boston.utm)
> ##D points(boston.utm, pch=18, col="lightgreen")
> ##D n.comp.nb(block.nb)$nc
> ##D moran.test(boston.c$CMEDV, nb2listw(boston.soi))
> ##D moran.test(boston.c$CMEDV, nb2listw(block.nb))
> ##D block.nb <- nb2blocknb(NULL, as.character(boston.c$TOWN))
> ##D block.nb
> ##D print(is.symmetric.nb(block.nb))
> ##D plot(block.nb, boston.utm)
> ##D n.comp.nb(block.nb)$nc
> ##D moran.test(boston.c$CMEDV, nb2listw(block.nb, zero.policy=TRUE), zero.policy=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2blocknb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nb2lines")
> ### * nb2lines
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2lines
> ### Title: Use arc-type shapefiles for import and export of weights
> ### Aliases: nb2lines listw2lines df2sn
> ### Keywords: spatial
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> example(columbus)

colmbs> require(maptools)

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> res <- listw2lines(nb2listw(col.gal.nb), coords)
> summary(res)
Object of class SpatialLinesDataFrame
Coordinates:
        min      max
x  6.221943 10.95359
y 11.010031 14.36908
Is projected: NA 
proj4string : [NA]
Data attributes:
       i               j             i_ID               j_ID          
 Min.   : 1.00   Min.   : 1.00   Length:230         Length:230        
 1st Qu.:13.00   1st Qu.:13.00   Class :AsIs        Class :AsIs       
 Median :24.00   Median :24.00   Mode  :character   Mode  :character  
 Mean   :24.19   Mean   :24.19                                        
 3rd Qu.:35.00   3rd Qu.:35.00                                        
 Max.   :49.00   Max.   :49.00                                        
       wt        
 Min.   :0.1000  
 1st Qu.:0.1429  
 Median :0.1667  
 Mean   :0.2130  
 3rd Qu.:0.2500  
 Max.   :0.5000  
> fn <- paste(tempdir(), "nbshape", sep="/")
> writeLinesShape(res, fn=fn)
> inMap <- readShapeLines(fn)
> summary(inMap)
Object of class SpatialLinesDataFrame
Coordinates:
        min      max
x  6.221943 10.95359
y 11.010031 14.36908
Is projected: NA 
proj4string : [NA]
Data attributes:
     SL_ID           i               j              i_ID          j_ID    
 1      :  1   Min.   : 1.00   Min.   : 1.00   20     : 10   20     : 10  
 10     :  1   1st Qu.:13.00   1st Qu.:13.00   28     :  9   28     :  9  
 100    :  1   Median :24.00   Median :24.00   9      :  8   9      :  8  
 101    :  1   Mean   :24.19   Mean   :24.19   16     :  7   16     :  7  
 102    :  1   3rd Qu.:35.00   3rd Qu.:35.00   24     :  7   24     :  7  
 103    :  1   Max.   :49.00   Max.   :49.00   25     :  7   25     :  7  
 (Other):224                                   (Other):182   (Other):182  
       wt        
 Min.   :0.1000  
 1st Qu.:0.1429  
 Median :0.1667  
 Mean   :0.2130  
 3rd Qu.:0.2500  
 Max.   :0.5000  
                 
> diffnb(sn2listw(df2sn(as(inMap, "data.frame")))$neighbours, col.gal.nb)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2lines", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nb2listw")
> ### * nb2listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2listw
> ### Title: Spatial weights for neighbours lists
> ### Aliases: nb2listw can.be.simmed
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> cards <- card(col.gal.nb)
> col.w <- nb2listw(col.gal.nb)
> plot(cards, unlist(lapply(col.w$weights, sum)),xlim=c(0,10),
+ ylim=c(0,10), xlab="number of links", ylab="row sums of weights")
> col.b <- nb2listw(col.gal.nb, style="B")
> points(cards, unlist(lapply(col.b$weights, sum)), col="red")
> col.c <- nb2listw(col.gal.nb, style="C")
> points(cards, unlist(lapply(col.c$weights, sum)), col="green")
> col.u <- nb2listw(col.gal.nb, style="U")
> points(cards, unlist(lapply(col.u$weights, sum)), col="orange")
> col.s <- nb2listw(col.gal.nb, style="S")
> points(cards, unlist(lapply(col.s$weights, sum)), col="blue")
> legend(x=c(0, 1), y=c(7, 9), legend=c("W", "B", "C", "U", "S"),
+ col=c("black", "red", "green", "orange", "blue"), pch=rep(1,5))
> summary(nb2listw(col.gal.nb, style="minmax"))
Characteristics of weights list object:
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Link number distribution:

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 2 links
1 most connected region:
20 with 10 links

Weights style: minmax 
Weights constants summary:
        n   nn S0  S1    S2
minmax 49 2401 23 4.6 50.48
> dlist <- nbdists(col.gal.nb, coords)
> dlist <- lapply(dlist, function(x) 1/x)
> col.w.d <- nb2listw(col.gal.nb, glist=dlist)
> summary(unlist(col.w$weights))
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1000  0.1429  0.1667  0.2130  0.2500  0.5000 
> summary(unlist(col.w.d$weights))
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.06977 0.13110 0.17710 0.21300 0.27120 0.67180 
> # introducing other conditions into weights - only earlier sales count
> # see http://sal.uiuc.edu/pipermail/openspace/2005-October/000610.html
> data(baltimore)
> set.seed(211)
> dates <- sample(1:500, nrow(baltimore), replace=TRUE)
> nb_15nn <- knn2nb(knearneigh(cbind(baltimore$X, baltimore$Y), k=15))
> glist <- vector(mode="list", length=length(nb_15nn))
> for (i in seq(along=nb_15nn))
+   glist[[i]] <- ifelse(dates[i] > dates[nb_15nn[[i]]], 1, 0)
> listw_15nn_dates <- nb2listw(nb_15nn, glist=glist, style="B")
Warning in nb2listw(nb_15nn, glist = glist, style = "B") :
  zero sum general weights
> which(lag(listw_15nn_dates, baltimore$PRICE) == 0.0)
 [1]  39  40  48  92 112 117 118 143 160 176 177 185 191 198
> which(sapply(glist, sum) == 0)
 [1]  39  40  48  92 112 117 118 143 160 176 177 185 191 198
> ex <- which(sapply(glist, sum) == 0)[1]
> dates[ex]
[1] 13
> dates[nb_15nn[[ex]]]
 [1] 266  44 168 434 222  38 432 399 172 213 430  29 312 237  55
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nb2mat")
> ### * nb2mat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb2mat
> ### Title: Spatial weights matrices for neighbours lists
> ### Aliases: nb2mat listw2mat
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col005 <- dnearneigh(coords, 0, 0.5, attr(col.gal.nb, "region.id"))
> summary(col005)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 170 
Percentage nonzero weights: 7.080383 
Average number of links: 3.469388 
4 regions with no links:
1 3 6 21
Link number distribution:

 0  1  2  3  4  5  6  7  8  9 
 4 11  5  8  3  9  2  2  3  2 
11 least connected regions:
2 5 9 10 31 34 36 39 42 46 47 with 1 link
2 most connected regions:
11 16 with 9 links
> col005.w.mat <- nb2mat(col005, zero.policy=TRUE)
> table(round(apply(col005.w.mat, 1, sum)))

 0  1 
 4 45 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nb2mat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nbdists")
> ### * nbdists
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nbdists
> ### Title: Spatial link distance measures
> ### Aliases: nbdists
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> dlist <- nbdists(col.gal.nb, coords)
> dlist <- lapply(dlist, function(x) 1/x)
> stem(unlist(dlist))

  The decimal point is at the |

  1 | 1111112222223333334444444444
  1 | 555555556666667777777777888888888899999999999999999999
  2 | 00000000111111111111111122222222222222333333333333334444
  2 | 55555555556666666666666677777777888888999999
  3 | 0000111111222233334444
  3 | 77779999
  4 | 223344
  4 | 77
  5 | 001144
  5 | 
  6 | 
  6 | 99
  7 | 
  7 | 88

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nbdists", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("nblag")
> ### * nblag
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nblag
> ### Title: Higher order neighbours lists
> ### Aliases: nblag nblag_cumul
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> summary(col.gal.nb, coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Link number distribution:

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 2 links
1 most connected region:
20 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1276  0.3613  0.4566  0.4694  0.5536  0.8924 

  The decimal point is 1 digit(s) to the left of the |

  1 | 3344
  1 | 99
  2 | 000011333344
  2 | 556677779999
  3 | 000011222222223344444444
  3 | 556666777777888888889999999999
  4 | 00001111112233333333334444
  4 | 55666666666666777777777788888899
  5 | 0011112222222222222233334444
  5 | 556666667788
  6 | 000000112244
  6 | 5577889999
  7 | 11112244
  7 | 557777
  8 | 1144
  8 | 55999999

> plot(columbus, border="grey")
> plot(col.gal.nb, coords, add=TRUE)
> title(main="GAL order 1 (black) and 2 (red) links")
> col.lags <- nblag(col.gal.nb, 2)
> lapply(col.lags, print)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 406 
Percentage nonzero weights: 16.90962 
Average number of links: 8.285714 
[[1]]
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 

[[2]]
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 406 
Percentage nonzero weights: 16.90962 
Average number of links: 8.285714 

> summary(col.lags[[2]], coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 406 
Percentage nonzero weights: 16.90962 
Average number of links: 8.285714 
Link number distribution:

 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 
 1  2  5  4  2  3  5  4  2  3  7  3  4  1  1  1  1 
1 least connected region:
36 with 1 link
1 most connected region:
25 with 17 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.3209  0.7126  0.8481  0.9023  1.0860  1.6740 

  The decimal point is 1 digit(s) to the left of the |

   3 | 2233557799
   4 | 1166777788888888
   5 | 0011224455555566666688889999
   6 | 11113333334455556666666666889999999999
   7 | 00000011112222222233334444444455555555556666667777777777777777889999
   8 | 000011111111222222222233333344444444445555555555666666999999
   9 | 001111222222222233444444555555556666667777778899
  10 | 0000002222223333333344666666777788889999
  11 | 00112233334444555566777788
  12 | 1122223333555566667777888888889999
  13 | 0000001166668899
  14 | 002244558888
  15 | 00667788
  16 | 77

> plot(col.lags[[2]], coords, add=TRUE, col="red", lty=2)
> cuml <- nblag_cumul(col.lags)
> cuml
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 636 
Percentage nonzero weights: 26.48896 
Average number of links: 12.97959 
> if (require(igraph)) {
+ W <- as(nb2listw(col.gal.nb), "CsparseMatrix")
+ G <- graph.adjacency(W, mode="directed", weight="W")
+ D <- diameter(G)
+ nbs <- nblag(col.gal.nb, maxlag=D)
+ n <- length(col.gal.nb)
+ lmat <- lapply(nbs, nb2mat, style="B", zero.policy=TRUE)
+ mat <- matrix(0, n, n)
+ for (i in seq(along=lmat)) mat = mat + i*lmat[[i]]
+ G2 <- shortest.paths(G)
+ print(all.equal(G2, mat, check.attributes=FALSE))
+ 
+ 
+ }
Loading required package: igraph

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nblag", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:igraph’, ‘package:maptools’

> nameEx("nboperations")
> ### * nboperations
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nb.set.operations
> ### Title: Set operations on neighborhood objects
> ### Aliases: intersect.nb union.nb setdiff.nb complement.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col.tri.nb <- tri2nb(coords)
> oldpar <- par(mfrow=c(1,2))
> col.soi.nb <- graph2nb(soi.graph(col.tri.nb, coords))
> plot(columbus, border="grey")
> plot(col.soi.nb, coords, add=TRUE)
> title(main="Sphere of Influence Graph")
> plot(columbus, border="grey")
> plot(complement.nb(col.soi.nb), coords, add=TRUE)
> title(main="Complement of Sphere of Influence Graph")
> par(mfrow=c(2,2))
> col2 <- droplinks(col.gal.nb, 21)
> plot(intersect.nb(col.gal.nb, col2), coords)
> title(main="Intersect")
> plot(union.nb(col.gal.nb, col2), coords)
> title(main="Union")
> plot(setdiff.nb(col.gal.nb, col2), coords)
> title(main="Set diff")
> par(oldpar)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nboperations", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:maptools’

> nameEx("nc.sids")
> ### * nc.sids
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nc.sids
> ### Title: North Carolina SIDS data
> ### Aliases: nc.sids ncCR85.nb ncCC89.nb sidspolys sidscents
> ### Keywords: datasets
> 
> ### ** Examples
> 
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],
+   ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
> rn <- sapply(slot(nc.sids, "polygons"), function(x) slot(x, "ID"))
> ncCC89_nb <- read.gal(system.file("etc/weights/ncCC89.gal", package="spdep")[1],
+   region.id=rn)
> ncCR85_nb <- read.gal(system.file("etc/weights/ncCR85.gal", package="spdep")[1],
+   region.id=rn)
> ## Not run: 
> ##D plot(nc.sids, border="grey")
> ##D plot(ncCR85_nb, coordinates(nc.sids), add=TRUE, col="blue")
> ##D plot(nc.sids, border="grey")
> ##D plot(ncCC89_nb, coordinates(nc.sids), add=TRUE, col="blue")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nc.sids", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("p.adjustSP")
> ### * p.adjustSP
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: p.adjustSP
> ### Title: Adjust local association measures' p-values
> ### Aliases: p.adjustSP
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(afcon)
> oid <- order(afcon$id)
> resG <- as.vector(localG(afcon$totcon, nb2listw(include.self(paper.nb))))
> non <- format.pval(pnorm(2*(abs(resG)), lower.tail=FALSE), 2)
> bon <- format.pval(p.adjustSP(pnorm(2*(abs(resG)), lower.tail=FALSE),
+  paper.nb, "bonferroni"), 2)
> tot <- format.pval(p.adjust(pnorm(2*(abs(resG)), lower.tail=FALSE),
+  "bonferroni", n=length(resG)), 2)
> data.frame(resG, non, bon, tot, row.names=afcon$name)[oid,]
                                resG     non     bon     tot
THE GAMBIA               -0.98383592 0.02455 0.04911  1.0000
MALI                     -1.69893391 0.00034 0.00272  0.0143
SENEGAL                  -1.46321911 0.00171 0.00857  0.0720
BENIN                    -1.30139679 0.00462 0.02312  0.1942
MAURITANIA               -0.60496775 0.11315 0.56576  1.0000
NIGER                    -1.04877003 0.01797 0.14378  0.7549
IVORY COAST              -1.41712454 0.00230 0.01378  0.0965
GUINEA                   -1.44888005 0.00188 0.01128  0.0789
BURKINA FASO             -1.75085492 0.00023 0.00162  0.0097
LIBERIA                  -1.04053617 0.01871 0.07485  0.7860
SIERRA LEONE             -0.87032623 0.04087 0.12262  1.0000
GHANA                    -1.10269327 0.01371 0.05485  0.5760
TOGO                     -0.99053008 0.02379 0.09517  0.9993
CAMEROON                 -1.13328519 0.01171 0.07025  0.4917
NIGERIA                  -1.17261672 0.00951 0.04754  0.3993
GABON                    -0.78935857 0.05720 0.17160  1.0000
CENTRAL AFRICAN REPUBLIC  1.17349763 0.00946 0.05678  0.3974
CHAD                      0.46259185 0.17744 1.00000  1.0000
CONGO                    -0.20253005 0.34272 1.00000  1.0000
ZAIRE                     2.02270432 2.6e-05 0.00026  0.0011
ANGOLA                    1.23450728 0.00677 0.02710  0.2845
UGANDA                    3.33600851 1.3e-11 7.6e-11 5.3e-10
KENYA                     3.50301896 1.2e-12 7.4e-12 5.1e-11
TANZANIA                  1.09843592 0.01401 0.12613  0.5886
BURUNDI                   0.77417084 0.06077 0.24308  1.0000
RWANDA                    1.45720776 0.00178 0.00891  0.0748
SOMALIA                   1.18316273 0.00898 0.02695  0.3773
ETHIOPIA                  2.62720027 7.4e-08 3.0e-07 3.1e-06
ZAMBIA                    0.75273285 0.06610 0.59492  1.0000
ZIMBABWE                 -0.19956472 0.34490 1.00000  1.0000
MALAWI                    0.21195283 0.33582 1.00000  1.0000
MOZAMBIQUE               -0.28761679 0.28257 1.00000  1.0000
SOUTH AFRICA             -0.86814954 0.04126 0.33004  1.0000
LESOTHO                  -0.29841469 0.27531 0.55062  1.0000
BOTSWANA                  0.04090396 0.46740 1.00000  1.0000
SWAZILAND                -0.65938417 0.09362 0.28087  1.0000
MOROCCO                   0.02191606 0.48252 1.00000  1.0000
ALGERIA                  -0.36307938 0.23387 1.00000  1.0000
TUNISIA                   0.57910139 0.12339 0.37017  1.0000
LIBYA                     2.55272169 1.7e-07 1.2e-06 6.9e-06
SUDAN                     4.03925235 3.3e-16 3.0e-15 1.4e-14
EGYPT                     4.42133637 < 2e-16 < 2e-16 < 2e-16
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("p.adjustSP", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot.mst")
> ### * plot.mst
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.mst
> ### Title: Plot the Minimum Spanning Tree
> ### Aliases: plot.mst
> ### Keywords: hplot tree
> 
> ### ** Examples
> 
> ### see example in mstree function documentation
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.mst", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot.nb")
> ### * plot.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.nb
> ### Title: Plot a neighbours list
> ### Aliases: plot.nb plot.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> plot(col.gal.nb, coords)
> title(main="GAL order 1 links with first nearest neighbours in red")
> col.knn <- knearneigh(coords, k=1)
> plot(knn2nb(col.knn), coords, add=TRUE, col="red", length=0.08)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("plot.skater")
> ### * plot.skater
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.skater
> ### Title: Plot the object of skater class
> ### Aliases: plot.skater
> ### Keywords: hplot cluster
> 
> ### ** Examples
> 
> ### see example in the skater function documentation
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.skater", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("poly2nb")
> ### * poly2nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: poly2nb
> ### Title: Construct neighbours list from polygon list
> ### Aliases: poly2nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> xx <- poly2nb(columbus)
> dxx <- diffnb(xx, col.gal.nb)
Warning in diffnb(xx, col.gal.nb) :
  region.id differ; using ids of first list
> plot(columbus, border="grey")
> plot(col.gal.nb, coords, add=TRUE)
> plot(dxx, coords, add=TRUE, col="red")
> title(main=paste("Differences (red) in Columbus GAL weights (black)",
+  "and polygon generated queen weights", sep="\n"))
> xxx <- poly2nb(columbus, queen=FALSE)
> dxxx <- diffnb(xxx, col.gal.nb)
Warning in diffnb(xxx, col.gal.nb) :
  region.id differ; using ids of first list
> plot(columbus, border = "grey")
> plot(col.gal.nb, coords, add = TRUE)
> plot(dxxx, coords, add = TRUE, col = "red")
> title(main=paste("Differences (red) in Columbus GAL weights (black)",
+  "and polygon generated rook weights", sep="\n"))
> cards <- card(xx)
> maxconts <- which(cards == max(cards))
> if(length(maxconts) > 1) maxconts <- maxconts[1]
> fg <- rep("grey", length(cards))
> fg[maxconts] <- "red"
> fg[xx[[maxconts]]] <- "green"
> plot(columbus, col=fg)
> title(main="Region with largest number of contiguities")
> example(nc.sids)

nc.sds> require(maptools)

nc.sds> nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],
nc.sds+   ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

nc.sds> rn <- sapply(slot(nc.sids, "polygons"), function(x) slot(x, "ID"))

nc.sds> ncCC89_nb <- read.gal(system.file("etc/weights/ncCC89.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ncCR85_nb <- read.gal(system.file("etc/weights/ncCR85.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ## Not run: 
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCR85_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCC89_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ## End(Not run)
nc.sds> 
nc.sds> 
nc.sds> 
> system.time(xxnb <- poly2nb(nc.sids))
   user  system elapsed 
  0.021   0.000   0.020 
> plot(nc.sids)
> plot(xxnb, coordinates(nc.sids), add=TRUE, col="blue")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("poly2nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("predict.sarlm")
> ### * predict.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict.sarlm
> ### Title: Prediction for spatial simultaneous autoregressive linear model
> ###   objects
> ### Aliases: predict.sarlm print.sarlm.pred as.data.frame.sarlm.pred
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> lw <- nb2listw(COL.nb)
> COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw)
> COL.mix.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,
+   type="mixed")
> COL.err.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw)
> COL.SDerr.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,
+  etype="emixed")
> print(p1 <- predict(COL.mix.eig))
         fit      trend    signal
1  26.044311 14.8543508 11.189960
2  44.034234 29.2632112 14.771023
3  43.511934 25.8193818 17.692553
4  37.656561 16.4555583 21.201002
5  10.902976  0.3664066 10.536570
6  36.829798 24.2905246 12.539274
7  44.290467 27.0386615 17.251806
8  38.853571 21.5342393 17.319331
9  50.870854 29.5092783 21.361576
10 16.401300  5.6029104 10.798389
11 36.354390 28.6415353  7.712855
12 20.452836 12.4607277  7.992108
13 20.324088 14.4173433  5.906745
14 19.243496 10.2606419  8.982854
15 19.747775 12.2556861  7.492089
16  6.962527 -2.0137491  8.976276
17  7.452143 -6.3808928 13.833036
18 28.481587 14.2125594 14.269028
19 43.351392 28.0442064 15.307186
20 50.359682 30.6608153 19.698867
21 38.905226 24.7490977 14.156128
22 44.724478 28.8314299 15.893048
23 37.888974 23.7778863 14.111087
24 45.527017 26.9163190 18.610698
25 32.429571 17.1892401 15.240331
26 26.490842 14.8893980 11.601444
27 35.629158 23.4577209 12.171437
28 35.574326 21.9001006 13.674226
29 38.598639 23.1818442 15.416795
30 36.602053 14.8614072 21.740646
31 50.320031 30.1013982 20.218633
32 53.698863 31.2094168 22.489447
33 49.364208 26.5151201 22.849088
34 46.262357 25.5538226 20.708534
35 39.177121 15.7689329 23.408188
36 54.984344 32.6590841 22.325260
37 51.611458 33.1290203 18.482438
38 51.998831 30.7428313 21.256000
39 43.651605 27.4107880 16.240817
40 44.196841 25.9409252 18.255916
41 49.310592 29.5106497 19.799943
42 37.995310 15.7039024 22.291408
43 46.908709 28.2687603 18.639948
44 28.976789 19.5389223  9.437867
45 25.343793 17.1838200  8.159973
46 24.006252 16.0103703  7.995882
47 25.034907 18.4616473  6.573260
48 10.478529  3.3573578  7.121171
49 13.495623  5.3356502  8.159973
> print(p2 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw))
         fit      trend    signal
1  29.038788 14.8543508 14.184437
2  46.227075 29.2632112 16.963864
3  45.640479 25.8193818 19.821097
4  36.643520 16.4555583 20.187962
5  14.819940  0.3664066 14.453533
6  38.764777 24.2905246 14.474252
7  45.715716 27.0386615 18.677055
8  37.514611 21.5342393 15.980372
9  49.324228 29.5092783 19.814950
10 17.510607  5.6029104 11.907696
11 34.973608 28.6415353  6.332072
12 21.079100 12.4607277  8.618372
13 19.704134 14.4173433  5.286791
14 16.365521 10.2606419  6.104879
15 17.063856 12.2556861  4.808170
16  6.190282 -2.0137491  8.204031
17  5.967260 -6.3808928 12.348153
18 29.250462 14.2125594 15.037902
19 41.530036 28.0442064 13.485830
20 49.344770 30.6608153 18.683954
21 39.508818 24.7490977 14.759720
22 42.772692 28.8314299 13.941262
23 37.114901 23.7778863 13.337015
24 43.622499 26.9163190 16.706180
25 33.247197 17.1892401 16.057957
26 30.301331 14.8893980 15.411933
27 38.316063 23.4577209 14.858342
28 36.886068 21.9001006 14.985967
29 38.970564 23.1818442 15.788720
30 33.014615 14.8614072 18.153208
31 48.209875 30.1013982 18.108477
32 50.808064 31.2094168 19.598647
33 44.555996 26.5151201 18.040876
34 43.232773 25.5538226 17.678951
35 35.009061 15.7689329 19.240128
36 52.113364 32.6590841 19.454280
37 52.189015 33.1290203 19.059995
38 51.631805 30.7428313 20.888973
39 46.543565 27.4107880 19.132776
40 45.036095 25.9409252 19.095170
41 45.907835 29.5106497 16.397185
42 35.337110 15.7039024 19.633208
43 43.948398 28.2687603 15.679638
44 32.091257 19.5389223 12.552334
45 29.647005 17.1838200 12.463185
46 26.375304 16.0103703 10.364934
47 27.235807 18.4616473  8.774160
48 14.785518  3.3573578 11.428160
49 17.798835  5.3356502 12.463185
> AIC(COL.mix.eig)
[1] 376.787
> sqrt(deviance(COL.mix.eig)/length(COL.nb))
[1] 9.580773
> sqrt(sum((COL.OLD$CRIME - as.vector(p1))^2)/length(COL.nb))
[1] 9.580773
> sqrt(sum((COL.OLD$CRIME - as.vector(p2))^2)/length(COL.nb))
[1] 10.35029
> AIC(COL.err.eig)
[1] 376.7609
> sqrt(deviance(COL.err.eig)/length(COL.nb))
[1] 9.776221
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig)))^2)/length(COL.nb))
[1] 9.776221
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig, newdata=COL.OLD,
+   listw=lw)))^2)/length(COL.nb))
[1] 11.61744
> AIC(COL.SDerr.eig)
[1] 377.1693
> sqrt(deviance(COL.SDerr.eig)/length(COL.nb))
[1] 9.619298
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig)))^2)/length(COL.nb))
[1] 9.619298
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig, newdata=COL.OLD,
+   listw=lw)))^2)/length(COL.nb))
[1] 10.40472
> AIC(COL.lag.eig)
[1] 374.7809
> sqrt(deviance(COL.lag.eig)/length(COL.nb))
[1] 9.772129
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig)))^2)/length(COL.nb))
[1] 9.772129
> sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig, newdata=COL.OLD,
+   listw=lw)))^2)/length(COL.nb))
[1] 10.72654
> p3 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, legacy=FALSE)
> all.equal(p2, p3)
[1] TRUE
> p4 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, legacy=FALSE, power=TRUE)
> all.equal(p2, p4)
[1] TRUE
> p5 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, legacy=TRUE, power=TRUE)
> all.equal(p2, p5)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("probmap")
> ### * probmap
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: probmap
> ### Title: Probability mapping for rates
> ### Aliases: probmap
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(auckland)

acklnd> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

acklnd> auckland <- readShapePoly(system.file("etc/shapes/auckland.shp",
acklnd+  package="spdep")[1])

acklnd> auckland.nb <- poly2nb(auckland)
> res <- probmap(auckland$M77_85, 9*auckland$Und5_81)
> rt <- sum(auckland$M77_85)/sum(9*auckland$Und5_81)
> ppois_pmap <- numeric(length(auckland$Und5_81))
> for (i in seq(along=ppois_pmap)) {
+ ppois_pmap[i] <- poisson.test(auckland$M77_85[i], r=rt,
+   T=(9*auckland$Und5_81[i]), alternative="less")$p.value
+ }
> all.equal(ppois_pmap, res$pmap)
[1] TRUE
> brks <- c(-Inf,2,2.5,3,3.5,Inf)
> cols <- grey(6:2/7)
> plot(auckland, col=cols[findInterval(res$raw*1000, brks, all.inside=TRUE)])
> legend("bottomleft", fill=cols, legend=leglabs(brks), bty="n")
> title(main="Crude (raw) estimates of infant mortality per 1000 per year")
> brks <- c(-Inf,47,83,118,154,190,Inf)
> cols <- cm.colors(6)
> plot(auckland, col=cols[findInterval(res$relRisk, brks, all.inside=TRUE)])
> legend("bottomleft", fill=cols, legend=leglabs(brks), bty="n")
> title(main="Standardised mortality ratios for Auckland child deaths")
> brks <- c(0,0.05,0.1,0.2,0.8,0.9,0.95,1)
> cols <- cm.colors(7)
> plot(auckland, col=cols[findInterval(res$pmap, brks, all.inside=TRUE)])
> legend("bottomleft", fill=cols, legend=leglabs(brks), bty="n")
> title(main="Poisson probabilities for Auckland child mortality")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("probmap", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("prunecost")
> ### * prunecost
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: prunecost
> ### Title: Compute cost of prune each edge
> ### Aliases: prunecost
> ### Keywords: graphs cluster
> 
> ### ** Examples
> 
> d <- data.frame(a=-2:2, b=runif(5))
> e <- matrix(c(1,2, 2,3, 3,4, 4,5), ncol=2, byrow=TRUE)
> 
> sum(sweep(d, 2, colMeans(d))^2)
[1] 10.32582
> 
> prunecost(e, d)
[1] 2.055010 2.818561 2.954664 2.137955
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("prunecost", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("prunemst")
> ### * prunemst
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: prunemst
> ### Title: Prune a Minimun Spanning Tree
> ### Aliases: prunemst
> ### Keywords: tree cluster
> 
> ### ** Examples
> 
> e <- matrix(c(2,3, 1,2, 3,4, 4,5), ncol=2, byrow=TRUE)
> e
     [,1] [,2]
[1,]    2    3
[2,]    1    2
[3,]    3    4
[4,]    4    5
> prunemst(e)
$node1
[1] 2 1

$node2
[1] 3 4 5

> prunemst(e, only.nodes=FALSE)
[[1]]
[[1]]$node
[1] 2 1

[[1]]$edge
     [,1] [,2]
[1,]    1    2


[[2]]
[[2]]$node
[1] 3 4 5

[[2]]$edge
     [,1] [,2]
[1,]    3    4
[2,]    4    5


> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("prunemst", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read.gal")
> ### * read.gal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read.gal
> ### Title: Read a GAL lattice file into a neighbours list
> ### Aliases: read.gal read.geoda
> ### Keywords: spatial
> 
> ### ** Examples
> 
> us48.fipsno <- read.geoda(system.file("etc/weights/us48.txt",
+  package="spdep")[1])
> us48.q <- read.gal(system.file("etc/weights/us48_q.GAL", package="spdep")[1],
+  us48.fipsno$Fipsno)
> us48.r <- read.gal(system.file("etc/weights/us48_rk.GAL", package="spdep")[1],
+  us48.fipsno$Fipsno)
> data(state)
> if (as.numeric(paste(version$major, version$minor, sep="")) < 19) {
+  m50.48 <- match(us48.fipsno$"State.name", state.name)
+ } else {
+  m50.48 <- match(us48.fipsno$"State_name", state.name)
+ }
> plot(us48.q, as.matrix(as.data.frame(state.center))[m50.48,])
> plot(diffnb(us48.r, us48.q),
+  as.matrix(as.data.frame(state.center))[m50.48,], add=TRUE, col="red")
> title(main="Differences between rook and queen criteria imported neighbours lists")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read.gal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read.gwt2nb")
> ### * read.gwt2nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read.gwt2nb
> ### Title: Read and write spatial neighbour files
> ### Aliases: read.gwt2nb write.sn2gwt read.dat2listw write.sn2dat
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(baltimore)
> STATION <- baltimore$STATION
> gwt1 <- read.gwt2nb(system.file("etc/weights/baltk4.GWT", package="spdep")[1],
+  STATION)
Warning in read.gwt2nb(system.file("etc/weights/baltk4.GWT", package = "spdep")[1],  :
  102, 115, 208 are not destinations
> cat(paste("Neighbours list symmetry;", is.symmetric.nb(gwt1, FALSE, TRUE),
+  "\n"))
Neighbours list symmetry; FALSE 
> listw1 <- nb2listw(gwt1, style="B", glist=attr(gwt1, "GeoDa")$dist)
> tmpGWT <- tempfile()
> write.sn2gwt(listw2sn(listw1), tmpGWT)
> gwt2 <- read.gwt2nb(tmpGWT, STATION)
Warning in read.gwt2nb(tmpGWT, STATION) :
  102, 115, 208 are not destinations
> cat(paste("Neighbours list symmetry;", is.symmetric.nb(gwt2, FALSE, TRUE),
+  "\n"))
Neighbours list symmetry; FALSE 
> diffnb(gwt1, gwt2)
Neighbour list object:
Number of regions: 211 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
211 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211
> data(oldcol)
> tmpMAT <- tempfile()
> COL.W <- nb2listw(COL.nb)
> write.sn2dat(listw2sn(COL.W), tmpMAT)
> listwmat1 <- read.dat2listw(tmpMAT)
> diffnb(listwmat1$neighbours, COL.nb, verbose=TRUE)
Warning in diffnb(listwmat1$neighbours, COL.nb, verbose = TRUE) :
  region.id differ; using ids of first list
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
> listwmat2 <- read.dat2listw(system.file("etc/weights/wmat.dat", 
+  package="spdep")[1])
> diffnb(listwmat1$neighbours, listwmat2$neighbours, verbose=TRUE)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read.gwt2nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rotation")
> ### * rotation
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Rotation
> ### Title: Rotate a set of point by a certain angle
> ### Aliases: Rotation
> ### Keywords: manip
> 
> ### ** Examples
> 
> set.seed(1)
> ### Create a set of coordinates
> coords<-cbind(runif(20),runif(20))
> 
> ### Create a series of angles
> rad<-seq(0,pi,l=20)
> 
> opar <- par(mfrow=c(5,4))
> for(i in rad){
+ 	coords.rot<-Rotation(coords,i)
+ 	plot(coords.rot)
+ }
> par(opar)
> 
> ### Rotate the coordinates by an angle of 90 degrees
> coords.90<-Rotation(coords,90*pi/180)
> coords.90
             [,1]       [,2]
 [1,] -0.93470523 0.26550866
 [2,] -0.21214252 0.37212390
 [3,] -0.65167377 0.57285336
 [4,] -0.12555510 0.90820779
 [5,] -0.26722067 0.20168193
 [6,] -0.38611409 0.89838968
 [7,] -0.01339033 0.94467527
 [8,] -0.38238796 0.66079779
 [9,] -0.86969085 0.62911404
[10,] -0.34034900 0.06178627
[11,] -0.48208012 0.20597457
[12,] -0.59956583 0.17655675
[13,] -0.49354131 0.68702285
[14,] -0.18621760 0.38410372
[15,] -0.82737332 0.76984142
[16,] -0.66846674 0.49769924
[17,] -0.79423986 0.71761851
[18,] -0.10794363 0.99190609
[19,] -0.72371095 0.38003518
[20,] -0.41127443 0.77744522
> 
> plot(coords,xlim=range(rbind(coords.90,coords)[,1]),ylim=range(rbind(coords.90,coords)[,2]),asp=1)
> points(coords.90,pch=19)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rotation", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("sacsarlm")
> ### * sacsarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sacsarlm
> ### Title: Spatial simultaneous autoregressive SAC model estimation
> ### Aliases: sacsarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.sacW.eig <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, 
+  nb2listw(COL.nb, style="W"))
> summary(COL.sacW.eig, correlation=TRUE)

Call:
sacsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"))

Residuals:
      Min        1Q    Median        3Q       Max 
-37.32081  -5.33662  -0.20219   6.59672  23.25604 

Type: sac 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 47.783766   9.902659  4.8253 1.398e-06
INC         -1.025894   0.326326 -3.1438  0.001668
HOVAL       -0.281651   0.090033 -3.1283  0.001758

Rho: 0.36807
Asymptotic standard error: 0.19668
    z-value: 1.8714, p-value: 0.061285
Lambda: 0.16668
Asymptotic standard error: 0.29661
    z-value: 0.56196, p-value: 0.57415

LR test value: 10.285, p-value: 0.0058432

Log likelihood: -182.2348 for sac model
ML residual variance (sigma squared): 95.604, (sigma: 9.7777)
Number of observations: 49 
Number of parameters estimated: 6 
AIC: 376.47, (AIC for lm: 382.75)

 Correlation of coefficients 
            sigma rho   lambda (Intercept) INC  
rho         -0.10                               
lambda       0.03 -0.76                         
(Intercept)  0.09 -0.90  0.68                   
INC         -0.04  0.38 -0.29  -0.59            
HOVAL       -0.01  0.09 -0.07  -0.22       -0.41

> W <- as(nb2listw(COL.nb, style="W"), "CsparseMatrix")
> trMatc <- trW(W, type="mult")
> summary(impacts(COL.sacW.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE)
Impact measures (sac, trace):
          Direct   Indirect      Total
INC   -1.0632723 -0.5601501 -1.6234223
HOVAL -0.2919129 -0.1537847 -0.4456977
========================================================
Simulation results (asymptotic variance matrix):
========================================================
Simulated z-values:
         Direct   Indirect     Total
INC   -3.376570 -0.8371024 -1.861677
HOVAL -3.159909 -0.7431009 -1.553156

Simulated p-values:
      Direct     Indirect Total   
INC   0.00073396 0.40254  0.062649
HOVAL 0.00157818 0.45742  0.120386
> COL.msacW.eig <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, 
+  nb2listw(COL.nb, style="W"), type="sacmixed")
> summary(COL.msacW.eig, correlation=TRUE)

Call:
sacsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), type = "sacmixed")

Residuals:
     Min       1Q   Median       3Q      Max 
-37.8045  -6.5244  -0.2207   5.9944  22.8691 

Type: sacmixed 
Coefficients: (asymptotic standard errors) 
            Estimate Std. Error z value Pr(>|z|)
(Intercept) 50.92026   68.25721  0.7460 0.455664
INC         -0.95072    0.44033 -2.1591 0.030841
HOVAL       -0.28650    0.09994 -2.8667 0.004148
lag.INC     -0.69261    1.69113 -0.4096 0.682132
lag.HOVAL    0.20852    0.28702  0.7265 0.467546

Rho: 0.31557
Asymptotic standard error: 0.9458
    z-value: 0.33365, p-value: 0.73864
Lambda: 0.15415
Asymptotic standard error: 1.0643
    z-value: 0.14484, p-value: 0.88484

LR test value: 12.07, p-value: 0.016837

Log likelihood: -181.3422 for sacmixed model
ML residual variance (sigma squared): 93.149, (sigma: 9.6514)
Number of observations: 49 
Number of parameters estimated: 8 
AIC: 378.68, (AIC for lm: 382.75)

 Correlation of coefficients 
            sigma rho   lambda (Intercept) INC   HOVAL lag.INC
rho         -0.36                                             
lambda       0.34 -0.98                                       
(Intercept)  0.36 -1.00  0.98                                 
INC         -0.25  0.68 -0.67  -0.69                          
HOVAL        0.17 -0.46  0.45   0.44       -0.60              
lag.INC     -0.34  0.95 -0.94  -0.96        0.57 -0.43        
lag.HOVAL   -0.28  0.77 -0.76  -0.79        0.57 -0.40  0.62  

> summary(impacts(COL.msacW.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE)
Impact measures (sacmixed, trace):
          Direct   Indirect      Total
INC   -1.0317003 -1.3693141 -2.4010144
HOVAL -0.2768608  0.1629265 -0.1139344
========================================================
Simulation results (asymptotic variance matrix):
========================================================
Simulated z-values:
         Direct   Indirect       Total
INC   -2.829395 -0.7135127 -1.12521734
HOVAL -2.374202  0.2243548 -0.07638181

Simulated p-values:
      Direct    Indirect Total  
INC   0.0046636 0.47553  0.26050
HOVAL 0.0175869 0.82248  0.93912
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sacsarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("set.mcOption")
> ### * set.mcOption
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: set.mcOption
> ### Title: Options for parallel support
> ### Aliases: set.ClusterOption get.ClusterOption set.mcOption
> ###   get.coresOption set.coresOption get.mcOption
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ls(envir=spdep:::.spdepOptions)
[1] "cluster"                "cores"                  "listw_is_CsparseMatrix"
[4] "mc"                     "rlecuyerSeed"           "spChkID"               
[7] "verbose"                "zeroPolicy"            
> library(parallel)
> nc <- detectCores(logical=FALSE)
> nc
[1] 4
> # set nc to 1L here
> if (nc > 1L) nc <- 1L
> #nc <- ifelse(nc > 2L, 2L, nc)
> coresOpt <- get.coresOption()
> coresOpt
NULL
> if (!is.na(nc)) {
+  invisible(set.coresOption(nc))
+  print(exists("aple.mc"))
+  if(.Platform$OS.type == "windows") {
+ # forking not permitted on Windows - start cluster
+   print(get.mcOption())
+   cl <- makeCluster(get.coresOption())
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   set.ClusterOption(cl)
+   clusterEvalQ(get.ClusterOption(), library(spdep))
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   clusterEvalQ(get.ClusterOption(), detach(package:spdep))
+   set.ClusterOption(NULL)
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   stopCluster(cl)
+  } else {
+   mcOpt <- get.mcOption()
+   print(mcOpt)
+   print(mclapply(1:get.coresOption(), function(i) exists("aple.mc"),
+    mc.cores=get.coresOption()))
+   invisible(set.mcOption(FALSE))
+   cl <- makeCluster(nc)
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   set.ClusterOption(cl)
+   clusterEvalQ(get.ClusterOption(), library(spdep))
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   clusterEvalQ(get.ClusterOption(), detach(package:spdep))
+   set.ClusterOption(NULL)
+   print(clusterEvalQ(cl, exists("aple.mc")))
+   stopCluster(cl)
+   invisible(set.mcOption(mcOpt))
+  }
+  invisible(set.coresOption(coresOpt))
+ }
[1] TRUE
[1] TRUE
[[1]]
[1] TRUE

[[1]]
[1] FALSE

[[1]]
[1] TRUE

[[1]]
[1] FALSE

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("set.mcOption", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:parallel’

> nameEx("set.spChkOption")
> ### * set.spChkOption
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: set.spChkOption
> ### Title: Control checking of spatial object IDs
> ### Aliases: set.spChkOption get.spChkOption chkIDs spNamedVec
> ###   set.VerboseOption get.VerboseOption set.ZeroPolicyOption
> ###   get.ZeroPolicyOption set.listw_is_CsparseMatrix_Option
> ###   get.listw_is_CsparseMatrix_Option
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> rownames(COL.OLD)
 [1] "1001" "1002" "1003" "1004" "1005" "1006" "1007" "1008" "1009" "1010"
[11] "1011" "1012" "1013" "1014" "1015" "1016" "1017" "1018" "1019" "1020"
[21] "1021" "1022" "1023" "1024" "1025" "1026" "1027" "1028" "1029" "1030"
[31] "1031" "1032" "1033" "1034" "1035" "1036" "1037" "1038" "1039" "1040"
[41] "1041" "1042" "1043" "1044" "1045" "1046" "1047" "1048" "1049"
> data(columbus)
> rownames(columbus)
 [1] "1005" "1001" "1006" "1002" "1007" "1008" "1004" "1003" "1018" "1010"
[11] "1038" "1037" "1039" "1040" "1009" "1036" "1011" "1042" "1041" "1017"
[21] "1043" "1019" "1012" "1035" "1032" "1020" "1021" "1031" "1033" "1034"
[31] "1045" "1013" "1022" "1044" "1023" "1046" "1030" "1024" "1047" "1016"
[41] "1014" "1049" "1029" "1025" "1028" "1048" "1015" "1027" "1026"
> get.spChkOption()
[1] FALSE
> oldChk <- set.spChkOption(TRUE)
> get.spChkOption()
[1] TRUE
> chkIDs(COL.OLD, nb2listw(COL.nb))
[1] TRUE
> chkIDs(columbus, nb2listw(col.gal.nb))
[1] TRUE
> chkIDs(columbus, nb2listw(COL.nb))
[1] FALSE
> tmp <- try(moran.test(spNamedVec("CRIME", COL.OLD), nb2listw(COL.nb)))
> print(tmp)

	Moran's I test under randomisation

data:  spNamedVec("CRIME", COL.OLD)  
weights: nb2listw(COL.nb)  

Moran I statistic standard deviate = 5.6341, p-value = 8.797e-09
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.510951264      -0.020833333       0.008908762 

> tmp <- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(col.gal.nb)))
> print(tmp)

	Moran's I test under randomisation

data:  spNamedVec("CRIME", columbus)  
weights: nb2listw(col.gal.nb)  

Moran I statistic standard deviate = 5.3427, p-value = 4.578e-08
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.485770914      -0.020833333       0.008991121 

> tmp <- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb)))
Error in moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb)) : 
  Check of data and weights ID integrity failed
> print(tmp)
[1] "Error in moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb)) : \n  Check of data and weights ID integrity failed\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb)): Check of data and weights ID integrity failed>
> set.spChkOption(FALSE)
[1] TRUE
> get.spChkOption()
[1] FALSE
> moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb))

	Moran's I test under randomisation

data:  spNamedVec("CRIME", columbus)  
weights: nb2listw(COL.nb)  

Moran I statistic standard deviate = 3.8402, p-value = 6.147e-05
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.341628707      -0.020833333       0.008908762 

> tmp <- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb),
+  spChk=TRUE))
Error in moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb), spChk = TRUE) : 
  Check of data and weights ID integrity failed
> print(tmp)
[1] "Error in moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb), spChk = TRUE) : \n  Check of data and weights ID integrity failed\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb), spChk = TRUE): Check of data and weights ID integrity failed>
> set.spChkOption(oldChk)
[1] FALSE
> get.spChkOption()
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("set.spChkOption", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("similar.listw")
> ### * similar.listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: similar.listw
> ### Title: Create symmetric similar weights lists
> ### Aliases: similar.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.W <- nb2listw(COL.nb, style="W")
> COL.S <- nb2listw(COL.nb, style="S")
> sum(log(1 - 0.5 * eigenw(COL.W)))
[1] -1.62766
> sum(log(1 - 0.5 * eigenw(similar.listw(COL.W))))
[1] -1.62766
> W_J <- as(as_dsTMatrix_listw(similar.listw(COL.W)), "CsparseMatrix")
> I <- as_dsCMatrix_I(dim(W_J)[1])
> c(determinant(I - 0.5 * W_J, logarithm=TRUE)$modulus)
[1] -1.62766
> sum(log(1 - 0.5 * eigenw(COL.S)))
[1] -1.602757
> sum(log(1 - 0.5 * eigenw(similar.listw(COL.S))))
[1] -1.602757
> W_J <- as(as_dsTMatrix_listw(similar.listw(COL.S)), "CsparseMatrix")
> c(determinant(I - 0.5 * W_J, logarithm=TRUE)$modulus)
[1] -1.602757
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("similar.listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("skater")
> ### * skater
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: skater
> ### Title: Spatial 'K'luster Analysis by Tree Edge Removal
> ### Aliases: skater
> ### Keywords: cluster tree
> 
> ### ** Examples
> 
> ### loading data
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> bh <- readShapePoly(system.file("etc/shapes/bhicv.shp",
+       package="spdep")[1])
> ### data standardized 
> dpad <- data.frame(scale(bh@data[,5:8]))
> 
> ### neighboorhod list
> bh.nb <- poly2nb(bh)
> 
> ### calculating costs
> lcosts <- nbcosts(bh.nb, dpad)
> 
> ### making listw
> nb.w <- nb2listw(bh.nb, lcosts, style="B")
> 
> ### find a minimum spanning tree
> mst.bh <- mstree(nb.w,5)
> 
> ### the mstree plot
> par(mar=c(0,0,0,0))
> plot(mst.bh, coordinates(bh), col=2,       
+      cex.lab=.7, cex.circles=0.035, fg="blue")
> plot(bh, border=gray(.5), add=TRUE)
> 
> ### three groups with no restriction
> res1 <- skater(mst.bh[,1:2], dpad, 2)
> 
> ### groups size
> table(res1$groups)

 1  2  3 
18 23 57 
> 
> ### the skater plot
> par(mar=c(0,0,0,0))
> plot(res1, coordinates(bh), cex.circles=0.035, cex.lab=.7)
> 
> ### the skater plot, using other colors
> plot(res1, coordinates(bh), cex.circles=0.035, cex.lab=.7,
+      groups.colors=rainbow(length(res1$ed)))
> 
> ### the Spatial Polygons plot
> plot(bh, col=heat.colors(length(res1$edg))[res1$groups])
> 
> ### EXPERT OPTIONS
> 
> ### more one partition
> res1b <- skater(res1, dpad, 1)
> 
> ### length groups frequency
> table(res1$groups)

 1  2  3 
18 23 57 
> table(res1b$groups)

 1  2  3  4 
18 23 55  2 
> 
> ### thee groups with minimum population 
> res2 <- skater(mst.bh[,1:2], dpad, 2, 200000, bh@data$Pop)
> 
> ### thee groups with minimun number of areas
> res3 <- skater(mst.bh[,1:2], dpad, 2, 3, rep(1,nrow(bh@data)))
> 
> ### thee groups with minimun and maximun number of areas
> res4 <- skater(mst.bh[,1:2], dpad, 2, c(20,50), rep(1,nrow(bh@data)))
> 
> table(res2$groups)

 1  2  3 
22 37 39 
> table(res3$groups)

 1  2  3 
18 23 57 
> table(res4$groups)

 1  2  3 
50 24 24 
> 
> ### if I want to get groups with 20 to 40 elements
> res5 <- skater(mst.bh[,1:2], dpad, 2,
+    c(20,40), rep(1,nrow(bh@data))) ## DON'T MAKE DIVISIONS 
> table(res5$groups)

 1 
98 
> 
> ### In this MST don't have groups with this restrictions
> ### In this case, first I do one division
> ### with the minimun criteria
> res5a <- skater(mst.bh[,1:2], dpad, 1, 20, rep(1,nrow(bh@data))) 
> table(res5a$groups)

 1  2 
75 23 
> 
> ### and do more one division with the full criteria
> res5b <- skater(res5a, dpad, 1, c(20, 40), rep(1,nrow(bh@data)))
> table(res5b$groups)

 1  2  3 
22 23 53 
> 
> ### and do more one division with the full criteria
> res5c <- skater(res5b, dpad, 1, c(20, 40), rep(1,nrow(bh@data)))
> table(res5c$groups)

 1  2  3  4 
22 23 33 20 
> 
> ### It don't have another divison with this criteria
> res5d <- skater(res5c, dpad, 1, c(20, 40), rep(1,nrow(bh@data)))
> table(res5d$groups)

 1  2  3  4 
22 23 33 20 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("skater", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:maptools’

> nameEx("sp.correlogram")
> ### * sp.correlogram
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sp.correlogram
> ### Title: Spatial correlogram
> ### Aliases: sp.correlogram plot.spcor print.spcor
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(nc.sids)

nc.sds> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

nc.sds> nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],
nc.sds+   ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

nc.sds> rn <- sapply(slot(nc.sids, "polygons"), function(x) slot(x, "ID"))

nc.sds> ncCC89_nb <- read.gal(system.file("etc/weights/ncCC89.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ncCR85_nb <- read.gal(system.file("etc/weights/ncCR85.gal", package="spdep")[1],
nc.sds+   region.id=rn)

nc.sds> ## Not run: 
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCR85_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ##D plot(nc.sids, border="grey")
nc.sds> ##D plot(ncCC89_nb, coordinates(nc.sids), add=TRUE, col="blue")
nc.sds> ## End(Not run)
nc.sds> 
nc.sds> 
nc.sds> 
> ft.SID74 <- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +
+   sqrt((nc.sids$SID74+1)/nc.sids$BIR74))
> tr.SIDS74 <- ft.SID74*sqrt(nc.sids$BIR74)
> cspc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="corr",
+  zero.policy=TRUE)
> print(cspc)
Spatial correlogram for tr.SIDS74 
method: Spatial autocorrelation
          1           2           3           4           5           6 
 0.38193491  0.47679881  0.11740653  0.09935901  0.27819159  0.30153012 
          7           8 
-0.05150923  0.05283813 
> plot(cspc)
> Ispc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="I",
+  zero.policy=TRUE)
> print(Ispc)
Spatial correlogram for tr.SIDS74 
method: Moran's I
         estimate expectation   variance standard deviate Pr(I) two sided    
1 (98)  0.2311685  -0.0103093  0.0055378           3.2450       0.0011747 ** 
2 (98)  0.2246930  -0.0103093  0.0037817           3.8214       0.0001327 ***
3 (98)  0.0193576  -0.0103093  0.0029386           0.5473       0.5841914    
4 (98)  0.0042255  -0.0103093  0.0024974           0.2908       0.7711687    
5 (98)  0.0875548  -0.0103093  0.0022875           2.0462       0.0407386 *  
6 (98)  0.0758362  -0.0103093  0.0021583           1.8543       0.0637011 .  
7 (98) -0.0752243  -0.0103093  0.0022282          -1.3752       0.1690654    
8 (98) -0.0261063  -0.0103093  0.0025211          -0.3146       0.7530514    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> print(Ispc, "bonferroni")
Spatial correlogram for tr.SIDS74 
method: Moran's I
         estimate expectation   variance standard deviate Pr(I) two sided   
1 (98)  0.2311685  -0.0103093  0.0055378           3.2450        0.009397 **
2 (98)  0.2246930  -0.0103093  0.0037817           3.8214        0.001061 **
3 (98)  0.0193576  -0.0103093  0.0029386           0.5473        1.000000   
4 (98)  0.0042255  -0.0103093  0.0024974           0.2908        1.000000   
5 (98)  0.0875548  -0.0103093  0.0022875           2.0462        0.325909   
6 (98)  0.0758362  -0.0103093  0.0021583           1.8543        0.509609   
7 (98) -0.0752243  -0.0103093  0.0022282          -1.3752        1.000000   
8 (98) -0.0261063  -0.0103093  0.0025211          -0.3146        1.000000   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> plot(Ispc)
> Cspc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="C",
+  zero.policy=TRUE)
> print(Cspc)
Spatial correlogram for tr.SIDS74 
method: Geary's C
        estimate expectation  variance standard deviate Pr(I) two sided    
1 (98) 0.7172624   1.0000000 0.0059986          -3.6506       0.0002617 ***
2 (98) 0.6817819   1.0000000 0.0046785          -4.6523       3.282e-06 ***
3 (98) 0.9470179   1.0000000 0.0044311          -0.7959       0.4260762    
4 (98) 1.0016202   1.0000000 0.0041985           0.0250       0.9800516    
5 (98) 0.8977501   1.0000000 0.0038054          -1.6575       0.0974119 .  
6 (98) 0.9173310   1.0000000 0.0036428          -1.3697       0.1707819    
7 (98) 1.0527148   1.0000000 0.0037227           0.8640       0.3875979    
8 (98) 1.0067939   1.0000000 0.0036482           0.1125       0.9104415    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> print(Cspc, "bonferroni")
Spatial correlogram for tr.SIDS74 
method: Geary's C
        estimate expectation  variance standard deviate Pr(I) two sided    
1 (98) 0.7172624   1.0000000 0.0059986          -3.6506        0.002093 ** 
2 (98) 0.6817819   1.0000000 0.0046785          -4.6523       2.626e-05 ***
3 (98) 0.9470179   1.0000000 0.0044311          -0.7959        1.000000    
4 (98) 1.0016202   1.0000000 0.0041985           0.0250        1.000000    
5 (98) 0.8977501   1.0000000 0.0038054          -1.6575        0.779295    
6 (98) 0.9173310   1.0000000 0.0036428          -1.3697        1.000000    
7 (98) 1.0527148   1.0000000 0.0037227           0.8640        1.000000    
8 (98) 1.0067939   1.0000000 0.0036482           0.1125        1.000000    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> plot(Cspc)
> drop.no.neighs <- !(1:length(ncCC89_nb) %in% which(card(ncCC89_nb) == 0))
> sub.ncCC89.nb <- subset(ncCC89_nb, drop.no.neighs)
> plot(sp.correlogram(sub.ncCC89.nb, subset(tr.SIDS74,  drop.no.neighs),
+  order=8, method="corr"))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sp.correlogram", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("sp.mantel.mc")
> ### * sp.mantel.mc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sp.mantel.mc
> ### Title: Mantel-Hubert spatial general cross product statistic
> ### Aliases: sp.mantel.mc plot.mc.sim
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> sim1 <- sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb),
+  nsim=99, type="geary", alternative="less")
> sim1

	Mantel permutation test for geary measure

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb) 
number of simulations + 1: 100 

statistic = 51.927, observed rank = 1, p-value = 0.01
alternative hypothesis: less
sample estimates:
mean of permutations   sd of permutations 
           97.467742             7.576027 

> plot(sim1)
> sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,
+  type="sokal", alternative="less")

	Mantel permutation test for sokal measure

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb) 
number of simulations + 1: 100 

statistic = 36.695, observed rank = 1, p-value = 0.01
alternative hypothesis: less
sample estimates:
mean of permutations   sd of permutations 
           55.979566             3.252045 

> sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,
+  type="moran")

	Mantel permutation test for moran measure

data:  COL.OLD$CRIME 
weights: nb2listw(COL.nb) 
number of simulations + 1: 100 

statistic = 24.526, observed rank = 100, p-value = 0.01
alternative hypothesis: greater
sample estimates:
mean of permutations   sd of permutations 
          -0.5243846            4.5409376 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sp.mantel.mc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spautolm")
> ### * spautolm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spautolm
> ### Title: Spatial conditional and simultaneous autoregression model
> ###   estimation
> ### Aliases: spautolm residuals.spautolm deviance.spautolm coef.spautolm
> ###   fitted.spautolm print.spautolm summary.spautolm LR1.spautolm
> ###   logLik.spautolm print.summary.spautolm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(NY_data)

NY_dat> ## NY leukemia
NY_dat> library(foreign)

NY_dat> nydata <- read.dbf(system.file("etc/misc/nydata.dbf", package="spdep")[1])

NY_dat> coordinates(nydata) <- c("X", "Y")

NY_dat> nyadjmat <- as.matrix(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1])[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> ID <- as.character(names(read.dbf(system.file("etc/misc/nyadjwts.dbf",
NY_dat+  package="spdep")[1]))[-1])
Field name: ‘Z600701190’ changed to: ‘Z600701190.1’
Field name: ‘Z600701190’ changed to: ‘Z600701190.2’
Field name: ‘Z600701200’ changed to: ‘Z600701200.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.1’
Field name: ‘Z600701210’ changed to: ‘Z600701210.2’
Field name: ‘Z600701220’ changed to: ‘Z600701220.1’
Field name: ‘Z600701270’ changed to: ‘Z600701270.1’
Field name: ‘Z600701320’ changed to: ‘Z600701320.1’
Field name: ‘Z600701330’ changed to: ‘Z600701330.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.1’
Field name: ‘Z605303010’ changed to: ‘Z605303010.2’
Field name: ‘Z605303040’ changed to: ‘Z605303040.1’
Field name: ‘Z605303040’ changed to: ‘Z605303040.2’
Field name: ‘Z605303050’ changed to: ‘Z605303050.1’
Field name: ‘Z606700170’ changed to: ‘Z606700170.1’
Field name: ‘Z606700360’ changed to: ‘Z606700360.1’
Field name: ‘Z606700560’ changed to: ‘Z606700560.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.1’
Field name: ‘Z606700610’ changed to: ‘Z606700610.2’
Field name: ‘Z606701100’ changed to: ‘Z606701100.1’
Field name: ‘Z606701110’ changed to: ‘Z606701110.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.1’
Field name: ‘Z606701120’ changed to: ‘Z606701120.2’
Field name: ‘Z606701120’ changed to: ‘Z606701120.3’
Field name: ‘Z606701140’ changed to: ‘Z606701140.1’
Field name: ‘Z606701520’ changed to: ‘Z606701520.1’
Field name: ‘Z606701650’ changed to: ‘Z606701650.1’
Field name: ‘Z606701680’ changed to: ‘Z606701680.1’
Field name: ‘Z606701690’ changed to: ‘Z606701690.1’

NY_dat> identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10))
[1] TRUE

NY_dat> nyadjlw <- mat2listw(nyadjmat, as.character(nydata$AREAKEY))

NY_dat> listw_NY <- nb2listw(nyadjlw$neighbours, style="B")
> lm0 <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata)
> summary(lm0)

Call:
lm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.7417 -0.3957 -0.0326  0.3353  4.1398 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -0.51728    0.15856  -3.262  0.00124 ** 
PEXPOSURE    0.04884    0.03506   1.393  0.16480    
PCTAGE65P    3.95089    0.60550   6.525 3.22e-10 ***
PCTOWNHOME  -0.56004    0.17031  -3.288  0.00114 ** 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.6571 on 277 degrees of freedom
Multiple R-squared:  0.1932,	Adjusted R-squared:  0.1844 
F-statistic:  22.1 on 3 and 277 DF,  p-value: 7.306e-13

> lm0w <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata, weights=POP8)
> summary(lm0w)

Call:
lm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata, 
    weights = POP8)

Weighted Residuals:
     Min       1Q   Median       3Q      Max 
-129.067  -14.714    5.817   25.624   70.723 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -0.77837    0.14116  -5.514 8.03e-08 ***
PEXPOSURE    0.07626    0.02731   2.792  0.00560 ** 
PCTAGE65P    3.85656    0.57126   6.751 8.60e-11 ***
PCTOWNHOME  -0.39869    0.15305  -2.605  0.00968 ** 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 33.5 on 277 degrees of freedom
Multiple R-squared:  0.1977,	Adjusted R-squared:  0.189 
F-statistic: 22.75 on 3 and 277 DF,  p-value: 3.382e-13

> esar0 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
+  listw=listw_NY)
> summary(esar0)

Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, 
    data = nydata, listw = listw_NY)

Residuals:
     Min       1Q   Median       3Q      Max 
-1.56754 -0.38239 -0.02643  0.33109  4.01219 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.618193   0.176784 -3.4969 0.0004707
PEXPOSURE    0.071014   0.042051  1.6888 0.0912635
PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09
PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930

Lambda: 0.040487, LR test value: 5.2438, p-value: 0.022026
Asymptotic standard error: 0.016214
    z-value: 2.4971, p-value: 0.01252
Wald statistic: 6.2356, p-value: 0.01252

Log likelihood: -276.1069 for error model
ML residual variance (sigma squared): 0.41388, (sigma: 0.64333)
Number of observations: 281 
Number of parameters estimated: 6 
AIC: 564.21, (AIC for lm: 567.46)

> system.time(esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
+  data=nydata, listw=listw_NY, family="SAR", method="eigen", verbose=TRUE))

Jacobian calculated using neighbourhood matrix eigenvalues
Computing eigenvalues ...

lambda: -0.1280272 function: -316.7563 Jacobian -11.58022 SSE 144.3945 
lambda: -0.01993754 function: -281.8204 Jacobian -0.2954435 SSE 122.0236 
lambda: 0.04686555 function: -276.1764 Jacobian -1.808964 SSE 115.9629 
lambda: 0.04441244 function: -276.1331 Jacobian -1.616242 SSE 116.0864 
lambda: 0.04008128 function: -276.1072 Jacobian -1.304915 SSE 116.3224 
lambda: 0.04050468 function: -276.1069 Jacobian -1.333747 SSE 116.2983 
lambda: 0.04048595 function: -276.1069 Jacobian -1.332465 SSE 116.2994 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.0404872 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0 function: -278.7288 Jacobian 0 SSE 119.6191 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048744 function: -276.1069 Jacobian -1.332567 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048695 function: -276.1069 Jacobian -1.332533 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048744 function: -276.1069 Jacobian -1.332567 SSE 116.2993 
lambda: 0.04048744 function: -276.1069 Jacobian -1.332567 SSE 116.2993 
lambda: 0.04048744 function: -276.1069 Jacobian -1.332567 SSE 116.2993 
lambda: 0.04048744 function: -276.1069 Jacobian -1.332567 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
   user  system elapsed 
  0.254   0.001   0.255 
> res <- summary(esar1f)
> print(res)

Call: 
spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata, 
    listw = listw_NY, family = "SAR", method = "eigen", verbose = TRUE)

Residuals:
     Min       1Q   Median       3Q      Max 
-1.56754 -0.38239 -0.02643  0.33109  4.01219 

Coefficients: 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.618193   0.176784 -3.4969 0.0004707
PEXPOSURE    0.071014   0.042051  1.6888 0.0912635
PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09
PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930

Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026 
Numerical Hessian standard error of lambda: 0.017199 

Log likelihood: -276.1069 
ML residual variance (sigma squared): 0.41388, (sigma: 0.64333)
Number of observations: 281 
Number of parameters estimated: 6 
AIC: 564.21

> sqrt(diag(res$resvar))
(Intercept)   PEXPOSURE   PCTAGE65P  PCTOWNHOME 
 0.17678351  0.04205063  0.62472153  0.19132936 
> sqrt(diag(esar1f$fit$imat)*esar1f$fit$s2)
(Intercept)   PEXPOSURE   PCTAGE65P  PCTOWNHOME 
 0.17678351  0.04205063  0.62472153  0.19132936 
> sqrt(diag(esar1f$fdHess))
[1] 0.01719949 0.18510068 0.04382630 0.63008743 0.20358778
> system.time(esar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
+  data=nydata, listw=listw_NY, family="SAR", method="Matrix", verbose=TRUE))

Jacobian calculated using sparse matrix Cholesky decomposition
lambda: -0.2135255 function: -365.0561 Jacobian -33.88724 SSE 173.7385 
lambda: -0.03647451 function: -285.2244 Jacobian -0.9732593 SSE 124.4143 
lambda: 0.07294902 function: -278.0021 Jacobian -4.669448 SSE 115.112 
lambda: 0.04279999 function: -276.116 Jacobian -1.496068 SSE 116.1715 
lambda: 0.03858654 function: -276.113 Jacobian -1.205863 SSE 116.4093 
lambda: 0.04049635 function: -276.1069 Jacobian -1.333177 SSE 116.2988 
lambda: 0.04048367 function: -276.1069 Jacobian -1.332309 SSE 116.2995 
lambda: 0.04048719 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.0404872 function: -276.1069 Jacobian -1.33255 SSE 116.2993 
lambda: 0.04048723 function: -276.1069 Jacobian -1.332553 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0 function: -278.7288 Jacobian 0 SSE 119.6191 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048745 function: -276.1069 Jacobian -1.332568 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048696 function: -276.1069 Jacobian -1.332534 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048745 function: -276.1069 Jacobian -1.332568 SSE 116.2993 
lambda: 0.04048745 function: -276.1069 Jacobian -1.332568 SSE 116.2993 
lambda: 0.04048745 function: -276.1069 Jacobian -1.332568 SSE 116.2993 
lambda: 0.04048745 function: -276.1069 Jacobian -1.332568 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
lambda: 0.04048721 function: -276.1069 Jacobian -1.332551 SSE 116.2993 
   user  system elapsed 
  0.257   0.002   0.259 
> summary(esar1M)

Call: 
spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata, 
    listw = listw_NY, family = "SAR", method = "Matrix", verbose = TRUE)

Residuals:
     Min       1Q   Median       3Q      Max 
-1.56754 -0.38239 -0.02643  0.33109  4.01219 

Coefficients: 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) -0.618193   0.176784 -3.4969 0.0004707
PEXPOSURE    0.071014   0.042051  1.6888 0.0912635
PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09
PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930

Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026 
Numerical Hessian standard error of lambda: 0.017085 

Log likelihood: -276.1069 
ML residual variance (sigma squared): 0.41388, (sigma: 0.64333)
Number of observations: 281 
Number of parameters estimated: 6 
AIC: 564.21

> ## Not run: 
> ##D system.time(esar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
> ##D  data=nydata, listw=listw_NY, family="SAR", method="Matrix", verbose=TRUE,
> ##D  control=list(super=TRUE)))
> ##D summary(esar1M)
> ##D esar1wf <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=POP8, family="SAR", method="eigen")
> ##D summary(esar1wf)
> ##D system.time(esar1wM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
> ##D  data=nydata, listw=listw_NY, weights=POP8, family="SAR", method="Matrix"))
> ##D summary(esar1wM)
> ##D esar1wlu <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=POP8, family="SAR", method="LU")
> ##D summary(esar1wlu)
> ##D esar1wch <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=POP8, family="SAR", method="Chebyshev")
> ##D summary(esar1wch)
> ##D ecar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, family="CAR", method="eigen")
> ##D summary(ecar1f)
> ##D system.time(ecar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
> ##D  data=nydata, listw=listw_NY, family="CAR", method="Matrix"))
> ##D summary(ecar1M)
> ##D ecar1wf <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,
> ##D  listw=listw_NY, weights=nydata$POP8, family="CAR", method="eigen")
> ##D summary(ecar1wf)
> ##D system.time(ecar1wM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
> ##D  data=nydata, listw=listw_NY, weights=POP8, family="CAR", method="Matrix"))
> ##D summary(ecar1wM)
> ##D example(nc.sids)
> ##D ft.SID74 <- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +
> ##D  sqrt((nc.sids$SID74+1)/nc.sids$BIR74))
> ##D lm_nc <- lm(ft.SID74 ~ 1)
> ##D sids.nhbr30 <- dnearneigh(cbind(nc.sids$east, nc.sids$north), 0, 30, row.names=row.names(nc.sids))
> ##D sids.nhbr30.dist <- nbdists(sids.nhbr30, cbind(nc.sids$east, nc.sids$north))
> ##D sids.nhbr <- listw2sn(nb2listw(sids.nhbr30, glist=sids.nhbr30.dist, style="B", zero.policy=TRUE))
> ##D dij <- sids.nhbr[,3]
> ##D n <- nc.sids$BIR74
> ##D el1 <- min(dij)/dij
> ##D el2 <- sqrt(n[sids.nhbr$to]/n[sids.nhbr$from])
> ##D sids.nhbr$weights <- el1*el2
> ##D sids.nhbr.listw <- sn2listw(sids.nhbr)
> ##D both <- factor(paste(nc.sids$L_id, nc.sids$M_id, sep=":"))
> ##D ft.NWBIR74 <- sqrt(1000)*(sqrt(nc.sids$NWBIR74/nc.sids$BIR74) +
> ##D  sqrt((nc.sids$NWBIR74+1)/nc.sids$BIR74))
> ##D mdata <- data.frame(both, ft.NWBIR74, ft.SID74, BIR74=nc.sids$BIR74)
> ##D outl <- which.max(rstandard(lm_nc))
> ##D as.character(nc.sids$names[outl])
> ##D mdata.4 <- mdata[-outl,]
> ##D W <- listw2mat(sids.nhbr.listw)
> ##D W.4 <- W[-outl, -outl]
> ##D sids.nhbr.listw.4 <- mat2listw(W.4)
> ##D esarI <- errorsarlm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,
> ##D  zero.policy=TRUE)
> ##D summary(esarI)
> ##D esarIa <- spautolm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,
> ##D  family="SAR")
> ##D summary(esarIa)
> ##D esarIV <- errorsarlm(ft.SID74 ~ ft.NWBIR74, data=mdata, listw=sids.nhbr.listw,
> ##D  zero.policy=TRUE)
> ##D summary(esarIV)
> ##D esarIVa <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata, listw=sids.nhbr.listw,
> ##D  family="SAR")
> ##D summary(esarIVa)
> ##D esarIaw <- spautolm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,
> ##D  weights=BIR74, family="SAR")
> ##D summary(esarIaw)
> ##D esarIIaw <- spautolm(ft.SID74 ~ both - 1, data=mdata, listw=sids.nhbr.listw,
> ##D  weights=BIR74, family="SAR")
> ##D summary(esarIIaw)
> ##D esarIVaw <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata,
> ##D  listw=sids.nhbr.listw, weights=BIR74, family="SAR")
> ##D summary(esarIVaw)
> ##D ecarIaw <- spautolm(ft.SID74 ~ 1, data=mdata.4, listw=sids.nhbr.listw.4,
> ##D  weights=BIR74, family="CAR")
> ##D summary(ecarIaw)
> ##D ecarIIaw <- spautolm(ft.SID74 ~ both - 1, data=mdata.4,
> ##D  listw=sids.nhbr.listw.4, weights=BIR74, family="CAR")
> ##D summary(ecarIIaw)
> ##D ecarIVaw <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata.4,
> ##D  listw=sids.nhbr.listw.4, weights=BIR74, family="CAR")
> ##D summary(ecarIVaw)
> ##D nc.sids$fitIV <- append(fitted.values(ecarIVaw), NA, outl-1)
> ##D spplot(nc.sids, c("fitIV"), cuts=12) # Cressie 1993, p. 565
> ##D data(oldcol)
> ##D COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
> ##D  nb2listw(COL.nb, style="W"))
> ##D summary(COL.errW.eig)
> ##D COL.errW.sar <- spautolm(CRIME ~ INC + HOVAL, data=COL.OLD,
> ##D  nb2listw(COL.nb, style="W"))
> ##D summary(COL.errW.sar)
> ##D data(boston)
> ##D gp1 <- spautolm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2)
> ##D  + I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT), 
> ##D  data=boston.c, nb2listw(boston.soi), family="SMA")
> ##D summary(gp1)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spautolm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:foreign’

> nameEx("spweights.constants")
> ### * spweights.constants
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spweights.constants
> ### Title: Provides constants for spatial weights matrices
> ### Aliases: spweights.constants Szero
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> B <- spweights.constants(nb2listw(COL.nb, style="B"))
> W <- spweights.constants(nb2listw(COL.nb, style="W"))
> C <- spweights.constants(nb2listw(COL.nb, style="C"))
> S <- spweights.constants(nb2listw(COL.nb, style="S"))
> U <- spweights.constants(nb2listw(COL.nb, style="U"))
> print(data.frame(rbind(unlist(B), unlist(W), unlist(C), unlist(S), unlist(U)),
+   row.names=c("B", "W", "C", "S", "U")))
   n n1 n2 n3   nn  S0           S1           S2
B 49 48 47 46 2401 232 464.00000000 5.136000e+03
W 49 48 47 46 2401  49  23.29434146 2.048729e+02
C 49 48 47 46 2401  49  20.69827586 2.291085e+02
S 49 48 47 46 2401  49  21.25561347 2.134568e+02
U 49 48 47 46 2401   1   0.00862069 9.542212e-02
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spweights.constants", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ssw")
> ### * ssw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ssw
> ### Title: Compute the sum of dissimilarity
> ### Aliases: ssw
> ### Keywords: cluster multivariate
> 
> ### ** Examples
> 
> data(USArrests)
> n <- nrow(USArrests)
> ssw(USArrests, 1:n)
[1] 3701.394
> ssw(USArrests, 1:(n/2))
[1] 1910.214
> ssw(USArrests, (n/2+1):n)
[1] 1625.882
> ssw(USArrests, 1:(n/2)) + ssw(USArrests, (n/2+1):n)
[1] 3536.096
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ssw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stsls")
> ### * stsls
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stsls
> ### Title: Generalized spatial two stage least squares
> ### Aliases: stsls print.stsls print.summary.stsls summary.stsls
> ###   residuals.stsls coef.stsls deviance.stsls
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb))
> summary(COL.lag.eig, correlation=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb))

Residuals:
      Min        1Q    Median        3Q       Max 
-37.68585  -5.35636   0.05421   6.02013  23.20555 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 45.079251   7.177347  6.2808 3.369e-10
INC         -1.031616   0.305143 -3.3808 0.0007229
HOVAL       -0.265926   0.088499 -3.0049 0.0026570

Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588
Asymptotic standard error: 0.11768
    z-value: 3.6626, p-value: 0.00024962
Wald statistic: 13.415, p-value: 0.00024962

Log likelihood: -182.3904 for lag model
ML residual variance (sigma squared): 95.494, (sigma: 9.7721)
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 374.78, (AIC for lm: 382.75)
LM test for residual autocorrelation
test value: 0.31955, p-value: 0.57188

 Correlation of coefficients 
            sigma rho   (Intercept) INC  
rho         -0.14                        
(Intercept)  0.12 -0.83                  
INC         -0.05  0.35 -0.61            
HOVAL       -0.01  0.08 -0.25       -0.44

> COL.lag.stsls <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb))
> summary(COL.lag.stsls, correlation=TRUE)

Call:
stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb))

Residuals:
      Min        1Q    Median        3Q       Max 
-37.86437  -5.65096  -0.13669   6.23315  22.90823 

Coefficients: 
             Estimate Std. Error t value  Pr(>|t|)
Rho          0.454567   0.185118  2.4555  0.014067
(Intercept) 43.793442  10.952229  3.9986 6.372e-05
INC         -1.000716   0.383858 -2.6070  0.009134
HOVAL       -0.265489   0.091852 -2.8904  0.003847

Residual variance (sigma squared): 103.44, (sigma: 10.171)

Correlation of Coefficients:
     [,1]  [,2]  [,3] 
[1,] -0.92            
[2,]  0.63 -0.76      
[3,]  0.04 -0.16 -0.36

> COL.lag.stslsW <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb), W2X=FALSE)
> summary(COL.lag.stslsW, correlation=TRUE)

Call:
stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    W2X = FALSE)

Residuals:
       Min         1Q     Median         3Q        Max 
-37.785778  -5.442414  -0.052649   6.170104  23.039123 

Coefficients: 
             Estimate Std. Error t value  Pr(>|t|)
Rho          0.444202   0.189141  2.3485  0.018848
(Intercept) 44.359512  11.157079  3.9759 7.011e-05
INC         -1.014319   0.387469 -2.6178  0.008850
HOVAL       -0.265681   0.091954 -2.8893  0.003861

Residual variance (sigma squared): 103.67, (sigma: 10.182)

Correlation of Coefficients:
     [,1]  [,2]  [,3] 
[1,] -0.93            
[2,]  0.64 -0.77      
[3,]  0.04 -0.16 -0.36

> COL.lag.stslsR <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb),
+ robust=TRUE, W2X=FALSE)
> summary(COL.lag.stslsR, correlation=TRUE)

Call:
stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    robust = TRUE, W2X = FALSE)

Residuals:
       Min         1Q     Median         3Q        Max 
-37.785778  -5.442414  -0.052649   6.170104  23.039123 

Coefficients: 
            Estimate HC0 std. Error z value  Pr(>|z|)
Rho          0.44420        0.13748  3.2310  0.001234
(Intercept) 44.35951        7.67306  5.7812 7.417e-09
INC         -1.01432        0.44113 -2.2993  0.021486
HOVAL       -0.26568        0.17353 -1.5311  0.125752

Residual variance (sigma squared): 103.67, (sigma: 10.182)

Correlation of Coefficients:
     [,1]  [,2]  [,3] 
[1,] -0.90            
[2,]  0.15 -0.28      
[3,]  0.24 -0.24 -0.83

> COL.lag.stslsRl <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, nb2listw(COL.nb),
+ robust=TRUE, legacy=TRUE, W2X=FALSE)
> summary(COL.lag.stslsRl, correlation=TRUE)

Call:
stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    robust = TRUE, legacy = TRUE, W2X = FALSE)

Residuals:
       Min         1Q     Median         3Q        Max 
-38.654607  -5.141303  -0.065221   5.864384  23.671589 

Coefficients: 
            Estimate HC0 std. Error z value  Pr(>|z|)
Rho          0.40138        0.13554  2.9613  0.003064
(Intercept) 47.37696        7.49975  6.3171 2.664e-10
INC         -1.15183        0.43490 -2.6485  0.008085
HOVAL       -0.25047        0.17333 -1.4450  0.148461

Asymptotic robust residual variance: 96.446, (sigma: 9.8207)

Correlation of Coefficients:
            Rho   (Intercept) INC  
(Intercept) -0.89                  
INC          0.12 -0.26            
HOVAL        0.25 -0.26       -0.83

> data(boston)
> gp2a <- stsls(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2) +
+   AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
+  data=boston.c, nb2listw(boston.soi))
> summary(gp2a)

Call:stsls(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + 
    I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + 
    log(LSTAT), data = boston.c, listw = nb2listw(boston.soi))

Residuals:
       Min         1Q     Median         3Q        Max 
-0.5356002 -0.0758562 -0.0045074  0.0719613  0.7128012 

Coefficients: 
               Estimate  Std. Error  t value  Pr(>|t|)
Rho          4.5925e-01  3.8485e-02  11.9330 < 2.2e-16
(Intercept)  2.4025e+00  2.1710e-01  11.0661 < 2.2e-16
CRIM        -7.3557e-03  1.0345e-03  -7.1100 1.160e-12
ZN           3.6435e-04  3.9311e-04   0.9268 0.3540112
INDUS        1.1992e-03  1.8365e-03   0.6530 0.5137794
CHAS1        1.1929e-02  2.6632e-02   0.4479 0.6542202
I(NOX^2)    -2.8874e-01  9.2546e-02  -3.1199 0.0018091
I(RM^2)      6.6991e-03  1.0192e-03   6.5728 4.938e-11
AGE         -2.5810e-04  4.0940e-04  -0.6304 0.5284073
log(DIS)    -1.6043e-01  2.6107e-02  -6.1451 7.993e-10
log(RAD)     7.1704e-02  1.4926e-02   4.8038 1.557e-06
TAX         -3.6857e-04  9.5315e-05  -3.8668 0.0001103
PTRATIO     -1.2957e-02  4.1334e-03  -3.1347 0.0017203
B            2.8845e-04  8.0266e-05   3.5937 0.0003261
log(LSTAT)  -2.3984e-01  2.2470e-02 -10.6740 < 2.2e-16

Residual variance (sigma squared): 0.020054, (sigma: 0.14161)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stsls", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("subset.listw")
> ### * subset.listw
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: subset.listw
> ### Title: Subset a spatial weights list
> ### Aliases: subset.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> to.be.dropped <- c(31, 34, 36, 39, 42, 46)
> pre <- nb2listw(col.gal.nb)
> print(pre)
Characteristics of weights list object:
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 

Weights style: W 
Weights constants summary:
   n   nn S0       S1       S2
W 49 2401 49 23.48489 204.6687
> post <- subset(pre, !(1:length(col.gal.nb) %in% to.be.dropped))
> print(post)
Characteristics of weights list object:
Neighbour list object:
Number of regions: 43 
Number of nonzero links: 212 
Percentage nonzero weights: 11.46566 
Average number of links: 4.930233 

Weights style: W 
Weights constants summary:
   n   nn S0       S1       S2
W 43 1849 43 19.26584 178.4604
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("subset.listw", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("subset.nb")
> ### * subset.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: subset.nb
> ### Title: Subset a neighbours list
> ### Aliases: subset.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> plot(col.gal.nb, coords)
> to.be.dropped <- c(31, 34, 36, 39, 42, 46)
> text(coords[to.be.dropped,1], coords[to.be.dropped,2], labels=to.be.dropped,
+   pos=2, offset=0.3)
> sub.col.gal.nb <- subset(col.gal.nb,
+   !(1:length(col.gal.nb) %in% to.be.dropped))
> plot(sub.col.gal.nb, coords[-to.be.dropped,], col="red", add=TRUE)
> which(!(attr(col.gal.nb, "region.id") %in%
+   attr(sub.col.gal.nb, "region.id")))
[1] 31 34 36 39 42 46
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("subset.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("summary.nb")
> ### * summary.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary.nb
> ### Title: Print and summary function for neighbours and weights lists
> ### Aliases: summary.nb print.nb summary.listw print.listw
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> col.gal.nb
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
> summary(col.gal.nb, coords)
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Link number distribution:

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 2 links
1 most connected region:
20 with 10 links
Summary of link distances:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1276  0.3613  0.4566  0.4694  0.5536  0.8924 

  The decimal point is 1 digit(s) to the left of the |

  1 | 3344
  1 | 99
  2 | 000011333344
  2 | 556677779999
  3 | 000011222222223344444444
  3 | 556666777777888888889999999999
  4 | 00001111112233333333334444
  4 | 55666666666666777777777788888899
  5 | 0011112222222222222233334444
  5 | 556666667788
  6 | 000000112244
  6 | 5577889999
  7 | 11112244
  7 | 557777
  8 | 1144
  8 | 55999999

> col.listw <- nb2listw(col.gal.nb, style="W")
> col.listw
Characteristics of weights list object:
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 

Weights style: W 
Weights constants summary:
   n   nn S0       S1       S2
W 49 2401 49 23.48489 204.6687
> summary(col.listw)
Characteristics of weights list object:
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 230 
Percentage nonzero weights: 9.579342 
Average number of links: 4.693878 
Link number distribution:

 2  3  4  5  6  7  8  9 10 
 7  7 13  4  9  6  1  1  1 
7 least connected regions:
1 6 31 39 42 46 47 with 2 links
1 most connected region:
20 with 10 links

Weights style: W 
Weights constants summary:
   n   nn S0       S1       S2
W 49 2401 49 23.48489 204.6687
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summary.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("summary.sarlm")
> ### * summary.sarlm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary.sarlm
> ### Title: summary method for class sarlm
> ### Aliases: summary.sarlm print.sarlm print.summary.sarlm
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(oldcol)
> COL.mix.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb), type="mixed", method="eigen")
> summary(COL.mix.eig, correlation=TRUE, Nagelkerke=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    type = "mixed", method = "eigen")

Residuals:
      Min        1Q    Median        3Q       Max 
-37.47829  -6.46731  -0.33835   6.05200  22.62969 

Type: mixed 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 42.822415  12.667205  3.3806 0.0007233
INC         -0.914223   0.331094 -2.7612 0.0057586
HOVAL       -0.293738   0.089212 -3.2926 0.0009927
lag.INC     -0.520284   0.565129 -0.9206 0.3572355
lag.HOVAL    0.245640   0.178917  1.3729 0.1697756

Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494
Asymptotic standard error: 0.15623
    z-value: 2.7288, p-value: 0.0063561
Wald statistic: 7.4465, p-value: 0.0063561

Log likelihood: -181.3935 for mixed model
ML residual variance (sigma squared): 91.791, (sigma: 9.5808)
Nagelkerke pseudo-R-squared: 0.6494 
Number of observations: 49 
Number of parameters estimated: 7 
AIC: 376.79, (AIC for lm: 380.16)
LM test for residual autocorrelation
test value: 0.28919, p-value: 0.59074

 Correlation of coefficients 
            sigma rho   (Intercept) INC   HOVAL lag.INC
rho         -0.18                                      
(Intercept)  0.16 -0.89                                
INC         -0.03  0.14 -0.19                          
HOVAL        0.02 -0.09  0.03       -0.45              
lag.INC     -0.09  0.49 -0.53       -0.36  0.05        
lag.HOVAL   -0.04  0.19 -0.36        0.19 -0.24 -0.41  

> COL.mix.M <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+  nb2listw(COL.nb), type="mixed", method="Matrix")
> summary(COL.mix.M, correlation=TRUE, Nagelkerke=TRUE)

Call:
lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb), 
    type = "mixed", method = "Matrix")

Residuals:
      Min        1Q    Median        3Q       Max 
-37.47829  -6.46731  -0.33835   6.05200  22.62969 

Type: mixed 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 42.822413  12.667204  3.3806 0.0007233
INC         -0.914223   0.331094 -2.7612 0.0057586
HOVAL       -0.293738   0.089212 -3.2926 0.0009927
lag.INC     -0.520283   0.565129 -0.9206 0.3572355
lag.HOVAL    0.245640   0.178917  1.3729 0.1697756

Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494
Asymptotic standard error: 0.15623
    z-value: 2.7288, p-value: 0.0063561
Wald statistic: 7.4465, p-value: 0.0063561

Log likelihood: -181.3935 for mixed model
ML residual variance (sigma squared): 91.791, (sigma: 9.5808)
Nagelkerke pseudo-R-squared: 0.6494 
Number of observations: 49 
Number of parameters estimated: 7 
AIC: 376.79, (AIC for lm: 380.16)
LM test for residual autocorrelation
test value: 0.28919, p-value: 0.59074

 Correlation of coefficients 
            sigma rho   (Intercept) INC   HOVAL lag.INC
rho         -0.18                                      
(Intercept)  0.16 -0.89                                
INC         -0.03  0.14 -0.19                          
HOVAL        0.02 -0.09  0.03       -0.45              
lag.INC     -0.09  0.49 -0.53       -0.36  0.05        
lag.HOVAL   -0.04  0.19 -0.36        0.19 -0.24 -0.41  

> COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,
+   nb2listw(COL.nb, style="W"), method="eigen")
> summary(COL.errW.eig, correlation=TRUE, Nagelkerke=TRUE, Hausman=TRUE)

Call:
errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = nb2listw(COL.nb, 
    style = "W"), method = "eigen")

Residuals:
      Min        1Q    Median        3Q       Max 
-34.81174  -6.44031  -0.72142   7.61476  23.33626 

Type: error 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value  Pr(>|z|)
(Intercept) 59.893219   5.366163 11.1613 < 2.2e-16
INC         -0.941312   0.330569 -2.8476 0.0044057
HOVAL       -0.302250   0.090476 -3.3407 0.0008358

Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945
Asymptotic standard error: 0.13387
    z-value: 4.1966, p-value: 2.7098e-05
Wald statistic: 17.611, p-value: 2.7098e-05

Log likelihood: -183.3805 for error model
ML residual variance (sigma squared): 95.575, (sigma: 9.7762)
Nagelkerke pseudo-R-squared: 0.61978 
Number of observations: 49 
Number of parameters estimated: 5 
AIC: 376.76, (AIC for lm: 382.75)
Hausman test: 4.902, df: 3, p-value: 0.17911

 Correlation of coefficients 
            sigma lambda (Intercept) INC  
lambda      -0.24                         
(Intercept)  0.00  0.00                   
INC          0.00  0.00  -0.56            
HOVAL        0.00  0.00  -0.26       -0.45

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summary.sarlm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("testnb")
> ### * testnb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: is.symmetric.nb
> ### Title: Test a neighbours list for symmetry
> ### Aliases: is.symmetric.nb sym.attr.nb make.sym.nb old.make.sym.nb
> ###   is.symmetric.glist
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> ind <- sapply(slot(columbus, "polygons"), function(x) slot(x, "ID"))
> print(is.symmetric.nb(col.gal.nb, verbose=TRUE, force=TRUE))
[1] TRUE
> k4 <- knn2nb(knearneigh(coords, k=4), row.names=ind)
> k4 <- sym.attr.nb(k4)
> print(is.symmetric.nb(k4))
[1] FALSE
> k4.sym <- make.sym.nb(k4)
> print(is.symmetric.nb(k4.sym))
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("testnb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("tolerance.nb")
> ### * tolerance.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tolerance.nb
> ### Title: Function to construct edges based on a tolerance angle and a
> ###   maximum distance
> ### Aliases: tolerance.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> set.seed(1)
> ex.data<-cbind(runif(50),rexp(50))
> 
> ### Construct object of class nb with a tolerance angle of 30 degrees
> ### and a maximum distance of 2 m.
> nb.ex<-tolerance.nb(ex.data, unit.angle = "degrees", max.dist=1,
+  tolerance = 30)
> 
> ### Construct object of class nb with a tolerance angle of 30 degrees
> ### and a maximum distance of 2 m. The coordinates are rotated at an angle
> ### of 45 degrees counterclockwise.
> nb.ex2<-tolerance.nb(ex.data, unit.angle = "degrees", max.dist=1,
+  tolerance = 30, rot.angle = 45)
> 
> ### Construct object of class nb with a tolerance angle of pi/8 radians
> ### and a maximum distance of 1.5 m. The coordinates are rotated at
> ### an angle of pi/4 radians clockwise.
> nb.ex3<-tolerance.nb(ex.data, unit.angle = "radians", max.dist=1.5,
+  tolerance = pi/8, rot.angle = -pi*2/3)
> 
> par(mfrow=c(1,3))
> plot(nb.ex,ex.data,asp=1)
> plot(nb.ex2,ex.data,asp=1)
> plot(nb.ex3,ex.data,asp=1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tolerance.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("trW")
> ### * trW
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: trW
> ### Title: Spatial weights matrix powers traces
> ### Aliases: trW mom_calc mom_calc_int2
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> listw <- nb2listw(col.gal.nb)
> W <- as(listw, "CsparseMatrix")
> system.time(trMat <- trW(W, type="mult"))
   user  system elapsed 
   0.01    0.00    0.01 
> str(trMat)
 atomic [1:30] 0 10.91 3.65 5.62 3.66 ...
 - attr(*, "timings")= Named num [1:2] 0.01 0.01
  ..- attr(*, "names")= chr [1:2] "user.self" "elapsed"
 - attr(*, "type")= chr "mult"
> set.seed(1100)
> system.time(trMC <- trW(W, type="MC"))
   user  system elapsed 
   0.01    0.00    0.01 
> str(trMC)
 atomic [1:30] 0 10.91 3.69 5.36 3.64 ...
 - attr(*, "sd")= num [1:30] NA NA 0.598 0.495 0.489 ...
 - attr(*, "timings")= Named num [1:2] 0.01 0.01
  ..- attr(*, "names")= chr [1:2] "user.self" "elapsed"
 - attr(*, "type")= chr "MC"
> plot(trMat, trMC)
> abline(a=0, b=1)
> for(i in 3:length(trMC)) {
+  segments(trMat[i], trMC[i]-2*attr(trMC, "sd")[i], trMat[i],
+   trMC[i]+2*attr(trMC, "sd")[i])
+ }
> listwS <- similar.listw(listw)
> W <- forceSymmetric(as(listwS, "CsparseMatrix"))
> system.time(trmom <- trW(W, m=24, type="moments"))
   user  system elapsed 
  0.009   0.000   0.010 
> str(trmom)
 atomic [1:24] 0 10.91 3.65 5.62 3.66 ...
 - attr(*, "timings")= Named num [1:2] 0.009 0.01
  ..- attr(*, "names")= chr [1:2] "user.self" "elapsed"
 - attr(*, "type")= chr "moments"
> all.equal(trMat[1:24], trmom, check.attributes=FALSE)
[1] TRUE
> system.time(trMat <- trW(W, m=24, type="mult"))
   user  system elapsed 
  0.009   0.000   0.009 
> str(trMat)
 atomic [1:24] 0 10.91 3.65 5.62 3.66 ...
 - attr(*, "timings")= Named num [1:2] 0.009 0.009
  ..- attr(*, "names")= chr [1:2] "user.self" "elapsed"
 - attr(*, "type")= chr "mult"
> all.equal(trMat, trmom, check.attributes=FALSE)
[1] TRUE
> set.seed(1)
> system.time(trMC <- trW(W, m=24, type="MC"))
   user  system elapsed 
  0.011   0.000   0.010 
> str(trMC)
 atomic [1:24] 0 10.91 2.44 4.97 2.82 ...
 - attr(*, "sd")= num [1:24] NA NA 0.618 0.501 0.451 ...
 - attr(*, "timings")= Named num [1:2] 0.011 0.01
  ..- attr(*, "names")= chr [1:2] "user.self" "elapsed"
 - attr(*, "type")= chr "MC"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("trW", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("tri2nb")
> ### * tri2nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tri2nb
> ### Title: Neighbours list from tri object
> ### Aliases: tri2nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> coords <- coordinates(columbus)
> ind <- sapply(slot(columbus, "polygons"), function(x) slot(x, "ID"))
> col.tri.nb <- tri2nb(coords, row.names=ind)
> plot(columbus, border="grey")
> plot(col.tri.nb, coords, add=TRUE)
> title(main="Raw triangulation links")
> x <- seq(0,1,0.1)
> y <- seq(0,2,0.2)
> xy <- expand.grid(x, y)
> try(xy.nb <- tri2nb(xy))
> seed <- 1234
> xid <- sample(1:nrow(xy))
> xy.nb <- tri2nb(xy[xid,])
> plot(xy.nb, xy[xid,])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tri2nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("used.cars")
> ### * used.cars
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: used.cars
> ### Title: US 1960 used car prices
> ### Aliases: used.cars usa48.nb
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(used.cars)
> moran.test(used.cars$price.1960, nb2listw(usa48.nb))

	Moran's I test under randomisation

data:  used.cars$price.1960  
weights: nb2listw(usa48.nb)  

Moran I statistic standard deviate = 8.1752, p-value < 2.2e-16
alternative hypothesis: greater
sample estimates:
Moran I statistic       Expectation          Variance 
      0.783561543      -0.021276596       0.009692214 

> moran.plot(used.cars$price.1960, nb2listw(usa48.nb),
+   labels=rownames(used.cars))
> uc.lm <- lm(price.1960 ~ tax.charges, data=used.cars)
> summary(uc.lm)

Call:
lm(formula = price.1960 ~ tax.charges, data = used.cars)

Residuals:
     Min       1Q   Median       3Q      Max 
-116.701  -45.053   -1.461   43.400  107.807 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)    
(Intercept) 1435.7506    27.5796  52.058  < 2e-16 ***
tax.charges    0.6872     0.1754   3.918 0.000294 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 57.01 on 46 degrees of freedom
Multiple R-squared:  0.2503,	Adjusted R-squared:  0.234 
F-statistic: 15.35 on 1 and 46 DF,  p-value: 0.0002939

> lm.morantest(uc.lm, nb2listw(usa48.nb))

	Global Moran's I for regression residuals

data:  
model: lm(formula = price.1960 ~ tax.charges, data = used.cars)
weights: nb2listw(usa48.nb)

Moran I statistic standard deviate = 6.3869, p-value = 8.466e-11
alternative hypothesis: greater
sample estimates:
Observed Moran's I        Expectation           Variance 
       0.574817771       -0.030300549        0.008976437 

> lm.morantest.sad(uc.lm, nb2listw(usa48.nb))

	Saddlepoint approximation for global Moran's I (Barndorff-Nielsen
	formula)

data:  
model:lm(formula = price.1960 ~ tax.charges, data = used.cars)
weights: nb2listw(usa48.nb)

Saddlepoint approximation = 5.6688, p-value = 7.19e-09
alternative hypothesis: greater
sample estimates:
Observed Moran's I 
         0.5748178 

> lm.LMtests(uc.lm, nb2listw(usa48.nb))

	Lagrange multiplier diagnostics for spatial dependence

data:  
model: lm(formula = price.1960 ~ tax.charges, data = used.cars)
weights: nb2listw(usa48.nb)

LMErr = 31.793, df = 1, p-value = 1.715e-08

> uc.err <- errorsarlm(price.1960 ~ tax.charges, data=used.cars,
+   nb2listw(usa48.nb), tol.solve=1.0e-13, control=list(tol.opt=.Machine$double.eps^0.3))
> summary(uc.err)

Call:errorsarlm(formula = price.1960 ~ tax.charges, data = used.cars, 
    listw = nb2listw(usa48.nb), tol.solve = 1e-13, control = list(tol.opt = .Machine$double.eps^0.3))

Residuals:
     Min       1Q   Median       3Q      Max 
-74.8241 -17.4590   2.4061  21.2784  64.5967 

Type: error 
Coefficients: (asymptotic standard errors) 
              Estimate Std. Error z value Pr(>|z|)
(Intercept) 1528.34521   31.96239 47.8170   <2e-16
tax.charges    0.08831    0.11923  0.7406   0.4589

Lambda: 0.81899, LR test value: 40.899, p-value: 1.603e-10
Asymptotic standard error: 0.074052
    z-value: 11.06, p-value: < 2.22e-16
Wald statistic: 122.32, p-value: < 2.22e-16

Log likelihood: -240.7163 for error model
ML residual variance (sigma squared): 1043.9, (sigma: 32.309)
Number of observations: 48 
Number of parameters estimated: 4 
AIC: 489.43, (AIC for lm: 528.33)

> uc.lag <- lagsarlm(price.1960 ~ tax.charges, data=used.cars,
+   nb2listw(usa48.nb), tol.solve=1.0e-13, control=list(tol.opt=.Machine$double.eps^0.3))
> summary(uc.lag)

Call:lagsarlm(formula = price.1960 ~ tax.charges, data = used.cars, 
    listw = nb2listw(usa48.nb), tol.solve = 1e-13, control = list(tol.opt = .Machine$double.eps^0.3))

Residuals:
     Min       1Q   Median       3Q      Max 
-77.6781 -16.9505   4.2498  19.5486  58.9811 

Type: lag 
Coefficients: (asymptotic standard errors) 
             Estimate Std. Error z value Pr(>|z|)
(Intercept) 309.42997  123.03283  2.5150   0.0119
tax.charges   0.16711    0.10212  1.6364   0.1018

Rho: 0.78302, LR test value: 42.681, p-value: 6.4426e-11
Asymptotic standard error: 0.081637
    z-value: 9.5914, p-value: < 2.22e-16
Wald statistic: 91.995, p-value: < 2.22e-16

Log likelihood: -239.8252 for lag model
ML residual variance (sigma squared): 1036.7, (sigma: 32.197)
Number of observations: 48 
Number of parameters estimated: 4 
AIC: 487.65, (AIC for lm: 528.33)
LM test for residual autocorrelation
test value: 2.1139, p-value: 0.14596

> uc.lag1 <- lagsarlm(price.1960 ~ 1, data=used.cars,
+   nb2listw(usa48.nb), tol.solve=1.0e-13, control=list(tol.opt=.Machine$double.eps^0.3))
> summary(uc.lag1)

Call:
lagsarlm(formula = price.1960 ~ 1, data = used.cars, listw = nb2listw(usa48.nb), 
    tol.solve = 1e-13, control = list(tol.opt = .Machine$double.eps^0.3))

Residuals:
     Min       1Q   Median       3Q      Max 
-76.1518 -18.2214   5.2489  21.6309  63.4983 

Type: lag 
Coefficients: (asymptotic standard errors) 
            Estimate Std. Error z value Pr(>|z|)
(Intercept)   263.50     109.61  2.4038  0.01622

Rho: 0.82919, LR test value: 54.202, p-value: 1.8086e-13
Asymptotic standard error: 0.070993
    z-value: 11.68, p-value: < 2.22e-16
Wald statistic: 136.42, p-value: < 2.22e-16

Log likelihood: -240.977 for lag model
ML residual variance (sigma squared): 1045.4, (sigma: 32.333)
Number of observations: 48 
Number of parameters estimated: 3 
AIC: 487.95, (AIC for lm: 540.16)
LM test for residual autocorrelation
test value: 2.1495, p-value: 0.14262

> uc.err1 <- errorsarlm(price.1960 ~ 1, data=used.cars,
+   nb2listw(usa48.nb), tol.solve=1.0e-13, control=list(tol.opt=.Machine$double.eps^0.3))
> summary(uc.err1)

Call:
errorsarlm(formula = price.1960 ~ 1, data = used.cars, listw = nb2listw(usa48.nb), 
    tol.solve = 1e-13, control = list(tol.opt = .Machine$double.eps^0.3))

Residuals:
     Min       1Q   Median       3Q      Max 
-76.1518 -18.2214   5.2489  21.6309  63.4983 

Type: error 
Coefficients: (asymptotic standard errors) 
            Estimate Std. Error z value  Pr(>|z|)
(Intercept) 1542.607     27.321  56.462 < 2.2e-16

Lambda: 0.82919, LR test value: 54.202, p-value: 1.8086e-13
Asymptotic standard error: 0.070993
    z-value: 11.68, p-value: < 2.22e-16
Wald statistic: 136.42, p-value: < 2.22e-16

Log likelihood: -240.977 for error model
ML residual variance (sigma squared): 1045.4, (sigma: 32.333)
Number of observations: 48 
Number of parameters estimated: 3 
AIC: 487.95, (AIC for lm: 540.16)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("used.cars", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("wheat")
> ### * wheat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: wheat
> ### Title: Mercer and Hall wheat yield data
> ### Aliases: wheat
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(wheat)
> ##D wheat$lat1 <- 69 - wheat$lat
> ##D wheat$r <- factor(wheat$lat1)
> ##D wheat$c <- factor(wheat$lon)
> ##D wheat_sp <- wheat
> ##D coordinates(wheat_sp) <- c("lon", "lat1")
> ##D wheat_spg <- wheat_sp
> ##D gridded(wheat_spg) <- TRUE
> ##D wheat_spl <- as(wheat_spg, "SpatialPolygons")
> ##D df <- as(wheat_spg, "data.frame")
> ##D row.names(df) <- sapply(slot(wheat_spl, "polygons"),
> ##D  function(x) slot(x, "ID"))
> ##D wheat <- SpatialPolygonsDataFrame(wheat_spl, data=df)
> ## End(Not run)
> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()
> wheat <- readShapeSpatial(system.file("etc/shapes/wheat.shp",
+  package="spdep")[1])
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("wheat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:maptools’

> nameEx("write.nb.gal")
> ### * write.nb.gal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: write.nb.gal
> ### Title: Write a neighbours list as a GAL lattice file
> ### Aliases: write.nb.gal
> ### Keywords: spatial
> 
> ### ** Examples
> 
> example(columbus)

colmbs> require(maptools)
Loading required package: maptools
Checking rgeos availability: FALSE
 	Note: when rgeos is not available, polygon geometry 	computations in maptools depend on gpclib,
 	which has a restricted licence. It is disabled by default;
 	to enable gpclib, type gpclibPermit()

colmbs> columbus <- readShapePoly(system.file("etc/shapes/columbus.shp",
colmbs+  package="spdep")[1])

colmbs> col.gal.nb <- read.gal(system.file("etc/weights/columbus.gal",
colmbs+  package="spdep")[1])
> GALfile <- tempfile("GAL")
> write.nb.gal(col.gal.nb, GALfile)
> col.queen <- read.gal(GALfile)
> summary(diffnb(col.queen, col.gal.nb))
Neighbour list object:
Number of regions: 49 
Number of nonzero links: 0 
Percentage nonzero weights: 0 
Average number of links: 0 
49 regions with no links:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
Link number distribution:

 0 
49 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("write.nb.gal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  28.135 0.466 30.201 0.003 0.003 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
