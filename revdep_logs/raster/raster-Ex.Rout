
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "raster"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "raster-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('raster')
Loading required package: sp
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Arith-methods")
> ### * Arith-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Arith-methods
> ### Title: Arithmetic with Raster* objects
> ### Aliases: Arith-methods +,SpatialPolygons,SpatialPolygons-method
> ###   +,SpatialLines,SpatialLines-method
> ###   +,SpatialPoints,SpatialPoints-method
> ###   -,SpatialPolygons,SpatialPolygons-method
> ###   *,SpatialPolygons,SpatialPolygons-method
> ### Keywords: methods math spatial
> 
> ### ** Examples
> 
> 
> r1 <- raster(ncols=10, nrows=10)
> r1[] <- runif(ncell(r1))
> r2 <- setValues(r1, 1:ncell(r1) / ncell(r1) )
> r3 <- r1 + r2
> r2 <- r1 / 10
> r3 <- r1 * (r2 - 1 + r1^2 / r2)
> 
> # recycling by row
> r4 <- r1 * 0 + 1:ncol(r1)
> 
> # multi-layer object mutiplication, no recycling
> b1 <- brick(r1, r2, r3)
> b2 <- b1 * 10
> 
> # recycling by layer
> b3 <- b1 + c(1, 5, 10)
> 
> # addition of the cell-values of two RasterBrick objects
> b3 <- b2 + b1
> 
> # summing two RasterBricks and one RasterLayer. The RasterLayer is 'recycled'
> b3 <- b1 + b2 + r1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Arith-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Compare-methods")
> ### * Compare-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Compare-methods
> ### Title: Compare Raster* objects
> ### Aliases: Compare-methods ==,BasicRaster,BasicRaster-method
> ###   !=,BasicRaster,BasicRaster-method
> ### Keywords: methods math
> 
> ### ** Examples
> 
> r1 <- raster()
> r1 <- setValues(r1, round(10 * runif(ncell(r1))))
> r2 <- setValues(r1, round(10 * runif(ncell(r1))))
> as(r1, 'BasicRaster') == as(r2, 'BasicRaster')
[1] TRUE
> r3 <- r1 == r2
> 
> b <- extent(0, 360, 0, 180)
> r4 <- setExtent(r2, b)
> as(r2, 'BasicRaster') != as(r4, 'BasicRaster')
[1] TRUE
> # The following would give an error. You cannot compare RasterLayer 
> # that do not have the same BasicRaster properties.
> #r3 <- r1 > r4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Compare-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Extent-class")
> ### * Extent-class
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Extent-class
> ### Title: Class "Extent"
> ### Aliases: Extent Extent-class show,Extent-method
> ### Keywords: classes spatial
> 
> ### ** Examples
> 
> ext <- extent(-180,180,-90,90)
> ext
class       : Extent 
xmin        : -180 
xmax        : 180 
ymin        : -90 
ymax        : 90 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Extent-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("KML")
> ### * KML
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: KML
> ### Title: Write a KML or KMZ file
> ### Aliases: KML KML,Spatial-method KML,RasterLayer-method
> ###   KML,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Meuse data from the sp package
> ##D data(meuse.grid)
> ##D b <- rasterFromXYZ(meuse.grid)
> ##D projection(b) <- "+init=epsg:28992" 				  
> ##D # transform to longitude/latitude
> ##D p <- projectRaster(b, crs="+proj=longlat +datum=WGS84", method='ngb')
> ##D KML(p, file='meuse.kml')
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("KML", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Logic-methods")
> ### * Logic-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Logic-methods
> ### Title: Logical operators and functions
> ### Aliases: Logic-methods Logic,Raster,Raster-method is.na,Raster-method
> ###   is.nan,Raster-method is.finite,Raster-method
> ###   is.infinite,Raster-method !,Raster-method
> ### Keywords: methods math
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> r[] <- runif(ncell(r)) * 10
> r1 <- r < 3 | r > 6
> r2 <- !r1
> r3 <- r >= 3 & r <= 6
> r4 <- r2 == r3
> r[r>3] <- NA
> r5 <- is.na(r)
> r[1:5]
[1] 2.655087       NA       NA       NA 2.016819
> r1[1:5]
[1] 1 0 0 1 1
> r2[1:5]
[1] 0 1 1 0 0
> r3[1:5]
[1] 0 1 1 0 0
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Logic-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Math-methods")
> ### * Math-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Math-methods
> ### Title: Mathematical functions
> ### Aliases: Math-methods log,Raster-method
> ### Keywords: spatial methods math
> 
> ### ** Examples
> 
> r1 <- raster(nrow=10, ncol=10)
> r1 <- setValues(r1, runif(ncell(r1)) * 10)
> r2 <- sqrt(r1)
> s <- stack(r1, r2) - 5
> b <- abs(s)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Math-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("NAvalue")
> ### * NAvalue
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: NAvalue
> ### Title: Set the NA value of a RasterLayer
> ### Aliases: NAvalue<- NAvalue
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r1 <- raster(system.file("external/rlogo.grd", package="raster"))
> r2 <- r1
> NAvalue(r2)
[1] -3.4e+38
> NAvalue(r2) <- 255
> #plot(r1)
> #x11()
> #plot(r2)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("NAvalue", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RGB")
> ### * RGB
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RGB
> ### Title: Create a Red-Green-Blue Raster object
> ### Aliases: RGB RGB,RasterLayer-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> x <- RGB(r)
> plot(x, col=gray(0:9/10))
> plotRGB(x)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RGB", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Raster-classes")
> ### * Raster-classes
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Raster-class
> ### Title: Raster* classes
> ### Aliases: BasicRaster-class Raster-class RasterLayer-class
> ###   RasterLayerSparse-class RasterStack-class RasterBrick-class
> ###   RasterStackBrick-class VectorLayer-class SpatialVector-class
> ###   print,Raster-method show,BasicRaster-method show,RasterLayer-method
> ###   show,RasterStack-method show,RasterBrick-method print,Spatial-method
> ### Keywords: classes spatial
> 
> ### ** Examples
> 
> showClass("RasterLayer")
Class "RasterLayer" [package "raster"]

Slots:
                                                                          
Name:              file             data           legend            title
Class:      .RasterFile .SingleLayerData    .RasterLegend        character
                                                                          
Name:            extent          rotated         rotation            ncols
Class:           Extent          logical        .Rotation          integer
                                                                          
Name:             nrows              crs          history                z
Class:          integer              CRS             list             list

Extends: 
Class "Raster", directly
Class "BasicRaster", by class "Raster", distance 2

Known Subclasses: 
Class "RasterLayerSparse", directly, with explicit coerce
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Raster-classes", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Summary-methods")
> ### * Summary-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Summary-methods
> ### Title: Summary methods
> ### Aliases: Summary-methods mean,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r1 <- raster(nrow=10, ncol=10)
> r1 <- setValues(r1, runif(ncell(r1)))
> r2 <- setValues(r1, runif(ncell(r1)))
> r3 <- setValues(r1, runif(ncell(r1)))
> r <- max(r1, r2, r3)
> r <- range(r1, r2, r3, 1.2)
> 
> s <- stack(r1, r2, r3)
> r <- mean(s, 2)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Summary-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("addLayer")
> ### * addLayer
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: addLayer
> ### Title: Add or drop a layer
> ### Aliases: addLayer addLayer,Raster-method dropLayer
> ###   dropLayer,RasterStack-method dropLayer,RasterBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> file <- system.file("external/test.grd", package="raster")
> s <- stack(file, file, file)
> r <- raster(file)
> s <- addLayer(s, r/2, r*2)
> s
class       : RasterStack 
dimensions  : 115, 80, 9200, 5  (nrow, ncol, ncell, nlayers)
resolution  : 40, 40  (x, y)
extent      : 178400, 181600, 329400, 334000  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
names       : test.1.1, test.2.1,  test.3, test.1.2, test.2.2 
min values  :  128.434,  128.434, 128.434,   64.217,  256.868 
max values  :  1805.78,  1805.78, 1805.78,   902.89,  3611.56 

> s <- dropLayer(s, c(3, 5))
> nlayers(s)
[1] 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("addLayer", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("adjacent")
> ### * adjacent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: adjacent
> ### Title: Adjacent cells
> ### Aliases: adjacent
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrows=10, ncols=10)
> adjacent(r, cells=c(1, 55), directions=8, pairs=TRUE) 
      from to
 [1,]   55 44
 [2,]    1 10
 [3,]   55 54
 [4,]    1 20
 [5,]   55 64
 [6,]   55 46
 [7,]    1  2
 [8,]   55 56
 [9,]    1 12
[10,]   55 66
[11,]   55 45
[12,]    1 11
[13,]   55 65
> 
> a <- adjacent(r, cell = c(1,55,90), directions=4, sorted=TRUE) 
> a
      from  to
 [1,]    1   2
 [2,]    1  10
 [3,]    1  11
 [4,]   55  45
 [5,]   55  54
 [6,]   55  56
 [7,]   55  65
 [8,]   90  80
 [9,]   90  81
[10,]   90  89
[11,]   90 100
> 
> r[c(1,55,90)] <- 1
> r[a] <- 2
> plot(r)
> 
> # same result as above
> rook <- matrix(c(NA, 1, NA, 
+                   1, 0,  1, 
+                  NA, 1, NA), ncol=3, byrow=TRUE)
> 
> adjacent(r, cells = c(1,55,90), directions=rook, sorted=TRUE) 
      from  to
 [1,]    1   2
 [2,]    1  10
 [3,]    1  11
 [4,]   55  45
 [5,]   55  54
 [6,]   55  56
 [7,]   55  65
 [8,]   90  80
 [9,]   90  81
[10,]   90  89
[11,]   90 100
> 
> 
> # Count the number of times that a cell with a certain value
> # occurs next to a cell with a certain value
> set.seed(0)
> r <- raster(ncol=10, nrow=10)
> r[] <- round(runif(ncell(r)) * 5)
> a <- adjacent(r, 1:ncell(r), 4, pairs=TRUE)
> tb <- table(r[a[,1]], r[a[,2]])
> tb
   
     0  1  2  3  4  5
  0  2  4  7  4 10  0
  1  4 14 14  7 19  6
  2  7 14 30 15 35  8
  3  4  7 15 14 13  3
  4 10 19 35 13 20  5
  5  0  6  8  3  5  0
> plot(raster(tb[], xmn=-0.5, xmx=5.5, ymn=-0.5, ymx=5.5))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("adjacent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aggregate")
> ### * aggregate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aggregate
> ### Title: Aggregate raster cells or polygons
> ### Aliases: aggregate aggregate,Raster-method
> ###   aggregate,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster()
> # a new aggregated raster, no values
> ra <- aggregate(r, fact=10)
> r <- setValues(r, runif(ncell(r)))
> 
> # a new aggregated raster, max of the values
> ra <- aggregate(r, fact=10, fun=max)
> 
> # multiple layers
> s <- stack(r, r*2)
> x <- aggregate(s,2)
> 
> #SpatialPolygons
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	p
+ 	pa0 <- aggregate(p)
+ 	pa0
+ 	pa1 <- aggregate(p, vars='NAME_1', sums=list(list(mean, 'ID_2')))
+ 	pa1
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

class       : SpatialPolygonsDataFrame 
features    : 3 
extent      : 5.74414, 6.528252, 49.44781, 50.18162  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
variables   : 2
names       :     NAME_1,     ID_2 
min values  :   Diekirch, 3.000000 
max values  : Luxembourg, 9.500000 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aggregate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("alignExtent")
> ### * alignExtent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: alignExtent
> ### Title: Align an extent (object of class Extent)
> ### Aliases: alignExtent
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> e <- extent(-10.1, 9.9, -20.1, 19.9)
> ea <- alignExtent(e, r)
> e
class       : Extent 
xmin        : -10.1 
xmax        : 9.9 
ymin        : -20.1 
ymax        : 19.9 
> extent(r)
class       : Extent 
xmin        : -180 
xmax        : 180 
ymin        : -90 
ymax        : 90 
> ea
class       : Extent 
xmin        : -10 
xmax        : 10 
ymin        : -20 
ymax        : 20 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("alignExtent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("animate")
> ### * animate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: animate
> ### Title: Animate layers of a Raster* object
> ### Aliases: animate animate,RasterStackBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> animate(b, n=1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("animate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("approxNA")
> ### * approxNA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: approxNA
> ### Title: Estimate values for cell values that are 'NA' by interpolating
> ###   between layers
> ### Aliases: approxNA approxNA,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=5, nrows=5)
> r1 <- setValues(r, runif(ncell(r)))
> r2 <- setValues(r, runif(ncell(r)))
> r3 <- setValues(r, runif(ncell(r)))
> r4 <- setValues(r, runif(ncell(r)))
> r5 <- setValues(r, NA)
> r6 <- setValues(r, runif(ncell(r)))
> r1[6:10] <- NA
> r2[5:15] <- NA
> r3[8:25] <- NA
> s <- stack(r1,r2,r3,r4,r5,r6)
> s[1:5] <- NA
> x1 <- approxNA(s)
> x2 <- approxNA(s, rule=2)
> x3 <- approxNA(s, rule=2, z=c(1,2,3,5,14,15))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("approxNA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("area")
> ### * area
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: area
> ### Title: Size of cells
> ### Aliases: area area,RasterLayer-method area,RasterStackBrick-method
> ###   area,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> 
> r <- raster(nrow=18, ncol=36)
> a <- area(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("area", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.data.frame")
> ### * as.data.frame
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.data.frame
> ### Title: Get a data.frame with raster cell values, or coerce
> ###   SpatialPolygons, Lines, or Points to a data.frame
> ### Aliases: as.data.frame as.data.frame,Raster-method
> ###   as.data.frame,SpatialPolygons-method
> ###   as.data.frame,SpatialLines-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(ncol=3, nrow=3)
> r[] <- sqrt(1:ncell(r))
> r[3:5] <- NA
> as.data.frame(r)
     layer
1 1.000000
2 1.414214
3       NA
4       NA
5       NA
6 2.449490
7 2.645751
8 2.828427
9 3.000000
> s <- stack(r, r*2)
> as.data.frame(s)
   layer.1  layer.2
1 1.000000 2.000000
2 1.414214 2.828427
3       NA       NA
4       NA       NA
5       NA       NA
6 2.449490 4.898979
7 2.645751 5.291503
8 2.828427 5.656854
9 3.000000 6.000000
> as.data.frame(s, na.rm=TRUE)
   layer.1  layer.2
1 1.000000 2.000000
2 1.414214 2.828427
6 2.449490 4.898979
7 2.645751 5.291503
8 2.828427 5.656854
9 3.000000 6.000000
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.data.frame", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.logical-methods")
> ### * as.logical-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.logical
> ### Title: Change values to logical
> ### Aliases: as.logical,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=10, ncol=10)
> r[] <- round(runif(ncell(r)))
> r <- as.logical(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.logical-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.matrix")
> ### * as.matrix
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.matrix
> ### Title: Get a matrix with raster cell values
> ### Aliases: as.vector as.matrix as.array as.array,RasterStackBrick-method
> ###   as.array,RasterLayer-method as.matrix,RasterStackBrick-method
> ###   as.matrix,RasterLayer-method as.matrix,Extent-method
> ###   as.vector,Extent-method as.vector,Raster-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(ncol=3, nrow=3)
> r[] = 1:ncell(r)
> as.matrix(r)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
> s <- stack(r,r)
> as.array(s)
, , 1

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

, , 2

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

> as.vector(extent(s))
[1] -180  180  -90   90
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.matrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.raster")
> ### * as.raster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.raster
> ### Title: Coerce to a 'raster' object
> ### Aliases: as.raster as.raster,RasterLayer-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(ncol=3, nrow=3)
> r[] <- 1:ncell(r)
> as.raster(r)
     [,1]        [,2]        [,3]       
[1,] "#F2F2F2FF" "#EFC2B3FF" "#ECB178FF"
[2,] "#E9BC3CFF" "#E6E402FF" "#A1D600FF"
[3,] "#63C600FF" "#2EB600FF" "#00A600FF"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.raster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("atan2")
> ### * atan2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: atan2
> ### Title: Two argument arc-tangent
> ### Aliases: atan2,RasterLayer,RasterLayer-method atan2
> ### Keywords: methods math
> 
> ### ** Examples
> 
> r1 <- r2 <- raster(nrow=10, ncol=10)
> r1[] <- (runif(ncell(r1))-0.5) * 10
> r2[] <- (runif(ncell(r1))-0.5) * 10
> atan2(r1, r2)
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : -3.136868, 3.097747  (min, max)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("atan2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("autocor")
> ### * autocor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: autocorrelation
> ### Title: Spatial autocorrelation
> ### Aliases: Geary Moran MoranLocal GearyLocal
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrows=10, ncols=10)
> r[] <- 1:ncell(r)
> 
> Moran(r)
[1] 0.8549569
> # Rook's case
> f <- matrix(c(0,1,0,1,0,1,0,1,0), nrow=3)
> Moran(r, f)
[1] 0.8929367
> 
> Geary(r)
[1] 0.04739631
> 
> x1 <- MoranLocal(r)
> 
> # Rook's case
> x2 <- MoranLocal(r, w=f)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("autocor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bands")
> ### * bands
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bands
> ### Title: Number of bands
> ### Aliases: bandnr bandnr,RasterLayer-method nbands
> ### Keywords: spatial
> 
> ### ** Examples
> 
> f <- system.file("external/rlogo.grd", package="raster")
> r <- raster(f, layer=2)
> nbands(r)
[1] 3
> bandnr(r)
[1] 1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bands", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("barplot")
> ### * barplot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: barplot
> ### Title: Bar plot of a RasterLayer
> ### Aliases: barplot barplot,RasterLayer-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> f <- system.file("external/test.grd", package="raster")
> r <- raster(f)
> barplot(r, digits=-2, las=2, ylab='Frequency')
> 
> op <- par(no.readonly = TRUE)
> par(mai = c(1, 2, .5, .5))
> barplot(r, breaks=10, col=c('red', 'blue'), horiz=TRUE, digits=NULL, las=1)
> par(op)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("barplot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("bind")
> ### * bind
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bind
> ### Title: Bind Spatial* objects
> ### Aliases: bind bind,SpatialPolygons,SpatialPolygons-method
> ###   bind,SpatialLines,SpatialLines-method
> ###   bind,SpatialPoints,SpatialPoints-method
> ###   bind,data.frame,data.frame-method bind,data.frame,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	mersch <- p[p$NAME_2=='Mersch', ]
+ 	diekirch <- p[p$NAME_2=='Diekirch', ]
+ 	remich <- p[p$NAME_2=='Remich', ]
+ 	remich$NAME_1 <- NULL
+ 	x <- bind(mersch, diekirch, remich)
+ 	plot(x)
+ 	data.frame(x)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

  ID_1     NAME_1 ID_2   NAME_2 AREA
1    3 Luxembourg   11   Mersch  233
2    1   Diekirch    2 Diekirch  218
3    2       <NA>    7   Remich  129
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bind", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("blockSize")
> ### * blockSize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blockSize
> ### Title: Block size for writing files
> ### Aliases: blockSize
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> blockSize(r)
$row
[1]  1 30 59 88

$nrows
[1] 29 29 29 28

$n
[1] 4

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blockSize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("boundaries")
> ### * boundaries
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: boundaries
> ### Title: boundaries (edges) detection
> ### Aliases: boundaries boundaries,RasterLayer-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=18, ncol=36, xmn=0)
> r[150:250] <- 1
> r[251:450] <- 2
> plot( boundaries(r, type='inner') )
> plot( boundaries(r, type='outer') )
> plot( boundaries(r, classes=TRUE) )
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("boundaries", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("boxplot")
> ### * boxplot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: boxplot
> ### Title: Box plot of Raster objects
> ### Aliases: boxplot boxplot,RasterLayer-method
> ###   boxplot,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r1 <- r2 <- r3 <- raster(ncol=10, nrow=10)
> r1[] <- rnorm(ncell(r1), 100, 40)
> r2[] <- rnorm(ncell(r1), 80, 10)
> r3[] <- rnorm(ncell(r1), 120, 30)
> s <- stack(r1, r2, r3)
> names(s) <- c('A', 'B', 'C')
> 
> boxplot(s, notch=TRUE, col=c('red', 'blue', 'orange'), main='Box plot', ylab='random' )
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("boxplot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("brick")
> ### * brick
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: brick
> ### Title: Create a RasterBrick object
> ### Aliases: brick brick,character-method brick,missing-method
> ###   brick,RasterLayer-method brick,RasterStack-method
> ###   brick,RasterBrick-method brick,Extent-method brick,array-method
> ###   brick,big.matrix-method brick,list-method brick,SpatialPixels-method
> ###   brick,SpatialGrid-method brick,kasc-method brick,grf-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> b
class       : RasterBrick 
dimensions  : 77, 101, 7777, 3  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=merc +ellps=WGS84 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/rlogo.grd 
names       : red, green, blue 
min values  :   0,     0,    0 
max values  : 255,   255,  255 

> nlayers(b)
[1] 3
> names(b)
[1] "red"   "green" "blue" 
> extract(b, 870)
     red green blue
[1,] 149   149  137
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("brick", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("buffer")
> ### * buffer
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: buffer
> ### Title: buffer
> ### Aliases: buffer buffer,RasterLayer-method buffer,Spatial-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=36,nrow=18)
> r[] <- NA
> r[500] <- 1
> b <- buffer(r, width=5000000) 
> #plot(b)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("buffer", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("calc")
> ### * calc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: calc
> ### Title: Calculate
> ### Aliases: calc calc,Raster,function-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=36, nrows=18)
> r[] <- 1:ncell(r)
> 
> # multiply values with 10
> fun <- function(x) { x * 10 }
> rc1 <- calc(r, fun)
> 
> # set values below 100 to NA. 
> fun <- function(x) { x[x<100] <- NA; return(x) }
> rc2 <- calc(r, fun)
> 
> # set NA values to -9999
> fun <- function(x) { x[is.na(x)] <- -9999; return(x)} 
> rc3 <- calc(rc2, fun)
> 
> # using a RasterStack as input
> s <- stack(r, r*2, sqrt(r))
> # return a RasterLayer
> rs1 <- calc(s, sum)
> 
> # return a RasterBrick
> rs2 <- calc(s, fun=function(x){x * 10})
> # recycling by layer
> rs3 <- calc(s, fun=function(x){x * c(1, 5, 10)})
> 
> # use overlay when you want to refer to indiviudal layer in the function
> # but it can be done with calc: 
> rs4 <- calc(s, fun=function(x){x[1]+x[2]*x[3]})
> 
> ## 
> # Some regression examples
> ## 
> 
> # create data
> r <- raster(nrow=10, ncol=10)
> s1 <- s2<- list()
> for (i in 1:12) {
+ 	s1[i] <- setValues(r, rnorm(ncell(r), i, 3) )
+ 	s2[i] <- setValues(r, rnorm(ncell(r), i, 3) )
+ }
> s1 <- stack(s1)
> s2 <- stack(s2)
> 
> # regression of values in one brick (or stack) with another
> s <- stack(s1, s2)
> # s1 and s2 have 12 layers; coefficients[2] is the slope
> fun <- function(x) { lm(x[1:12] ~ x[13:24])$coefficients[2] }
> x1 <- calc(s, fun)
> 
> # regression of values in one brick (or stack) with 'time'
> time <- 1:nlayers(s)
> fun <- function(x) { lm(x ~ time)$coefficients[2] }
> x2 <- calc(s, fun)
> 
> # get multiple layers, e.g. the slope _and_ intercept
> fun <- function(x) { lm(x ~ time)$coefficients }
> x3 <- calc(s, fun)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("calc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cellFrom")
> ### * cellFrom
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cellFrom
> ### Title: Get cell, row, or column number
> ### Aliases: cellFromRowCol cellFromRowColCombine cellFromRow cellFromCol
> ###   colFromX rowFromY cellFromXY cellFromLine cellFromPolygon
> ###   fourCellsFromXY
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> cellFromRowCol(r, 5, 5)
[1] 45
> cellFromRowCol(r, 1:2, 1:2)
[1]  1 12
> cellFromRowColCombine(r, 1:3, 1:2)
[1]  1  2 11 12 21 22
> cellFromCol(r, 1)
 [1]  1 11 21 31 41 51 61 71 81 91
> cellFromRow(r, 1)
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> colFromX(r, 0.5)
[1] 6
> rowFromY(r, 0.5)
[1] 5
> cellFromXY(r, cbind(c(0.5,5), c(15, 88)))
[1] 46  6
> fourCellsFromXY(r, cbind(c(0.5,5), c(15, 88)))
     [,1] [,2] [,3] [,4]
[1,]   46   36   35   45
[2,]    6   16   15    5
> 
> cds1 <- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
> cds2 <- rbind(c(80,0), c(100,60), c(120,0), c(120,-55), c(80,0))
> pols <- SpatialPolygons(list(Polygons(list(Polygon(cds1)), 1), Polygons(list(Polygon(cds2)), 2)))
> cellFromPolygon(r, pols)
[[1]]
[1] 51 52 53 61 62 71

[[2]]
[1] 38 48 58

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cellFrom", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cellStats")
> ### * cellStats
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cellStats
> ### Title: Statistics across cells
> ### Aliases: cellStats cellStats,RasterLayer-method
> ###   cellStats,RasterStackBrick-method
> ### Keywords: spatial univar
> 
> ### ** Examples
> 
> r <- raster(nrow=18, ncol=36)
> r[] <- runif(ncell(r)) * 10
> # works for large files
> cellStats(r, 'mean')
[1] 5.033219
> # same, but does not work for very large files
> cellStats(r, mean)
[1] 5.033219
> # multi-layer object
> cellStats(brick(r,r), mean)
 layer.1  layer.2 
5.033219 5.033219 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cellStats", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cellsFromExtent")
> ### * cellsFromExtent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cellsFromExtent
> ### Title: Cells from Extent
> ### Aliases: cellsFromExtent
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> bb <- extent(-5, 5, -5, 5)
> cells <- cellsFromExtent(r, bb)
> r <- crop(r, bb)
> r[] <- cells
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cellsFromExtent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("clamp")
> ### * clamp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: clamp
> ### Title: Clamp values
> ### Aliases: clamp clamp,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=12, nrows=12)
> values(r) <- 1:ncell(r)
> rc <- clamp(r, 25, 75) 
> rc
class       : RasterLayer 
dimensions  : 12, 12, 144  (nrow, ncol, ncell)
resolution  : 30, 15  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : 25, 75  (min, max)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("clamp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("clearValues")
> ### * clearValues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: clearValues
> ### Title: Clear values
> ### Aliases: clearValues
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> r <- raster(ncol=10, nrow=10)
> r[] <- 1:ncell(r)
> r <- clearValues(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("clearValues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("click")
> ### * click
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: click
> ### Title: Query by clicking on a map
> ### Aliases: click click,Raster-method click,SpatialGrid-method
> ###   click,SpatialPixels-method click,missing-method
> ###   click,SpatialPolygons-method click,SpatialLines-method
> ###   click,SpatialPoints-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
>  r <- raster(system.file("external/test.grd", package="raster"))
> #plot(r)
> #click(r)
> #now click on the plot (map)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("click", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("clump")
> ### * clump
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: clump
> ### Title: Detect clumps
> ### Aliases: clump clump,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=12, nrows=12)
> set.seed(0)
> r[] <- round(runif(ncell(r))*0.7 )
> rc <- clump(r) 
Loading required namespace: igraph
> freq(rc)
      value count
 [1,]     1     1
 [2,]     2    12
 [3,]     3     2
 [4,]     4    10
 [5,]     5     1
 [6,]     6     3
 [7,]     7     1
 [8,]     8     2
 [9,]     9     4
[10,]    10     2
[11,]    11     1
[12,]    12     1
[13,]    NA   104
> plot(rc)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("clump", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cluster")
> ### * cluster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cluster
> ### Title: Use a multi-core cluster
> ### Aliases: beginCluster endCluster clusterR
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D # set up the cluster object for parallel computing
> ##D beginCluster()
> ##D 
> ##D r <- raster()
> ##D r[] <- 1:ncell(r)
> ##D 
> ##D x <- clusterR(r, sqrt, verbose=T)
> ##D 
> ##D f1 <- function(x) calc(x, sqrt)
> ##D y <- clusterR(r, f1)
> ##D 
> ##D s <- stack(r, r*2, r*3)
> ##D f2 <- function(d,e,f) (d + e) / (f * param)
> ##D param <- 122
> ##D ov <- clusterR(s, overlay, args=list(fun=f2), export='param')
> ##D 
> ##D pts <- matrix(c(0,0, 45,45), ncol=2, byrow=T)
> ##D d <- clusterR(r, distanceFromPoints, args=list(xy=pts))
> ##D 
> ##D values(r) <- runif(ncell(r))
> ##D m <- c(0, 0.25, 1,  0.25, 0.5, 2,  0.5, 1, 3)
> ##D m <- matrix(m, ncol=3, byrow=TRUE)
> ##D rc1 <- clusterR(r, reclassify, args=list(rcl=m, right=FALSE), 
> ##D                filename='rcltest.grd', datatype='INT2S', overwrite=TRUE)
> ##D 
> ##D # equivalent to:
> ##D rc2 <- reclassify(r, rcl=m, right=FALSE, filename='rcltest.grd', datatype='INT2S', overwrite=TRUE)
> ##D 
> ##D 
> ##D # example with the calc function
> ##D a <- 10
> ##D f3 <- function(x) sum(x)+a
> ##D 
> ##D z1 <- clusterR(s, calc, args=list(fun=f3), export='a')
> ##D 
> ##D # for some raster functions that use another function as an argument 
> ##D # you can write your own parallel function instead of using clusterR
> ##D # get cluster object created with beginCluster
> ##D cl <- getCluster()  
> ##D 
> ##D library(parallel)
> ##D clusterExport(cl, "a")
> ##D z2 <- calc(s, fun=function(x){ parApply(cl, x, 1, f3)} )
> ##D # set flag that cluster is available again
> ##D returnCluster()
> ##D #
> ##D 
> ##D # done with cluster object		
> ##D endCluster()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cluster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compareRaster
> ### Title: Compare Raster objects
> ### Aliases: compareRaster all.equal,Raster,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r1 <- raster()
> r2 <- r1
> r3 <- r1
> compareRaster(r1, r2, r3)
[1] TRUE
> nrow(r3) <- 10
> 
> # compareRaster(r1, r3)
> compareRaster(r1, r3, stopiffalse=FALSE)
[1] FALSE
> compareRaster(r1, r3, rowcol=FALSE)
[1] TRUE
> 
> all.equal(r1, r2)
[1] TRUE
> all.equal(r1, r3)
Warning in compareRaster(target, current, ..., values = values, stopiffalse = stopiffalse,  :
  different number or rows
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compare", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compareCRS")
> ### * compareCRS
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compareCRS
> ### Title: Partially compare two CRS objects
> ### Aliases: compareCRS
> ### Keywords: spatial
> 
> ### ** Examples
>  
> compareCRS("+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84",
+   "+proj=longlat +datum=WGS84")
[1] FALSE
> compareCRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0",
+   "+proj=longlat +datum=WGS84")
[1] TRUE
> compareCRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0", 
+   "+proj=longlat +datum=WGS84", verbatim=TRUE)
[1] FALSE
> compareCRS("+proj=longlat +datum=WGS84", NA)
[1] FALSE
> compareCRS("+proj=longlat +datum=WGS84", NA, unknown=TRUE)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compareCRS", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("contour")
> ### * contour
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: contour
> ### Title: Contour plot
> ### Aliases: contour contour,RasterLayer-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> plot(r)
> contour(r, add=TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("contour", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("coordinates")
> ### * coordinates
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Extent coordinates
> ### Title: Coordinates of the Extent of a Raster object
> ### Aliases: xmin,BasicRaster-method xmax,BasicRaster-method
> ###   ymin,BasicRaster-method ymax,BasicRaster-method xmin,Extent-method
> ###   xmax,Extent-method ymin,Extent-method ymax,Extent-method xmin xmax
> ###   ymin ymax xmin<- xmax<- ymin<- ymax<-
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> r <- raster(xmn=-0.5, xmx = 9.5, ncols=10)
> xmin(r)
[1] -0.5
> xmax(r)
[1] 9.5
> ymin(r)
[1] -90
> ymax(r)
[1] 90
> xmin(r) <- -180
> xmax(r) <- 180
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("coordinates", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("corLocal")
> ### * corLocal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: corLocal
> ### Title: Local correlation coefficient
> ### Aliases: corLocal corLocal,RasterLayer,RasterLayer-method
> ###   corLocal,RasterStackBrick,RasterStackBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> set.seed(0)
> b <- stack(system.file("external/rlogo.grd", package="raster"))
> b[[2]] <- flip(b[[2]], 'y') + runif(ncell(b))
> b[[1]] <- b[[1]] + runif(ncell(b))
> 
> x <- corLocal(b[[1]], b[[2]] )
> plot(x)
> 
> # only cells where the p-value < 0.1
> xm <- mask(x[[1]], x[[2]] < 0.1, maskvalue=FALSE)
> plot(xm)
> 
> 
> # for global correlation, use the cor function
> x <- as.matrix(b)
> cor(x, method="spearman")
            red     layer      blue
red   1.0000000 0.4838493 0.9233284
layer 0.4838493 1.0000000 0.4308862
blue  0.9233284 0.4308862 1.0000000
>  
> # use sampleRegular for large datasets
> x <- sampleRegular(b, 1000)
> cor.test(x[,1], x[,2])

	Pearson's product-moment correlation

data:  x[, 1] and x[, 2]
t = 15.272, df = 970, p-value < 2.2e-16
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 0.3881349 0.4895958
sample estimates:
      cor 
0.4402698 

> 
> # RasterStack or Brick objects
> y <- corLocal(b, flip(b, 'y'))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("corLocal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cover")
> ### * cover
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cover
> ### Title: Replace NA values with values of other layers
> ### Aliases: cover cover,RasterLayer,RasterLayer-method
> ###   cover,RasterStackBrick,Raster-method
> ###   cover,SpatialPolygons,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> # raster objects
> r1 <- raster(ncols=36, nrows=18)
> r1[] <- 1:ncell(r1)
> r2 <- setValues(r1, runif(ncell(r1)))
> r2[r2 < 0.5] <- NA
> r3 <- cover(r2, r1)
> 
> 
> #SpatialPolygons
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
+ 	crs(b) <- crs(p)
+ 	b <- SpatialPolygonsDataFrame(b, data.frame(ID_1=9))
+ 	
+ 	cv1 <- cover(p, b)
+ 	cv2 <- cover(p, b, identity=TRUE)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cover", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("crop")
> ### * crop
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: crop
> ### Title: Crop
> ### Aliases: crop crop,Raster-method crop,Spatial-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=45, ncol=90)
> r[] <- 1:ncell(r)
> e <- extent(-160, 10, 30, 60)
> rc <- crop(r, e)	
> 
> # use row and column numbers:
> rc2 <- crop(r, extent(r, 5, 10, 7, 15))
> 
> # crop Raster* with Spatial* object
> b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
> crs(b) <- crs(r)
> rb <- crop(r, b)
> 
> # crop a SpatialPolygon* object with another one
> if (require(rgdal) & require(rgeos)) {
+   p <- shapefile(system.file("external/lux.shp", package="raster"))
+   pb <- crop(p, b)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("crop", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("crosstab")
> ### * crosstab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: crosstab
> ### Title: Cross-tabulate
> ### Aliases: crosstab crosstab,Raster,Raster-method
> ###   crosstab,RasterStackBrick,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(nc=5, nr=5)
> r[] <- runif(ncell(r)) * 2
> s <- setValues(r, runif(ncell(r)) * 3)
> crosstab(r,s)
   Var1 Var2 Freq
1     0    0    1
2     1    0    2
3     2    0    0
4  <NA>    0    0
5     0    1    1
6     1    1    5
7     2    1    2
8  <NA>    1    0
9     0    2    4
10    1    2    5
11    2    2    4
12 <NA>    2    0
13    0    3    0
14    1    3    0
15    2    3    1
16 <NA>    3    0
17    0 <NA>    0
18    1 <NA>    0
19    2 <NA>    0
20 <NA> <NA>    0
> 
> rs <- r/s
> r[1:5] <- NA
> s[20:25] <- NA
> x <- stack(r, s, rs)
> crosstab(x, useNA=TRUE, long=TRUE)
    layer.1 layer.2 layer.3 Freq
8      <NA>       1       0    2
9         0       2       0    3
10        1       2       0    3
17        0    <NA>       0    1
18        1    <NA>       0    1
26        1       1       1    1
27        2       1       1    2
28     <NA>       1       1    1
30        1       2       1    1
31        2       2       1    2
36     <NA>       3       1    1
38        1    <NA>       1    1
39        2    <NA>       1    2
46        1       1       2    1
62        1       0       4    1
97        0    <NA>       6    1
104    <NA>       0      19    1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("crosstab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cut")
> ### * cut
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cut
> ### Title: Convert values to classes
> ### Aliases: cut cut,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> r <- raster(ncols=36, nrows=18)
> r[] <- rnorm(ncell(r)) 
> breaks <- -2:2 * 3
> rc <- cut(r, breaks=breaks)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cut", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cv")
> ### * cv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cv
> ### Title: Coefficient of variation
> ### Aliases: cv cv,ANY-method cv,Raster-method
> ### Keywords: univar math
> 
> ### ** Examples
> 
> data <- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
> cv(data, na.rm=TRUE)
[1] 56.23757
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dataType")
> ### * dataType
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dataType
> ### Title: Data type
> ### Aliases: dataType dataType<-
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> dataType(r)
[1] "FLT4S"
> s <- writeRaster(r, 'new.grd', datatype='INT2U', overwrite=TRUE)
> dataType(s)
[1] "INT2U"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dataType", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("datasource")
> ### * datasource
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: datasource
> ### Title: Are values in memory and/or on disk?
> ### Aliases: fromDisk inMemory hasValues
> ### Keywords: spatial
> 
> ### ** Examples
> 
> rs <- raster(system.file("external/test.grd", package="raster"))
> inMemory(rs)
[1] FALSE
> fromDisk(rs)
[1] TRUE
> rs <- readAll(rs)
> inMemory(rs)
[1] TRUE
> fromDisk(rs)
[1] FALSE
> rs <- rs + 1
> inMemory(rs)
[1] TRUE
> fromDisk(rs)
[1] FALSE
> rs <- raster(rs)
> inMemory(rs)
[1] FALSE
> fromDisk(rs)
[1] FALSE
> rs <- setValues(rs, 1:ncell(rs))
> inMemory(rs)
[1] TRUE
> fromDisk(rs)
[1] FALSE
> rs <- writeRaster(rs, filename='test', overwrite=TRUE)
> inMemory(rs)
[1] FALSE
> fromDisk(rs)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("datasource", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("density")
> ### * density
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: density
> ### Title: Density plot
> ### Aliases: density density,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> logo <- stack(system.file("external/rlogo.grd", package="raster")) 
> density(logo)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("density", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dimensions")
> ### * dimensions
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dim
> ### Title: Dimensions of a Raster* object
> ### Aliases: dim dim,RasterStackBrick-method dim,BasicRaster-method
> ###   dim<-,BasicRaster-method dim<-,RasterLayer-method
> ###   dim<-,RasterBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> dim(r)
[1] 180 360   1
> dim(r) <- c(18) 
> dim(r)
[1]  18 360   1
> dim(r) <- c(18, 36) 
> dim(r)
[1] 18 36  1
> b <- brick(r)
> dim(b)
[1] 18 36  1
> dim(b) <- c(10, 10, 5)
> dim(b)
[1] 10 10  5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dimensions", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("direction")
> ### * direction
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: direction
> ### Title: Direction
> ### Aliases: direction direction,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=36,nrow=18)
> r[] <- NA
> r[306] <- 1
> b <- direction(r) 
> #plot(b)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("direction", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("disaggregate")
> ### * disaggregate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: disaggregate
> ### Title: Disaggregate
> ### Aliases: disaggregate disaggregate,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> rd <- disaggregate(r, fact=c(10, 2))
> ncol(rd)
[1] 100
> nrow(rd)
[1] 20
> r[] <- 1:ncell(r)
> rd <- disaggregate(r, fact=c(4, 2), method='bilinear')
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("disaggregate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("distance")
> ### * distance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: distance
> ### Title: Distance
> ### Aliases: distance distance,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=36,nrow=18)
> r[] <- NA
> r[500] <- 1
> dist <- distance(r) 
> #plot(dist / 1000)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("distance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("distanceFromPoints")
> ### * distanceFromPoints
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: distanceFromPoints
> ### Title: Distance from points
> ### Aliases: distanceFromPoints
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=36,nrow=18)
> xy = c(0,0)
> dist <- distanceFromPoints(r, xy) 
> #plot(dist)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("distanceFromPoints", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("drawExtent")
> ### * drawExtent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: drawExtent
> ### Title: Create an Extent object by drawing on a map
> ### Aliases: drawExtent
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D r1 <- raster(nrow=10, ncol=10)
> ##D r1[] <- runif(ncell(r1))
> ##D plot(r1)
> ##D # after running the following line, click on the map twice
> ##D e <- drawExtent()
> ##D # after running the following line, click on the map twice
> ##D mean(values(crop(r1, drawExtent())))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("drawExtent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("erase")
> ### * erase
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: erase
> ### Title: Erase parts of a Spatial* object
> ### Aliases: erase erase,SpatialPolygons,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
+ 	projection(b) <- projection(p)
+ 	e <- erase(p, b)
+ 	plot(e)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("erase", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("extend")
> ### * extend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extend
> ### Title: Extend
> ### Aliases: extend extend,Raster-method extend,Extent-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(xmn=-150, xmx=-120, ymx=60, ymn=30, ncol=36, nrow=18)
> r[] <- 1:ncell(r)
> e <- extent(-180, 0, 0, 90)
> re <- extend(r, e)
> 
> # extend with a number of rows and columns (at each side)
> re2 <- extend(r, c(2,10))
> 
> # Extent object
> e <- extent(r)
> e
class       : Extent 
xmin        : -150 
xmax        : -120 
ymin        : 30 
ymax        : 60 
> extend(e, 10)
class       : Extent 
xmin        : -160 
xmax        : -110 
ymin        : 20 
ymax        : 70 
> extend(e, 10, -10, 0, 20)
class       : Extent 
xmin        : -160 
xmax        : -110 
ymin        : 20 
ymax        : 70 
> e + 10
class       : Extent 
xmin        : -155 
xmax        : -115 
ymin        : 25 
ymax        : 65 
> e * 2
class       : Extent 
xmin        : -165 
xmax        : -105 
ymin        : 15 
ymax        : 75 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extension")
> ### * extension
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extension
> ### Title: Filename extensions
> ### Aliases: extension extension<-
> ### Keywords: file
> 
> ### ** Examples
> 
> fn <- "c:/temp folder/filename.exten sion"
> extension(fn)
[1] ""
> extension(fn) <- ".txt"
> extension(fn)
[1] ".txt"
> fn <- extension(fn, '.document')
> extension(fn)
[1] ".document"
> extension(fn, maxchar=4)
[1] ""
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extension", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extent")
> ### * extent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extent
> ### Title: Extent
> ### Aliases: extent extent,Extent-method extent,BasicRaster-method
> ###   extent,Spatial-method extent,matrix-method extent,numeric-method
> ###   extent,list-method extent,GridTopology-method bbox,Raster-method
> ###   bbox,Extent-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> extent(r)
class       : Extent 
xmin        : -180 
xmax        : 180 
ymin        : -90 
ymax        : 90 
> extent(c(0, 20, 0, 20))
class       : Extent 
xmin        : 0 
xmax        : 20 
ymin        : 0 
ymax        : 20 
> #is equivalent to
> extent(0, 20, 0, 20)
class       : Extent 
xmin        : 0 
xmax        : 20 
ymin        : 0 
ymax        : 20 
> extent(matrix(c(0, 0, 20, 20), nrow=2))
class       : Extent 
xmin        : 0 
xmax        : 20 
ymin        : 0 
ymax        : 20 
> x <- list(x=c(0,1,2), y=c(-3,5))
> extent(x)
class       : Extent 
xmin        : 0 
xmax        : 2 
ymin        : -3 
ymax        : 5 
> 
> #crop the extent by row and column numbers
> extent(r, 1, 20, 10, 30)
class       : Extent 
xmin        : -171 
xmax        : -150 
ymin        : 70 
ymax        : 90 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extract")
> ### * extract
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extract
> ### Title: Extract values from Raster objects
> ### Aliases: extract extract,Raster,vector-method
> ###   extract,Raster,matrix-method extract,Raster,data.frame-method
> ###   extract,Raster,SpatialPoints-method
> ###   extract,Raster,SpatialLines-method
> ###   extract,Raster,SpatialPolygons-method extract,Raster,Extent-method
> ###   extract,SpatialPolygons,SpatialPoints-method
> ###   extract,SpatialPolygons,data.frame-method
> ###   extract,SpatialPolygons,matrix-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=36, nrow=18)
> r[] <- 1:ncell(r)
> 
> ###############################
> # extract values by cell number
> ###############################
> extract(r, c(1:2, 10, 100))
[1]   1   2  10 100
> s <- stack(r, sqrt(r), r/r)
> extract(s, c(1, 10, 100), layer=2, n=2)
       layer.2 layer.3
[1,]  1.000000       1
[2,]  3.162278       1
[3,] 10.000000       1
> 
> ###############################
> # extract values with points
> ###############################
> xy <- cbind(-50, seq(-80, 80, by=20))
> extract(r, xy)
[1] 626 554 482 410 338 266 194 122  50
> 
> sp <- SpatialPoints(xy)
> extract(r, sp, method='bilinear')
[1] 607.5 535.5 463.5 391.5 319.5 247.5 175.5 103.5  31.5
> 
> # examples with a buffer
> extract(r, xy[1:3,], buffer=1000000)
[[1]]
 [1] 586 587 588 589 590 591 592 593 620 621 622 623 624 625 626 627 628 629 630
[20] 631

[[2]]
[1] 517 518 552 553 554 555

[[3]]
[1] 445 446 481 482

> extract(r, xy[1:3,], buffer=1000000, fun=mean)
[1] 611.1 541.5 463.5
> 
> ## illustrating the varying size of a buffer (expressed in meters) 
> ## on a longitude/latitude raster
>  z <- extract(r, xy, buffer=1000000)
>  s <- raster(r)
>  for (i in 1:length(z)) { s[z[[i]]] <- i }
>  
> ## compare with raster that is not longitude/latitude
>  projection(r) <- "+proj=utm +zone=17" 
>  xy[,1] <- 50
>  z <- extract(r, xy, buffer=8)
>  for (i in 1:length(z)) { s[z[[i]]] <- i }
>  plot(s)
> # library(maptools)
> # data(wrld_simpl)
> # plot(wrld_simpl, add=TRUE)
> 
> ###############################
> # extract values with lines
> ###############################
> 
> cds1 <- rbind(c(-50,0), c(0,60), c(40,5), c(15,-45), c(-10,-25))
> cds2 <- rbind(c(80,20), c(140,60), c(160,0), c(140,-55))
> lines <- spLines(cds1, cds2)
> 
> extract(r, lines)
[[1]]
 [1] 126 127 161 162 163 164 196 197 200 201 231 232 237 266 267 273 274 302 310
[20] 311 338 346 381 382 414 417 450 451 452 453 487 488

[[2]]
 [1] 139 140 141 174 175 177 208 209 210 213 243 244 249 250 279 286 322 358 359
[20] 394 429 430 465 501 537

> 
> ###############################
> # extract values with polygons
> ###############################
> cds1 <- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
> cds2 <- rbind(c(80,0), c(100,60), c(120,0), c(120,-55), c(80,0))
> polys <- spPolygons(cds1, cds2)
> 
> #plot(r)
> #plot(polys, add=TRUE)
> v <- extract(r, polys)
> v
[[1]]
 [1] 326 327 328 329 330 331 332 333 334 335 361 362 363 364 365 366 367 368 369
[20] 370 397 398 399 400 401 402 403 404 434 435 436 437 438 470 471 472 473 507

[[2]]
 [1] 172 173 208 209 244 245 279 280 281 282 315 316 317 318 351 352 353 354 388
[20] 389 390 425 426 462 498

> # mean for each polygon
> unlist(lapply(v, function(x) if (!is.null(x)) mean(x, na.rm=TRUE) else NA ))
[1] 387.8158 321.0800
> 
> # v <- extract(r, polys, cellnumbers=TRUE)
> 
> # weighted mean
> # v <- extract(r, polys, weights=TRUE, fun=mean)
> # equivalent to:
> # v <- extract(r, polys, weights=TRUE)
> # sapply(v, function(x) if (!is.null(x)) {sum(apply(x, 1, prod)) / sum(x[,2])} else NA)
> 
> 
> ###############################
> # extract values with an extent
> ###############################
> e <- extent(150,170,-60,-40)
> extract(r, e)
[1] 502 503 538 539
> #plot(r)
> #plot(e, add=T)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extract", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extractIndex")
> ### * extractIndex
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Extract by index
> ### Title: Indexing to extract values of a Raster* object
> ### Aliases: [[,Raster,ANY,ANY-method [,Raster,Spatial,missing-method
> ###   [,Raster,RasterLayer,missing-method [,Raster,Extent,missing-method
> ###   [,Raster,numeric,numeric-method [,Raster,numeric,missing-method
> ###   [,Raster,missing,numeric-method [,Raster,matrix,missing-method
> ###   [,Raster,missing,missing-method [,Raster,logical,missing-method
> ###   [,Extent,numeric,missing-method [,Extent,missing,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=5)
> r[] <- 1:ncell(r) 
> 
> r[1]
  
1 
> r[1:10]
 [1]  1  2  3  4  5  6  7  8  9 10
> r[1,]
 [1]  1  2  3  4  5  6  7  8  9 10
> r[,1]
[1]  1 11 21 31 41
> r[1:2, 1:2]
[1]  1  2 11 12
> 
> s <- stack(r, sqrt(r))
> s[1:3]
     layer.1  layer.2
[1,]       1 1.000000
[2,]       2 1.414214
[3,]       3 1.732051
> s[[2]]
class       : RasterLayer 
dimensions  : 5, 10, 50  (nrow, ncol, ncell)
resolution  : 36, 36  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer.2 
values      : 1, 7.071068  (min, max)

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extractIndex", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extremeValues")
> ### * extremeValues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extremeValues
> ### Title: Minimum and maximum values
> ### Aliases: minValue maxValue minValue,RasterLayer-method
> ###   minValue,RasterStack-method minValue,RasterBrick-method
> ###   maxValue,RasterLayer-method maxValue,RasterStack-method
> ###   maxValue,RasterBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> r <- setValues(r, 1:ncell(r))
> minValue(r)
[1] 1
> maxValue(r)
[1] 64800
> r <- setValues(r, round(100 * runif(ncell(r)) + 0.5))
> minValue(r)
[1] 1
> maxValue(r)
[1] 100
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> minValue(r)
[1] 128.434
> maxValue(r)
[1] 1805.78
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extremeValues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("factor")
> ### * factor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: factors
> ### Title: Factors
> ### Aliases: is.factor is.factor,Raster-method is.factor,RasterStack-method
> ###   as.factor as.factor,RasterLayer-method levels levels,Raster-method
> ###   levels,RasterStack-method levels<- levels<-,Raster-method asFactor
> ###   asFactor,RasterLayer-method factorValues ratify deratify
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> set.seed(0)
> r <- raster(nrow=10, ncol=10)
> r[] <- runif(ncell(r)) * 10
> is.factor(r)
[1] FALSE
> 
> r <- round(r)
> f <- as.factor(r)
> is.factor(f)
[1] TRUE
> 
> x <- levels(f)[[1]]
> x
   ID
1   0
2   1
3   2
4   3
5   4
6   5
7   6
8   7
9   8
10  9
11 10
> x$code <- letters[10:20]
> levels(f) <- x
> levels(f)
[[1]]
   ID code
1   0    j
2   1    k
3   2    l
4   3    m
5   4    n
6   5    o
7   6    p
8   7    q
9   8    r
10  9    s
11 10    t

> f
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : 0, 10  (min, max)
attributes  :
       ID code
 from:  0    j
 to  : 10    t

> 
> r <- raster(nrow=10, ncol=10)
> r[] = 1
> r[51:100] = 2
> r[3:6, 1:5] = 3
> r <- ratify(r)
> 
> rat <- levels(r)[[1]]
> rat$landcover <- c('Pine', 'Oak', 'Meadow')
> rat$code <- c(12,25,30)
> levels(r) <- rat
> r
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : 1, 3  (min, max)
attributes  :
 ID landcover code
  1      Pine   12
  2       Oak   25
  3    Meadow   30

> 
> # extract values for some cells
> i <- extract(r, c(1,2, 25,100))
> i
[1] 1 1 3 2
> # get the attribute values for these cells
> factorValues(r, i)
  landcover code
1      Pine   12
2      Pine   12
3    Meadow   30
4       Oak   25
> 
> # write to file:
> rr <- writeRaster(r, 'test.grd', overwrite=TRUE)
> rr
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/test.grd 
names       : layer 
values      : 1, 3  (min, max)
attributes  :
 ID landcover code
  1      Pine   12
  2       Oak   25
  3    Meadow   30

> 
> # create a single-layer factor 
> x <- deratify(r, 'landcover')
> x
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : landcover 
values      : 1, 3  (min, max)
attributes  :
 ID landcover
  1      Pine
  2       Oak
  3    Meadow

> is.factor(x)
[1] TRUE
> levels(x)
[[1]]
  ID landcover
1  1      Pine
2  2       Oak
3  3    Meadow

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("factor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filename")
> ### * filename
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filename
> ### Title: Filename
> ### Aliases: filename
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster( system.file("external/test.grd", package="raster") )
> filename(r)
[1] "/Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filename", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filledContour")
> ### * filledContour
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filledContour
> ### Title: Filled contour plot
> ### Aliases: filledContour
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> filledContour(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filledContour", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flip")
> ### * flip
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flip
> ### Title: Flip
> ### Aliases: flip flip,RasterLayer-method flip,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=18, ncol=36)
> m <- matrix(1:ncell(r), nrow=18)
> r[] <- as.vector(t(m))
> rx <- flip(r, direction='x')
> r[] <- as.vector(m)
> ry <- flip(r, direction='y')
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flip", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flowpath")
> ### * flowpath
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flowPath
> ### Title: Flow path
> ### Aliases: flowPath
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(volcano)
> v <- raster(volcano, xmn=2667400, xmx=2668010, ymn=6478700, ymx=6479570, crs="+init=epsg:27200")
> fd <- terrain(v, opt = "flowdir")
> 
> path <- flowPath(fd, 2407)
> xy <- xyFromCell(fd, path)
> plot(v)
> lines(xy)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flowpath", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("focal")
> ### * focal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: focal
> ### Title: Focal values
> ### Aliases: focal focal,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=36, nrows=18, xmn=0)
> r[] <- runif(ncell(r)) 
> 
> # 3x3 mean filter
> r3 <- focal(r, w=matrix(1/9,nrow=3,ncol=3)) 
> 
> # 5x5 mean filter
> r5 <- focal(r, w=matrix(1/25,nrow=5,ncol=5)) 
> 
> # Gaussian filter
> gf <- focalWeight(r, 2, "Gauss")
> rg <- focal(r, w=gf)
> 
> # The max value for the lower-rigth corner of a 3x3 matrix around a focal cell
> f = matrix(c(0,0,0,0,1,1,0,1,1), nrow=3)
> f
     [,1] [,2] [,3]
[1,]    0    0    0
[2,]    0    1    1
[3,]    0    1    1
> rm <- focal(r, w=f, fun=max)
> 
> # global lon/lat data: no 'edge effect' for the columns
> xmin(r) <- -180
> r3g <- focal(r, w=matrix(1/9,nrow=3,ncol=3)) 
> 
> 
> ## Not run: 
> ##D ## focal can be used to create a cellular automaton
> ##D 
> ##D # Conway's Game of Life 
> ##D w <- matrix(c(1,1,1,1,0,1,1,1,1), nr=3,nc=3)
> ##D gameOfLife <- function(x) {
> ##D 	f <- focal(x, w=w, pad=TRUE, padValue=0)
> ##D 	# cells with less than two or more than three live neighbours die
> ##D 	x[f<2 | f>3] <- 0
> ##D 	# cells with three live neighbours become alive
> ##D 	x[f==3] <- 1
> ##D 	x
> ##D }
> ##D 
> ##D # simulation function
> ##D sim <- function(x, fun, n=100, pause=0.25) {
> ##D 	for (i in 1:n) {
> ##D 		x <- fun(x)
> ##D 		plot(x, legend=FALSE, asp=NA, main=i)
> ##D 		dev.flush()
> ##D 		Sys.sleep(pause)
> ##D 	}
> ##D 	invisible(x)
> ##D }
> ##D 
> ##D # Gosper glider gun
> ##D m <- matrix(0, nc=48, nr=34)
> ##D m[c(40, 41, 74, 75, 380, 381, 382, 413, 417, 446, 452, 480, 
> ##D   486, 517, 549, 553, 584, 585, 586, 619, 718, 719, 720, 752, 
> ##D   753, 754, 785, 789, 852, 853, 857, 858, 1194, 1195, 1228, 1229)] <- 1
> ##D init <- raster(m)
> ##D 
> ##D # run the model
> ##D sim(init, gameOfLife, n=150, pause=0.05)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("focal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("focalWeight")
> ### * focalWeight
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: focalWeight
> ### Title: Focal weights matrix
> ### Aliases: focalWeight
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=36, nrows=18, xmn=0)
> # Gaussian filter for square cells
> gf <- focalWeight(r, 2, "Gauss")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("focalWeight", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("freq")
> ### * freq
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: freq
> ### Title: Frequency table
> ### Aliases: freq freq,RasterLayer-method freq,RasterStackBrick-method
> ### Keywords: spatial univar
> 
> ### ** Examples
> 
> r <- raster(nrow=18, ncol=36)
> r[] <- runif(ncell(r))
> r[1:5] <- NA
> r <- r * r * r * 5
> freq(r)
     value count
[1,]     0   304
[2,]     1   132
[3,]     2    76
[4,]     3    56
[5,]     4    54
[6,]     5    21
[7,]    NA     5
> 
> freq(r, value=2)
[1] 76
> 
> s <- stack(r, r*2, r*3)
> freq(s, merge=TRUE)
   value layer.1 layer.2 layer.3
1      0     304     228     193
2      1     132     129     111
3      2      76      45      61
4      3      56      51      31
5      4      54      41      40
6      5      21      29      26
7      6      NA      33      25
8      7      NA      21      25
9      8      NA      29      15
10     9      NA      25      23
11    10      NA      12      18
12    11      NA      NA      11
13    12      NA      NA      21
14    13      NA      NA      22
15    14      NA      NA      12
16    15      NA      NA       9
17    NA       5       5       5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("freq", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("gainoffset")
> ### * gainoffset
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Gain and offset
> ### Title: Gain and offset of values on file
> ### Aliases: gain offs gain<- offs<-
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> gain(r)
[1] 1
> offs(r)
[1] 0
> r[1505:1510]
[1] 500.892 432.629 374.083 357.068 344.890 342.894
> gain(r) <- 10
> offs(r) <- 5
> r[1505:1510]
[1] 5013.92 4331.29 3745.83 3575.68 3453.90 3433.94
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("gainoffset", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getValues")
> ### * getValues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getValues
> ### Title: Get raster cell values
> ### Aliases: values values,Raster-method getValues
> ###   getValues,RasterLayer,missing,missing-method
> ###   getValues,RasterLayerSparse,missing,missing-method
> ###   getValues,RasterStack,missing,missing-method
> ###   getValues,RasterBrick,missing,missing-method
> ###   getValues,RasterLayer,numeric,missing-method
> ###   getValues,RasterLayerSparse,numeric,missing-method
> ###   getValues,RasterStack,numeric,missing-method
> ###   getValues,RasterBrick,numeric,missing-method
> ###   getValues,RasterLayer,numeric,numeric-method
> ###   getValues,RasterLayerSparse,numeric,numeric-method
> ###   getValues,RasterStack,numeric,numeric-method
> ###   getValues,RasterBrick,numeric,numeric-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> r
class       : RasterLayer 
dimensions  : 115, 80, 9200  (nrow, ncol, ncell)
resolution  : 40, 40  (x, y)
extent      : 178400, 181600, 329400, 334000  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd 
names       : test 
values      : 128.434, 1805.78  (min, max)

> v <- getValues(r)
> length(v)
[1] 9200
> head(v)
[1] NA NA NA NA NA NA
> getValues(r, row=10)
 [1]       NA       NA       NA       NA       NA       NA       NA       NA
 [9]       NA       NA       NA       NA       NA       NA       NA       NA
[17]       NA       NA       NA       NA       NA       NA       NA       NA
[25]       NA       NA       NA       NA       NA       NA       NA       NA
[33]       NA       NA       NA       NA       NA       NA       NA       NA
[41]       NA       NA       NA       NA       NA       NA       NA       NA
[49]       NA       NA       NA       NA       NA       NA       NA       NA
[57]       NA       NA       NA       NA       NA       NA       NA       NA
[65]       NA       NA 1003.870  945.002  769.047  661.724  593.855  537.250
[73]       NA       NA       NA       NA       NA       NA       NA       NA
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getValues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getValuesBlock")
> ### * getValuesBlock
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getValuesBlock
> ### Title: Get a block of raster cell values
> ### Aliases: getValuesBlock getValuesBlock,RasterLayer-method
> ###   getValuesBlock,RasterLayerSparse-method
> ###   getValuesBlock,RasterStack-method getValuesBlock,RasterBrick-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> b <- getValuesBlock(r, row=100, nrows=3, col=10, ncols=5)
> b 
 [1] 454.412 440.488 421.193 396.460 365.566 483.079 467.769 444.945 418.093
[10] 390.002 532.368 513.638 481.389 446.935 416.298
> b <- matrix(b, nrow=3, ncol=5, byrow=TRUE)
> b
        [,1]    [,2]    [,3]    [,4]    [,5]
[1,] 454.412 440.488 421.193 396.460 365.566
[2,] 483.079 467.769 444.945 418.093 390.002
[3,] 532.368 513.638 481.389 446.935 416.298
> 
> logo <- brick(system.file("external/rlogo.grd", package="raster"))
> getValuesBlock(logo, row=35, nrows=3, col=50, ncols=3, lyrs=2:3)
      green blue
 [1,]   168  220
 [2,]   176  231
 [3,]   175  226
 [4,]   167  219
 [5,]   176  230
 [6,]   175  226
 [7,]   167  219
 [8,]   176  230
 [9,]   175  224
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getValuesBlock", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getValuesFocal")
> ### * getValuesFocal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getValuesFocal
> ### Title: Get focal raster cell values
> ### Aliases: getValuesFocal getValuesFocal,Raster-method
> ###   getValuesFocal,Raster,missing,missing,numeric-method
> ###   getValuesFocal,Raster,numeric,numeric,numeric-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(nr=5, nc=5, crs='+proj=utm +zone=12')
> r[] <- 1:25
> as.matrix(r)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20
[5,]   21   22   23   24   25
> getValuesFocal(r, row=1, nrows=2, ngb=3, names=TRUE)
   r1c1 r1c2 r1c3 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3
1    NA   NA   NA   NA    1    2   NA    6    7
2    NA   NA   NA    1    2    3    6    7    8
3    NA   NA   NA    2    3    4    7    8    9
4    NA   NA   NA    3    4    5    8    9   10
5    NA   NA   NA    4    5   NA    9   10   NA
6    NA    1    2   NA    6    7   NA   11   12
7     1    2    3    6    7    8   11   12   13
8     2    3    4    7    8    9   12   13   14
9     3    4    5    8    9   10   13   14   15
10    4    5   NA    9   10   NA   14   15   NA
> getValuesFocal(stack(r,r), row=1, nrows=1, ngb=3, names=TRUE, array=TRUE)
, , layer.1

  r1c1 r1c2 r1c3 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3
1   NA   NA   NA   NA    1    2   NA    6    7
2   NA   NA   NA    1    2    3    6    7    8
3   NA   NA   NA    2    3    4    7    8    9
4   NA   NA   NA    3    4    5    8    9   10
5   NA   NA   NA    4    5   NA    9   10   NA

, , layer.2

  r1c1 r1c2 r1c3 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3
1   NA   NA   NA   NA    1    2   NA    6    7
2   NA   NA   NA    1    2    3    6    7    8
3   NA   NA   NA    2    3    4    7    8    9
4   NA   NA   NA    3    4    5    8    9   10
5   NA   NA   NA    4    5   NA    9   10   NA

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getValuesFocal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("gridDistance")
> ### * gridDistance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: gridDistance
> ### Title: Distance on a grid
> ### Aliases: gridDistance gridDistance,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> #world lon/lat raster
> r <- raster(ncol=10,nrow=10)
> r[] <- 1
> r[48] <- 2
> r[66:68] <- 3
> d <- gridDistance(r,origin=2,omit=3) 
> plot(d)
> 
> #UTM small area
> projection(r) <- "+proj=utm +zone=15 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
> d <- gridDistance(r,origin=2,omit=3) 
> plot(d)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("gridDistance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hdrFiles")
> ### * hdrFiles
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hdr
> ### Title: Header files
> ### Aliases: hdr
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> r <- writeRaster(r, filename='export.grd', overwrite=TRUE)
> hdr(r, format="ENVI") 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hdrFiles", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("headtail")
> ### * headtail
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: head
> ### Title: Show the head or tail of a Raster* object
> ### Aliases: head head,RasterLayer-method head,RasterStackBrick-method
> ###   head,Spatial-method tail tail,RasterLayer-method
> ###   tail,RasterStackBrick-method tail,Spatial-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=25, ncol=25)
> r[] = 1:ncell(r)
> head(r)
     1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
1    1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
2   26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44
3   51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69
4   76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94
5  101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
6  126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144
7  151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169
8  176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194
9  201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219
10 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244
    20
1   20
2   45
3   70
4   95
5  120
6  145
7  170
8  195
9  220
10 245
> tail(r, cols=10, rows=5)
    16  17  18  19  20  21  22  23  24  25
21 516 517 518 519 520 521 522 523 524 525
22 541 542 543 544 545 546 547 548 549 550
23 566 567 568 569 570 571 572 573 574 575
24 591 592 593 594 595 596 597 598 599 600
25 616 617 618 619 620 621 622 623 624 625
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("headtail", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hillShade")
> ### * hillShade
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hillShade
> ### Title: Hill shading
> ### Aliases: hillShade
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D alt <- getData('alt', country='CHE')
> ##D slope <- terrain(alt, opt='slope')
> ##D aspect <- terrain(alt, opt='aspect')
> ##D hill <- hillShade(slope, aspect, 40, 270)
> ##D plot(hill, col=grey(0:100/100), legend=FALSE, main='Switzerland')
> ##D plot(alt, col=rainbow(25, alpha=0.35), add=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hillShade", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hist")
> ### * hist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hist
> ### Title: Histogram
> ### Aliases: hist hist,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> r1 <- raster(nrows=50, ncols=50)
> r1 <- setValues(r1, runif(ncell(r1)))
> r2 <- setValues(r1, runif(ncell(r1)))
> rs <- r1 + r2
> rp <- r1 * r2
> par(mfrow=c(2,2))
> plot(rs, main='sum')
> plot(rp, main='product')
> hist(rs)
> a = hist(rp)
> a
$breaks
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

$counts
 [1] 848 490 319 255 188 165 102  71  48  14

$density
 [1] 3.392 1.960 1.276 1.020 0.752 0.660 0.408 0.284 0.192 0.056

$mids
 [1] 0.05 0.15 0.25 0.35 0.45 0.55 0.65 0.75 0.85 0.95

$xname
[1] "v"

$equidist
[1] TRUE

attr(,"class")
[1] "histogram"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("image")
> ### * image
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: image
> ### Title: Image
> ### Aliases: image image,RasterLayer-method image,RasterStackBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> image(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("image", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("init")
> ### * init
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: initialize
> ### Title: Intitialize a Raster object with values
> ### Aliases: init
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=36, nrows=18)
> 
> x <- init(r, fun='cell')
> 
> y <- init(r, fun=runif)
> 
> # there are different ways to set all values to 1 
> # for large rasters:
> set1f <- function(x){rep(1, x)}
> z1 <- init(r, fun=set1f, filename='test.grd', overwrite=TRUE)
> 
> # This is equivalent to (but not memory safe):
> z2 <- setValues(r, rep(1, ncell(r)))
> # or  
> r[] <- rep(1, ncell(r))
> # or  
> r[] <- 1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("init", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("interpolate")
> ### * interpolate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: interpolate
> ### Title: Interpolate
> ### Aliases: interpolate interpolate,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Thin plate spline interpolation with x and y only
> ##D library(fields) 
> ##D r <- raster(system.file("external/test.grd", package="raster"))
> ##D ra <- aggregate(r, 10)
> ##D xy <- data.frame(xyFromCell(ra, 1:ncell(ra)))
> ##D v <- getValues(ra)
> ##D # fit a model
> ##D tps <- Tps(xy, v)
> ##D p <- raster(r)
> ##D # use model to predict values for all locations
> ##D p <- interpolate(p, tps)
> ##D p <- mask(p, r)
> ##D plot(p)
> ##D # change the fun from predict to fields::predictSE to get the TPS standard error
> ##D se <- interpolate(p, tps, fun=predictSE)
> ##D se <- mask(se, r)
> ##D plot(se)
> ##D 
> ##D 
> ##D ## gstat examples
> ##D library(gstat)
> ##D data(meuse)
> ##D 
> ##D ## inverse distance weighted (IDW)
> ##D r <- raster(system.file("external/test.grd", package="raster"))
> ##D data(meuse)
> ##D mg <- gstat(id = "zinc", formula = zinc~1, locations = ~x+y, data=meuse, 
> ##D             nmax=7, set=list(idp = .5))
> ##D z <- interpolate(r, mg)
> ##D z <- mask(z, r)
> ##D 
> ##D ## kriging
> ##D coordinates(meuse) <- ~x+y
> ##D projection(meuse) <- projection(r)
> ##D 
> ##D ## ordinary kriging
> ##D v <- variogram(log(zinc)~1, meuse)
> ##D m <- fit.variogram(v, vgm(1, "Sph", 300, 1))
> ##D gOK <- gstat(NULL, "log.zinc", log(zinc)~1, meuse, model=m)
> ##D OK <- interpolate(r, gOK)
> ##D 
> ##D # examples below provided by Maurizio Marchi
> ##D ## universial kriging
> ##D vu <- variogram(log(zinc)~elev, meuse)
> ##D mu <- fit.variogram(vu, vgm(1, "Sph", 300, 1))
> ##D gUK <- gstat(NULL, "log.zinc", log(zinc)~elev, meuse, model=mu)
> ##D names(r) <- 'elev'
> ##D UK <- interpolate(r, gUK, xyOnly=FALSE)
> ##D 
> ##D ## co-kriging
> ##D gCoK <- gstat(NULL, 'log.zinc', log(zinc)~1, meuse)
> ##D gCoK <- gstat(gCoK, 'elev', elev~1, meuse)
> ##D gCoK <- gstat(gCoK, 'cadmium', cadmium~1, meuse)
> ##D gCoK <- gstat(gCoK, 'copper', copper~1, meuse)
> ##D coV <- variogram(gCoK)
> ##D plot(coV, type='b', main='Co-variogram')
> ##D coV.fit <- fit.lmc(coV, gCoK, vgm(model='Sph', range=1000))
> ##D coV.fit
> ##D plot(coV, coV.fit, main='Fitted Co-variogram')
> ##D coK <- interpolate(r, coV.fit)
> ##D plot(coK)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("interpolate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("intersect")
> ### * intersect
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: intersect
> ### Title: Intersect
> ### Aliases: intersect intersect,Extent,ANY-method
> ###   intersect,Raster,ANY-method intersect,SpatialVector,ANY-method
> ###   intersect,SpatialPolygons,SpatialPolygons-method
> ###   intersect,SpatialLines,SpatialPolygons-method
> ###   intersect,SpatialPolygons,SpatialLines-method
> ###   intersect,SpatialPoints,SpatialPolygons-method
> ###   intersect,SpatialPolygons,SpatialPoints-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> e1 <- extent(-10, 10, -20, 20)
> e2 <- extent(0, 20, -40, 5)
> intersect(e1, e2)
class       : Extent 
xmin        : 0 
xmax        : 10 
ymin        : -20 
ymax        : 5 
> 
> #SpatialPolygons
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
+ 	projection(b) <- projection(p)
+ 	i <- intersect(p, b)
+ 	plot(p)
+ 	plot(b, add=TRUE, col='red')
+ 	plot(i, add=TRUE, col='blue', lwd=2)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("intersect", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("isLonLat")
> ### * isLonLat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: isLonLat
> ### Title: Is this longitude/latitude data?
> ### Aliases: isLonLat isLonLat,BasicRaster-method isLonLat,Spatial-method
> ###   isLonLat,CRS-method isLonLat,character-method isLonLat,ANY-method
> ###   couldBeLonLat
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> isLonLat(r)
[1] TRUE
> projection(r) <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
> isLonLat(r)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("isLonLat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("layerStats")
> ### * layerStats
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: layerStats
> ### Title: Correlation and (weighted) covariance
> ### Aliases: layerStats
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> layerStats(b, 'pearson')
$`pearson correlation coefficient`
            red     green      blue
red   1.0000000 0.9980961 0.9501633
green 0.9980961 1.0000000 0.9658011
blue  0.9501633 0.9658011 1.0000000

$mean
     red    green     blue 
182.2855 185.3509 192.8046 

> 
> layerStats(b, 'cov')
$covariance
           red    green     blue
red   5564.371 5443.405 4993.165
green 5443.405 5345.403 4974.478
blue  4993.165 4974.478 4962.942

$mean
     red    green     blue 
182.2855 185.3509 192.8046 

> 
> # weigh by column number
> w <- init(b, v='col')
> layerStats(b, 'weighted.cov', w=w)
$`weigthed covariance`
           red    green     blue
red   5670.750 5536.351 5009.851
green 5536.351 5427.161 4987.092
blue  5009.851 4987.092 4937.007

$`weighted mean`
 layer.1  layer.2  layer.3 
177.5983 181.3521 191.5236 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layerStats", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("layerize")
> ### * layerize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: layerize
> ### Title: Layerize
> ### Aliases: layerize layerize,RasterLayer,missing-method
> ###   layerize,RasterLayer,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=36, ncol=72)
> r[] <- round(runif(ncell(r))*5)
> r[1:5] <- NA
> b <- layerize(r)
> 
> r2 <- raster(nrow=10, ncol=10)
> b2 <- layerize(r, r2)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layerize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("localFun")
> ### * localFun
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: localFun
> ### Title: Local functions
> ### Aliases: localFun localFun,RasterLayer,RasterLayer-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> set.seed(0)
> b <- stack(system.file("external/rlogo.grd", package="raster"))
> x <- flip(b[[2]], 'y') + runif(ncell(b))
> y <- b[[1]] + runif(ncell(b))
> 
> f <- localFun(x, y, fun=cor)
> 
> ## Not run: 
> ##D # local regression:
> ##D rfun <- function(x, y, ...) {
> ##D 	m <- lm(y~x)
> ##D 	# return R^2
> ##D 	summary(m)$r.squared
> ##D }
> ##D 
> ##D ff <- localFun(x, y, fun=rfun)
> ##D plot(f, ff)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("localFun", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mask")
> ### * mask
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mask
> ### Title: Mask values in a Raster object
> ### Aliases: mask mask,RasterLayer,RasterLayer-method
> ###   mask,RasterStackBrick,RasterLayer-method
> ###   mask,RasterLayer,RasterStackBrick-method
> ###   mask,RasterStackBrick,RasterStackBrick-method
> ###   mask,Raster,Spatial-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> m <- raster(ncol=10, nrow=10)
> r[] <- runif(ncell(r)) * 10
> m[] <- runif(ncell(r))
> m[m < 0.5] <- NA
> mr <- mask(r, m)
> 
> m2 <- m > .7
> mr2 <- mask(r, m2, maskvalue=TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mask", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("match")
> ### * match
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: match
> ### Title: Value matching for Raster* objects
> ### Aliases: match match,Raster-method %in% %in%,Raster-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> r <- raster(nrow=10, ncol=10)
> r[] <- 1:100
> m <- match(r, c(5:10, 50:55))
> n <- r %in% c(5:10, 50:55)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("match", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("merge")
> ### * merge
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: merge
> ### Title: Merge Raster* objects
> ### Aliases: merge merge,Raster,Raster-method
> ###   merge,RasterStackBrick,missing-method merge,Extent,ANY-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r1 <- raster(xmx=-150, ymn=60, ncols=30, nrows=30)
> r1[] <- 1:ncell(r1)
> r2 <- raster(xmn=-100, xmx=-50, ymx=50, ymn=30)
> res(r2) <- c(xres(r1), yres(r1))
> r2[] <- 1:ncell(r2)
> rm <- merge(r1, r2)
> 
> # if you have many RasterLayer objects in a list
> # you can use do.call:
> x <- list(r1, r2)
> # add arguments such as filename
> # x$filename <- 'test.tif'
> m <- do.call(merge, x)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("merge", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("metadata")
> ### * metadata
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: metadata
> ### Title: Metadata
> ### Aliases: metadata metadata<-
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster(nc=10, nr=10)
> r[] <- 1:ncell(r)
> 
> m <- list(wave=list(a=1, b=2, c=c('cool', 'important')), that=list(red='44', blue=1:5,
+        days=as.Date(c('2014-1-15','2014-2-15'))), this='888 miles from here', today=NA)
> 
> metadata(r) <- m
> x <- writeRaster(r, 'test.grd', overwrite=TRUE)
> metax <- metadata(x)
> 
> identical(metax, m)
[1] TRUE
> 
> ## Not run: 
> ##D # nested too deep
> ##D badmeta1 <- list(wave=list(a=1, b=2, c='x'), that=list(red='4', blue=list(bad=5)))
> ##D metadata(r) <- badmeta1
> ##D 
> ##D # missing names
> ##D badmeta2 <- list(wave=list(1, 2, c='x'), that=list(red='44', blue=14), this='8m')
> ##D metadata(r) <- badmeta2
> ##D 
> ##D # matrix not allowed
> ##D badmeta3 <- list(wave=list(a=1, b=matrix(1:4, ncol=2), c='x'), that=list(red='4'))
> ##D metadata(r) <- badmeta3
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("metadata", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("modal")
> ### * modal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: modal
> ### Title: modal value
> ### Aliases: modal modal,ANY-method modal,Raster-method
> ### Keywords: univar math
> 
> ### ** Examples
> 
> data <- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
> modal(data, na.rm=TRUE)
[1] 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("modal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mosaic")
> ### * mosaic
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mosaic
> ### Title: Merge Raster* objects using a function for overlapping areas
> ### Aliases: mosaic mosaic,Raster,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=100, nrow=100)
> r1 <- crop(r, extent(-10, 11, -10, 11))
> r2 <- crop(r, extent(0, 20, 0, 20))
> r3 <- crop(r, extent(9, 30, 9, 30))
> 
> r1[] <- 1:ncell(r1)
> r2[] <- 1:ncell(r2)
> r3[] <- 1:ncell(r3)
> 
> m1 <- mosaic(r1, r2, r3, fun=mean)
> 
> s1 <- stack(r1, r1*2)
> s2 <- stack(r2, r2/2)
> s3 <- stack(r3, r3*4)
> m2 <- mosaic(s1, s2, s3, fun=min)
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
Warning in FUN(newX[, i], ...) :
  no non-missing arguments to min; returning Inf
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mosaic", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("movingFun")
> ### * movingFun
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: movingFun
> ### Title: Moving functions
> ### Aliases: movingFun
> ### Keywords: spatial
> 
> ### ** Examples
> 
> movingFun(1:12, 3, mean)
 [1] NA  2  3  4  5  6  7  8  9 10 11 NA
> movingFun(1:12, 3, mean, 'to')
 [1] NA NA  2  3  4  5  6  7  8  9 10 11
> movingFun(1:12, 3, mean, 'from')
 [1]  2  3  4  5  6  7  8  9 10 11 NA NA
> movingFun(1:12, 3, mean, circular=TRUE)
 [1]  5  2  3  4  5  6  7  8  9 10 11  8
> 
> v <- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
> movingFun(v, n=5)
 [1]  NA  NA 1.8 2.4 2.8 3.2 3.4 3.6 4.0 4.4 4.8 5.4 6.0 6.6 7.4  NA  NA  NA
> movingFun(v, n=5, na.rm=TRUE)
 [1] 1.00 1.50 1.80 2.40 2.80 3.20 3.40 3.60 4.00 4.40 4.80 5.40 6.00 6.60 7.40
[16] 7.75 8.00 8.50
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("movingFun", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("names")
> ### * names
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: names
> ### Title: Names of raster layers
> ### Aliases: labels,Raster-method names names<- names,Raster-method
> ###   names,RasterStack-method names<-,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=5, nrows=5)
> r[] <- 1:ncell(r)
> s <- stack(r, r, r)
> nlayers(s)
[1] 3
> names(s)
[1] "layer.1" "layer.2" "layer.3"
> names(s) <- c('a', 'b', 'c')
> names(s)[2] <- 'hello world'
> names(s)
[1] "a"           "hello.world" "c"          
> s
class       : RasterStack 
dimensions  : 5, 5, 25, 3  (nrow, ncol, ncell, nlayers)
resolution  : 72, 36  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
names       :  a, hello.world,  c 
min values  :  1,           1,  1 
max values  : 25,          25, 25 

> labels(s)
[1] "a"           "hello.world" "c"          
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("names", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ncell")
> ### * ncell
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ncell
> ### Title: Number or rows, columns, and cells of a Raster* object
> ### Aliases: ncol nrow nrow,BasicRaster-method ncol,BasicRaster-method
> ###   ncell ncell,ANY-method ncell,BasicRaster-method
> ###   length,BasicRaster-method nrow<- ncol<-
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> ncell(r)
[1] 64800
> ncol(r)
[1] 360
> nrow(r)
[1] 180
> dim(r)
[1] 180 360   1
> 
> nrow(r) <- 18
> ncol(r) <- 36
> # equivalent to
> dim(r) <- c(18, 36) 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ncell", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nlayers")
> ### * nlayers
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nlayers
> ### Title: Number of layers
> ### Aliases: nlayers nlayers,BasicRaster-method nlayers,Raster-method
> ###   nlayers,RasterStack-method nlayers,RasterBrick-method
> ###   nlayers,Spatial-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> r[] <- 1:ncell(r)
> s <- stack(r, r, r)
> nlayers(s)
[1] 3
> s <- stack(s,s)
> nlayers(s)
[1] 6
> s <- dropLayer(s, 2:3)
> nlayers(s)
[1] 4
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nlayers", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("origin")
> ### * origin
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: origin
> ### Title: Origin
> ### Aliases: origin origin,BasicRaster-method origin<-
> ###   origin<-,BasicRaster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(xmn=-0.5, xmx = 9.5, ncols=10)
> origin(r)
[1] 0.5 0.0
> r
class       : RasterLayer 
dimensions  : 180, 10, 1800  (nrow, ncol, ncell)
resolution  : 1, 1  (x, y)
extent      : -0.5, 9.5, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 

> origin(r) <- 0
> r
class       : RasterLayer 
dimensions  : 180, 10, 1800  (nrow, ncol, ncell)
resolution  : 1, 1  (x, y)
extent      : 0, 10, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("origin", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("overlay")
> ### * overlay
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: overlay
> ### Title: Overlay Raster objects
> ### Aliases: overlay overlay,Raster,Raster-method
> ###   overlay,Raster,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r1 <- init(r, fun=runif)
> r2 <- init(r, fun=runif)
> r3 <- overlay(r1, r2, fun=function(x,y){return(x+y)})
> 
> # long version for multiplication
> r4 <- overlay(r1, r2, fun=function(x,y){(x*y)} )
> 
> #use the individual layers of a RasterStack to get a RasterLayer
> s <- stack(r1, r2)
> r5 <- overlay(s, fun=function(x,y) x*y )
> # equivalent to
> r5c <- calc(s, fun=function(x) x[1]*x[2] )
> 
> 
> #Combine RasterStack and RasterLayer objects (s2 has four layers. 
> # r1 (one layer) and s (two layers) are recycled) 
> s2 <- stack(r1, r2, r3, r4)
> b <- overlay(r1, s, s2, fun=function(x,y,z){return(x*y*z)} )
> 
> # use a single RasterLayer (same as calc function)
> r6 <- overlay(r1, fun=sqrt)
> 
> # multiplication with more than two layers 
> # (make sure the number of RasterLayers matches the arguments of 'fun')
> r7 <- overlay(r1, r2, r3, r4, fun=function(a,b,c,d){return(a*b+c*d)} )  
> # equivalent function, efficient if values can be loaded in memory
> r8 <- r1 * r2 + r3 * r4
> 
> # Also works with multi-layer objects. 
> s1 <- stack(r1, r2, r3)
> x <- overlay(s1, s1, fun=function(x,y)x+y+5)
> 
> # in this case the first layer of the shorter object is recycled.
> # i.e., s2 is treated as stack(r1, r3, r1)
> s2 <- stack(r1, r3)
> y <- overlay(s1, s2, fun=sum)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("overlay", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pairs")
> ### * pairs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pairs
> ### Title: Pairs plot (matrix of scatterplots)
> ### Aliases: pairs pairs,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster") )
> s <- stack(r, 1/r, sqrt(r))
> pairs(s)
> 
> ## Not run: 
> ##D # to make indvidual histograms:
> ##D hist(r)
> ##D # or scatter plots:
> ##D plot(r, 1/r)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pairs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("persp")
> ### * persp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: persp
> ### Title: Perspective plot
> ### Aliases: persp persp,RasterLayer-method persp,RasterStackBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> persp(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("persp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot")
> ### * plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot
> ### Title: Plot a Raster* object
> ### Aliases: plot plot,Raster,ANY-method plot,Raster,Raster-method
> ###   plot,Extent,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> # RasterLayer
> r <- raster(nrows=10, ncols=10)
> r <- setValues(r, 1:ncell(r))
> plot(r)
> 
> e <- extent(r)
> plot(e, add=TRUE, col='red', lwd=4)
> e <- e / 2
> plot(e, add=TRUE, col='red')
> 
> 
> # Scatterplot of 2 RasterLayers
> r2 <- sqrt(r)
> plot(r, r2)
> plot(r, r2, gridded=TRUE)
> 
> # Multi-layer object (RasterStack / Brick)
> s <- stack(r, r2, r/r)
> plot(s, 2)
> plot(s)
> 
> # two objects, different range, one scale:
> r[] <- runif(ncell(r))
> r2 <- r/2
> brks <- seq(0, 1, by=0.1) 
> nb <- length(brks)-1 
> cols <- rev(terrain.colors(nb))
> par(mfrow=c(1,2))
> plot(r, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='first') 
> plot(r2, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='second') 
> 
> 
> # breaks and labels
> x <- raster(nc=10, nr=10)
> x[] <- runif(ncell(x))
> brk <- c(0, 0.25, 0.75, 1)
> arg <- list(at=c(0.12,0.5,0.87), labels=c("Low","Med.","High"))
> plot(x, col=terrain.colors(3), breaks=brk)
> plot(x, col=terrain.colors(3), breaks=brk, axis.args=arg)
> par(mfrow=c(1,1))
> 
> # color ramp
> plot(x, col=colorRampPalette(c("red", "white", "blue"))(255))
> 
> # adding random points to the map
> xy <- cbind(-180 + runif(10) * 360, -90 + runif(10) * 180)
> points(xy, pch=3, cex=5)
> 
> # for SpatialPolygons do
> # plot(pols, add=TRUE)
> 
> # adding the same points to each map of each layer of a RasterStack
> fun <- function() {
+ 	points(xy, cex=2)
+ 	points(xy, pch=3, col='red')
+ }
> plot(s, addfun=fun)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plotRGB")
> ### * plotRGB
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotRGB
> ### Title: Red-Green-Blue plot of a multi-layered Raster object
> ### Aliases: plotRGB plotRGB,RasterStackBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> plotRGB(b)
> plotRGB(b, 3, 2, 1)
> plotRGB(b, 3, 2, 1, stretch='hist')
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotRGB", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pointdistance")
> ### * pointdistance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pointDistance
> ### Title: Distance between points
> ### Aliases: pointDistance
> ### Keywords: spatial
> 
> ### ** Examples
> 
> a <- cbind(c(1,5,55,31),c(3,7,20,22))
> b <- cbind(c(4,2,8,65),c(50,-90,20,32))   
> 
> pointDistance(c(0, 0), c(1, 1), lonlat=FALSE)
[1] 1.414214
> pointDistance(c(0, 0), c(1, 1), lonlat=TRUE)
[1] 157425.5
> pointDistance(c(0, 0), a, lonlat=TRUE)
[1]  352007.1  956800.1 6388112.7 4159808.1
> pointDistance(a, b, lonlat=TRUE)
[1]  5239684 10797991  4899364  3534050
>    
> #Make a distance matrix 
> dst <- pointDistance(a, lonlat=TRUE)
> # coerce to dist object
> dst <- as.dist(dst)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pointdistance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("predict")
> ### * predict
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict
> ### Title: Spatial model predictions
> ### Aliases: predict predict,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> # A simple model to predict the location of the R in the R-logo using 20 presence points 
> # and 50 (random) pseudo-absence points. This type of model is often used to predict
> # species distributions. See the dismo package for more of that.
> 
> # create a RasterStack or RasterBrick with with a set of predictor layers
> logo <- brick(system.file("external/rlogo.grd", package="raster"))
> names(logo)
[1] "red"   "green" "blue" 
> 
> ## Not run: 
> ##D # the predictor variables
> ##D par(mfrow=c(2,2))
> ##D plotRGB(logo, main='logo')
> ##D plot(logo, 1, col=rgb(cbind(0:255,0,0), maxColorValue=255))
> ##D plot(logo, 2, col=rgb(cbind(0,0:255,0), maxColorValue=255))
> ##D plot(logo, 3, col=rgb(cbind(0,0,0:255), maxColorValue=255))
> ##D par(mfrow=c(1,1))
> ## End(Not run)
> 
> # known presence and absence points
> p <- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, 
+    66, 42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, 
+    22, 34, 60, 70, 73, 63, 46, 43, 28), ncol=2)
> 
> a <- matrix(c(22, 33, 64, 85, 92, 94, 59, 27, 30, 64, 60, 33, 31, 9,
+    99, 67, 15, 5, 4, 30, 8, 37, 42, 27, 19, 69, 60, 73, 3, 5, 21,
+    37, 52, 70, 74, 9, 13, 4, 17, 47), ncol=2)
> 
> # extract values for points
> xy <- rbind(cbind(1, p), cbind(0, a))
> v <- data.frame(cbind(xy[,1], extract(logo, xy[,2:3])))
> colnames(v)[1] <- 'pa'
> 
> #build a model, here an example with glm 
> model <- glm(formula=pa~., data=v)
> 
> #predict to a raster
> r1 <- predict(logo, model, progress='text')
  |                                                                              |                                                                      |   0%  |                                                                              |==================                                                    |  25%  |                                                                              |===================================                                   |  50%  |                                                                              |====================================================                  |  75%  |                                                                              |======================================================================| 100%

> 
> plot(r1)
> points(p, bg='blue', pch=21)
> points(a, bg='red', pch=21)
> 
> # use a modified function to get a RasterBrick with p and se
> # from the glm model. The values returned by 'predict' are in a list,
> # and this list needs to be transformed to a matrix
> 
> predfun <- function(model, data) {
+   v <- predict(model, data, se.fit=TRUE)
+   cbind(p=as.vector(v$fit), se=as.vector(v$se.fit))
+ }
> 
> # predfun returns two variables, so use index=1:2
> r2 <- predict(logo, model, fun=predfun, index=1:2)
> 
> 
> ## Not run: 
> ##D # You can use multiple cores to speed up the predict function
> ##D # by calling it via the clusterR function
> ##D beginCluster()
> ##D r1c <- clusterR(logo, predict, args=list(model))
> ##D r2c <- clusterR(logo, predict, args=list(model=model, fun=predfun, index=1:2))
> ## End(Not run)
> 
> # principal components of a RasterBrick
> # here using sampling to simulate an object too large
> # too feed all its values to prcomp
> sr <- sampleRandom(logo, 100)
> pca <- prcomp(sr)
> 
> # note the use of the 'index' argument
> x <- predict(logo, pca, index=1:3)
> plot(x)
> 
> ## Not run: 
> ##D library(randomForest)
> ##D rfmod <- randomForest(pa ~., data=v)
> ##D 
> ##D ## note the additional argument "type='response'" that is 
> ##D ## passed to predict.randomForest
> ##D r3 <- predict(logo, rfmod, type='response', progress='window')
> ##D 
> ##D ## get a RasterBrick with class membership probabilities
> ##D vv <- v
> ##D vv$pa <- as.factor(vv$pa)
> ##D rfmod2 <- randomForest(pa ~., data=vv)
> ##D r4 <- predict(logo, rfmod2, type='prob', index=1:2)
> ##D spplot(r4)
> ##D 
> ##D # cforest example with factors argument
> ##D v$red <- as.factor(round(v$red/100))
> ##D logo$red <- round(logo[[1]]/100)
> ##D library(party)
> ##D m <- cforest(pa~., control=cforest_unbiased(mtry=3), data=v)
> ##D f <- list(levels(v$red))
> ##D names(f) <- 'red'
> ##D pc <- predict(logo, m, OOB=TRUE, factors=f)
> ##D 
> ##D 
> ##D # knn example, using calc instead of predict
> ##D library(class)
> ##D cl <- factor(c(rep(1, nrow(p)), rep(0, nrow(a))))
> ##D train <- extract(logo, rbind(p, a))
> ##D k <- calc(logo, function(x) as.integer(as.character(knn(train, x, cl))))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("programming")
> ### * programming
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Programming
> ### Title: Helper functions for programming
> ### Aliases: readStart readStop readStart,Raster-method
> ###   readStart,RasterStack-method readStop,Raster-method
> ###   readStop,RasterStack-method canProcessInMemory pbCreate pbStep
> ###   pbClose getCluster returnCluster
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=100, ncol=100)
> canProcessInMemory(r, 4)
[1] TRUE
> r <- raster(nrow=100000, ncol=100000)
> canProcessInMemory(r, 2)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("programming", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("projectRaster")
> ### * projectRaster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projectRaster
> ### Title: Project a Raster object
> ### Aliases: projectRaster projectExtent
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # create a new (not projected) RasterLayer with cellnumbers as values
> r <- raster(xmn=-110, xmx=-90, ymn=40, ymx=60, ncols=40, nrows=40)
> r <- setValues(r, 1:ncell(r))
> projection(r)
[1] "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
> # proj.4 projection description
> newproj <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
> 
> # we need the rgdal package for this
> if (require(rgdal)) {
+ 
+ #simplest approach
+ pr1 <- projectRaster(r, crs=newproj)
+ 
+ # alternatively also set the resolution
+ pr2 <- projectRaster(r, crs=newproj, res=20000)
+ 
+ # inverse projection, back to the properties of 'r'
+ inv <- projectRaster(pr2, r)
+ 
+ # to have more control, provide an existing Raster object, here we create one
+ # using projectExtent (no values are transferred)
+ pr3 <- projectExtent(r, newproj)
+ # Adjust the cell size 
+ res(pr3) <- 200000
+ # now project
+ pr3 <- projectRaster(r, pr3)
+ 
+ ## Not run: 
+ ##D # using a higher resolution
+ ##D res(pr1) <- 10000
+ ##D pr <- projectRaster(r, pr1, method='bilinear')
+ ##D inv <- projectRaster(pr, r, method='bilinear')
+ ##D dif <- r - inv
+ ##D # small difference
+ ##D plot(dif)
+ ## End(Not run)
+ 
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projectRaster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’

> nameEx("projection")
> ### * projection
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: projection
> ### Title: Get or set a coordinate reference system (projection)
> ### Aliases: crs crs,ANY-method crs<- projection projection<- proj4string
> ###   proj4string<- as.character,CRS-method is.na,CRS-method
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster()
> crs(r)
CRS arguments:
 +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
> crs(r) <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
> crs(r)
CRS arguments:
 +proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("projection", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("properties")
> ### * properties
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: properties
> ### Title: Raster file properties
> ### Aliases: dataSize dataSigned
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> dataSize(r)
[1] 4
> dataSigned(r)
[1] TRUE
> dataType(r)
[1] "FLT4S"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("properties", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("quantile")
> ### * quantile
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: quantile
> ### Title: Raster quantiles
> ### Aliases: quantile quantile,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=100, nrow=100)
> r[] <- rnorm(ncell(r), 0, 50)
> quantile(r)
          0%          25%          50%          75%         100% 
-183.5649966  -33.6697177   -0.7964414   33.8830237  190.5138340 
> quantile(r, probs = c(0.25, 0.75), type=7,names = FALSE)
[1] -33.66972  33.88302
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("quantile", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("raster")
> ### * raster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: raster
> ### Title: Create a RasterLayer object
> ### Aliases: raster raster,missing-method raster,character-method
> ###   raster,Extent-method raster,BasicRaster-method
> ###   raster,RasterLayer-method raster,RasterLayerSparse-method
> ###   raster,RasterStack-method raster,RasterBrick-method
> ###   raster,Spatial-method raster,SpatialGrid-method
> ###   raster,SpatialPixels-method raster,matrix-method
> ###   raster,big.matrix-method raster,list-method raster,im-method
> ###   raster,asc-method raster,kasc-method raster,kde-method
> ###   raster,grf-method raster,GridTopology-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> # Create a RasterLayer object from a file
> #   N.B.: For your own files, omit the 'system.file' and 'package="raster"' bits
> #   these are just to get the path to files installed with the package
> 
> f <- system.file("external/test.grd", package="raster")
> f
[1] "/Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd"
> r <- raster(f)
> 
> logo <- raster(system.file("external/rlogo.grd", package="raster")) 
> 
> 
> #from scratch
> r1 <- raster(nrows=108, ncols=21, xmn=0, xmx=10)
> 
> #from an Extent object
> e <- extent(r)
> r2 <- raster(e)
> 
> #from another Raster* object
> r3 <- raster(r)
> s <- stack(r, r, r)
> r4 <- raster(s)
> r5 <- raster(s, 3)
> 
> 
> ## Not run: 
> ##D # from NSIDC sea ice concentration file
> ##D baseurl <- "ftp://sidads.colorado.edu/pub/DATASETS/"
> ##D # southern hemisphere
> ##D f1 <- paste(baseurl, 
> ##D  "nsidc0051_gsfc_nasateam_seaice/final-gsfc/south/daily/2013/nt_20130114_f17_v01_s.bin",
> ##D  sep='')
> ##D # or northern hemisphere
> ##D f2 <- paste(baseurl, 
> ##D  "nsidc0051_gsfc_nasateam_seaice/final-gsfc/north/daily/2013/nt_20130105_f17_v01_n.bin",
> ##D  sep='')
> ##D      
> ##D if (!file.exists(basename(f1))) download.file(f1, basename(f1), mode = "wb")
> ##D ice1 <- raster(basename(f1))
> ##D 
> ##D if (!file.exists(basename(f2))) download.file(f2, basename(f2), mode = "wb")
> ##D ice2 <- raster(basename(f2))
> ##D      
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("raster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterFromCells")
> ### * rasterFromCells
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterFromCells
> ### Title: Subset a raster by cell numbers
> ### Aliases: rasterFromCells
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=100, nrows=100)
> cells <- c(3:5, 210)
> r <- rasterFromCells(r, cells)
> cbind(1:ncell(r), getValues(r))
      [,1] [,2]
 [1,]    1    3
 [2,]    2    4
 [3,]    3    5
 [4,]    4    6
 [5,]    5    7
 [6,]    6    8
 [7,]    7    9
 [8,]    8   10
 [9,]    9  103
[10,]   10  104
[11,]   11  105
[12,]   12  106
[13,]   13  107
[14,]   14  108
[15,]   15  109
[16,]   16  110
[17,]   17  203
[18,]   18  204
[19,]   19  205
[20,]   20  206
[21,]   21  207
[22,]   22  208
[23,]   23  209
[24,]   24  210
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterFromCells", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterFromXYZ")
> ### * rasterFromXYZ
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterFromXYZ
> ### Title: Create a Raster* object from x, y, z values
> ### Aliases: rasterFromXYZ
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=10, ncol=10, xmn=0, xmx=10, ymn=0, ymx=10, crs=NA)
> r[] <- runif(ncell(r))
> r[r<0.5] <- NA
> xyz <- rasterToPoints(r)
> 
> r2 <- rasterFromXYZ(xyz)
> 
> # equivalent to:
> r3 <- raster(nrow=10, ncol=10, xmn=0, xmx=10, ymn=0, ymx=10)
> cells <- cellFromXY(r3, xyz[,1:2])
> r3[cells] <- xyz[,3]
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterFromXYZ", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterOptions")
> ### * rasterOptions
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Options
> ### Title: Global options for the raster package
> ### Aliases: rasterOptions tmpDir
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D rasterOptions()
> ##D rasterOptions(chunksize=2e+07) 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterOptions", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterTmpFile")
> ### * rasterTmpFile
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterTmpFile
> ### Title: Temporary files
> ### Aliases: rasterTmpFile removeTmpFiles showTmpFiles
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D rasterTmpFile('mytemp_')
> ##D showTmpFiles()
> ##D removeTmpFiles(h=24)
> ##D 
> ##D # It is possible (but undesirable!) to create overlapping temp file names. 
> ##D for (i in 1:10) {
> ##D 	set.seed(0)
> ##D 	print(rasterTmpFile())
> ##D }
> ##D That can be avoided by using a prefix 
> ##D for (i in 1:10) {
> ##D 	set.seed(0)
> ##D 	print(rasterTmpFile(prefix=paste('i', i, '_', sep='')))
> ##D }
> ##D 
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterTmpFile", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterToContour")
> ### * rasterToContour
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterToContour
> ### Title: Raster to contour lines conversion
> ### Aliases: rasterToContour
> ### Keywords: spatial
> 
> ### ** Examples
> 
> f <- system.file("external/test.grd", package="raster")
> r <- raster(f)
> x <- rasterToContour(r)
> class(x)
[1] "SpatialLinesDataFrame"
attr(,"package")
[1] "sp"
> plot(r)
> plot(x, add=TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterToContour", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterToPoints")
> ### * rasterToPoints
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterToPoints
> ### Title: Raster to points conversion
> ### Aliases: rasterToPoints
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster(nrow=18, ncol=36)
> r[] <- runif(ncell(r)) * 10
> r[r>8] <- NA
> p <- rasterToPoints(r)
> p <- rasterToPoints(r, fun=function(x){x>6})
> #plot(r)
> #points(p)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterToPoints", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterToPolygons")
> ### * rasterToPolygons
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterToPolygons
> ### Title: Raster to polygons conversion
> ### Aliases: rasterToPolygons
> ### Keywords: spatial
> 
> ### ** Examples
>  
> r <- raster(nrow=18, ncol=36)
> r[] <- runif(ncell(r)) * 10
> r[r>8] <- NA
> pol <- rasterToPolygons(r, fun=function(x){x>6})
> #plot(r)
> #plot(pol, add=T, col='red')
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterToPolygons", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rasterize")
> ### * rasterize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rasterize
> ### Title: Rasterize points, lines, or polygons
> ### Aliases: rasterize rasterize,matrix,Raster-method
> ###   rasterize,data.frame,Raster-method
> ###   rasterize,SpatialPoints,Raster-method
> ###   rasterize,SpatialLines,Raster-method
> ###   rasterize,SpatialPolygons,Raster-method
> ###   rasterize,Extent,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> 
> ###############################
> # rasterize points
> ###############################
> r <- raster(ncols=36, nrows=18)
> n <- 1000
> x <- runif(n) * 360 - 180
> y <- runif(n) * 180 - 90
> xy <- cbind(x, y)
> # get the (last) indices
> r0 <- rasterize(xy, r)
> # prensence/absensce (NA) (is there a point or not?)
> r1 <- rasterize(xy, r, field=1)
> # how many points?
> r2 <- rasterize(xy, r, fun=function(x,...)length(x))
> vals <- runif(n)
> # sum of the values associated with the points
> r3 <- rasterize(xy, r, vals, fun=sum)
> 
> # with a SpatialPointsDataFrame
> vals <- 1:n
> p <- data.frame(xy, name=vals)
> coordinates(p) <- ~x+y
> r <- rasterize(p, r, 'name', fun=min)
> #r2 <- rasterize(p, r, 'name', fun=max)
> #plot(r, r2, cex=0.5)
> 
> ###############################
> # rasterize lines
> ###############################
> cds1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
> cds2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
> cds3 <- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
> 
> lines <- spLines(cds1, cds2, cds3)
> 
> r <- raster(ncols=90, nrows=45)
> r <- rasterize(lines, r)
> 
> ## Not run: 
> ##D plot(r)
> ##D plot(lines, add=TRUE)
> ##D 
> ##D r <- rasterize(lines, r, fun='count')
> ##D plot(r)
> ##D 
> ##D r[] <- 1:ncell(r)
> ##D r <- rasterize(lines, r, mask=TRUE)
> ##D plot(r)
> ##D 
> ##D r[] <- 1
> ##D r[lines] <- 10
> ##D plot(r)
> ## End(Not run)
> 
> ###############################
> # rasterize polygons
> ###############################
> 
> p1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
> hole <- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20))
> p1 <- list(p1, hole)
> p2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
> p3 <- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45), c(-125,0))
> 
> pols <- spPolygons(p1, p2, p3)
> 
> r <- raster(ncol=90, nrow=45)
> r <- rasterize(pols, r, fun=sum)
> 
> 
> ## Not run: 
> ##D 
> ##D plot(r)
> ##D plot(pols, add=T)
> ##D 
> ##D # add a polygon
> ##D p5 <- rbind(c(-180,10), c(0,90), c(40,90), c(145,-10),  
> ##D             c(-25, -15), c(-180,0), c(-180,10))
> ##D addpoly <- SpatialPolygons(list(Polygons(list(Polygon(p5)), 1)))
> ##D addpoly <- as(addpoly, "SpatialPolygonsDataFrame")
> ##D addpoly@data[1,1] <- 10
> ##D r2 <- rasterize(addpoly, r, field=1, update=TRUE, updateValue="NA")
> ##D plot(r2)
> ##D plot(pols, border="blue", lwd=2, add=TRUE)
> ##D plot(addpoly, add=TRUE, border="red", lwd=2)
> ##D 
> ##D # get the percentage cover of polygons in a cell
> ##D r3 <- raster(ncol=36, nrow=18)
> ##D r3 <- rasterize(pols, r3, getCover=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rasterize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readAll")
> ### * readAll
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readAll
> ### Title: Read values from disk
> ### Aliases: readAll,RasterLayer-method readAll,RasterStack-method
> ###   readAll,RasterBrick-method readAll
> ### Keywords: classes spatial
> 
> ### ** Examples
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> r <- readAll(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readAll", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("reclassify")
> ### * reclassify
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: reclassify
> ### Title: Reclassify
> ### Aliases: reclassify reclassify,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> r <- raster(ncols=36, nrows=18)
> r[] <- runif(ncell(r)) 
> # reclassify the values into three groups 
> # all values >= 0 and <= 0.25 become 1, etc.
> m <- c(0, 0.25, 1,  0.25, 0.5, 2,  0.5, 1, 3)
> rclmat <- matrix(m, ncol=3, byrow=TRUE)
> rc <- reclassify(r, rclmat)
> 
> # equivalent to
> rc <- reclassify(r, c(-Inf,0.25,1, 0.25,0.5,2, 0.5,Inf,3))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("reclassify", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("replacement")
> ### * replacement
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: replacement
> ### Title: Replace cell values or layers of a Raster* object
> ### Aliases: [<-,RasterLayer,RasterLayer,missing-method
> ###   [<-,RasterLayer,missing,missing-method
> ###   [<-,RasterStackBrick,Raster,missing-method
> ###   [<-,RasterStackBrick,missing,missing-method
> ###   [[<-,RasterStack,numeric,missing-method
> ###   [[<-,RasterBrick,numeric,missing-method
> ###   [[<-,RasterStackBrick,character,missing-method
> ###   [<-,Raster,numeric,numeric-method [<-,Raster,numeric,missing-method
> ###   [<-,Raster,matrix,missing-method [<-,Raster,logical,missing-method
> ###   [<-,Raster,missing,numeric-method [<-,Raster,Spatial,missing-method
> ###   [<-,Raster,Extent,missing-method [<-,Extent,numeric,missing-method
> ###   $<-,Raster-method $,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=5)
> r[] <- 1:ncell(r) * 2
> r[1,] <- 1
> r[,1] <- 2
> r[1,1] <- 3
> 
> s <- stack(r, sqrt(r))
> s[s<5] <- NA
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("replacement", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("resample")
> ### * resample
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: resample
> ### Title: Resample a Raster object
> ### Aliases: resample resample,Raster,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=3, ncol=3)
> r[] <- 1:ncell(r)
> s <- raster(nrow=10, ncol=10)
> s <- resample(r, s, method='bilinear')
> #par(mfrow=c(1,2))
> #plot(r)
> #plot(s)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("resample", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("resolution")
> ### * resolution
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: resolution
> ### Title: Resolution
> ### Aliases: xres yres res xres,BasicRaster-method yres,BasicRaster-method
> ###   res,BasicRaster-method res<-
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=18, nrow=18)
> xres(r)
[1] 20
> yres(r)
[1] 10
> res(r)
[1] 20 10
> 
> res(r) <- 1/120
> # set yres differently
> res(r) <- c(1/120, 1/60)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("resolution", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rotate")
> ### * rotate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rotate
> ### Title: Rotate
> ### Aliases: rotate rotate,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> r <- raster(nrow=18, ncol=36)
> m <- matrix(1:ncell(r), nrow=18)
> r[] <- as.vector(t(m))
> extent(r) <- extent(0, 360, -90, 90)
> rr <- rotate(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rotate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rotated")
> ### * rotated
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rotated
> ### Title: Do the raster cells have a rotation?
> ### Aliases: rotated
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> rotated(r)
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rotated", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("round")
> ### * round
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: round
> ### Title: Integer values
> ### Aliases: round,RasterLayer-method trunc,RasterLayer-method
> ###   ceiling,RasterLayer-method floor,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r[] <- runif(ncell(r)) * 10
> s <- round(r)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("round", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("roundExtent")
> ### * roundExtent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Extent math
> ### Title: round Extent coordinates
> ### Aliases: floor,Extent-method ceiling,Extent-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> e <- extent(c(0.999999,  10.000011, -60.4, 60))
> round(e)
class       : Extent 
xmin        : 1 
xmax        : 10 
ymin        : -60 
ymax        : 60 
> ceiling(e)
class       : Extent 
xmin        : 1 
xmax        : 10 
ymin        : -60 
ymax        : 60 
> floor(e)
class       : Extent 
xmin        : 0 
xmax        : 11 
ymin        : -61 
ymax        : 60 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("roundExtent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rowFromCell")
> ### * rowFromCell
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rowFromCell
> ### Title: Row or column number from a cell number
> ### Aliases: colFromCell rowFromCell rowColFromCell
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> colFromCell(r, c(5,15))
[1] 5 5
> rowFromCell(r, c(5,15))
[1] 1 2
> rowColFromCell(r, c(5,15))
     row col
[1,]   1   5
[2,]   2   5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rowFromCell", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sampleInt")
> ### * sampleInt
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SampleInt
> ### Title: Sample integer values
> ### Aliases: sampleInt
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   sampleInt(1e+12, 10)
 [1] 265508663143 372123899637 572853363352 908207789995 201681931038
 [6] 898389684968 944675268606 660797792487 629114043899  61786270468
>   
> # this may fail:
> #  sample.int(1e+12, 10)
> #  sample.int(1e+9, 10)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sampleInt", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sampleRandom")
> ### * sampleRandom
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sampleRandom
> ### Title: Random sample
> ### Aliases: sampleRandom sampleRandom,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
>  r <- raster(system.file("external/test.grd", package="raster"))
>  sampleRandom(r, size=10)
 [1] 629.172 307.217 230.684 207.532 424.737 316.995 614.457 427.112 296.062
[10] 502.993
>  s <- stack(r, r)
>  sampleRandom(s, size=5, cells=TRUE, sp=TRUE)
class       : SpatialPointsDataFrame 
features    : 5 
extent      : 178820, 180660, 330420, 332420  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
variables   : 3
names       : cell,           test.1,           test.2 
min values  : 3177, 225.768997192383, 225.768997192383 
max values  : 7146, 666.588989257812, 666.588989257812 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sampleRandom", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sampleRegular")
> ### * sampleRegular
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sampleRegular
> ### Title: Regular sample
> ### Aliases: sampleRegular sampleRegular,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
>  r <- raster(system.file("external/test.grd", package="raster"))
>  v <- sampleRegular(r, size=100)
>  x <- sampleRegular(r, size=100, asRaster=TRUE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sampleRegular", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sampleStratified")
> ### * sampleStratified
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sampleStratified
> ### Title: Stratified random sample
> ### Aliases: sampleStratified sampleStratified,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
>  r <- raster(ncol=10, nrow=10)
>  names(r) <- 'stratum'
>  r[] <- round((runif(ncell(r))+0.5)*3)
>  sampleStratified(r, size=3)
      cell stratum
 [1,]   64       2
 [2,]   34       2
 [3,]   24       2
 [4,]  100       3
 [5,]   60       3
 [6,]   23       3
 [7,]   15       4
 [8,]   46       4
 [9,]   87       4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sampleStratified", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("saveStack")
> ### * saveStack
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stackSave
> ### Title: Save or open a RasterStack file
> ### Aliases: stackSave stackOpen
> ### Keywords: spatial
> 
> ### ** Examples
> 
> file <- system.file("external/test.grd", package="raster")
> s <- stack(c(file, file))
> s <- stackSave(s, "mystack")
> # note that filename adds an extension .stk to a stackfile  
> ## Not run: 
> ##D s2 <- stackOpen("mystack.stk")
> ##D s2
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("saveStack", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("scale")
> ### * scale
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: scale
> ### Title: Scale values
> ### Aliases: scale scale,Raster-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> bs <- scale(b)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("scale", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("scalebar")
> ### * scalebar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: scalebar
> ### Title: scalebar
> ### Aliases: scalebar
> ### Keywords: spatial
> 
> ### ** Examples
> 
> f <- system.file("external/test.grd", package="raster")
> r <- raster(f)
> plot(r)
> scalebar(1000)
> scalebar(1000, xy=c(178000, 333500), type='bar', divs=4)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("scalebar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("select")
> ### * select
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: select
> ### Title: Geometric subsetting
> ### Aliases: select select,Raster-method select,Spatial-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # select a subset of a RasterLayer
> ##D r <- raster(nrow=10, ncol=10)
> ##D r[] <- 1:ncell(r)
> ##D plot(r)
> ##D s <- select(r) # now click on the map twice
> ##D 
> ##D # plot the selection on a new canvas:
> ##D x11()
> ##D plot(s)
> ##D 
> ##D 
> ##D # select a subset of a SpatialPolygons object
> ##D p1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
> ##D hole <- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20))
> ##D p2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
> ##D p3 <- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45), c(-125,0))
> ##D pols <- SpatialPolygons( list(  Polygons(list(Polygon(p1), Polygon(hole)), 1),
> ##D       Polygons(list(Polygon(p2)), 2), Polygons(list(Polygon(p3)), 3)))
> ##D pols@polygons[[1]]@Polygons[[2]]@hole <- TRUE
> ##D 
> ##D plot(pols, col=rainbow(3))
> ##D ps <- select(pols) # now click on the map twice
> ##D ps
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("select", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setExtent")
> ### * setExtent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setExtent
> ### Title: Set the extent of a RasterLayer
> ### Aliases: setExtent extent<-
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> bb <- extent(-10, 10, -20, 20)
> extent(r) <- bb
> r <- setExtent(r, bb, keepres=TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setExtent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setMinMax")
> ### * setMinMax
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setMinMax
> ### Title: Compute min and max values
> ### Aliases: setMinMax,RasterLayer-method setMinMax,RasterStack-method
> ###   setMinMax,RasterBrick-method setMinMax
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> r
class       : RasterLayer 
dimensions  : 115, 80, 9200  (nrow, ncol, ncell)
resolution  : 40, 40  (x, y)
extent      : 178400, 181600, 329400, 334000  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd 
names       : test 
values      : 128.434, 1805.78  (min, max)

> r <- setMinMax(r)
> r
class       : RasterLayer 
dimensions  : 115, 80, 9200  (nrow, ncol, ncell)
resolution  : 40, 40  (x, y)
extent      : 178400, 181600, 329400, 334000  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd 
names       : test 
values      : 128.434, 1805.78  (min, max)

> 	
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setMinMax", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setValues")
> ### * setValues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setValues
> ### Title: Set values of a Raster object
> ### Aliases: values<- values<-,RasterLayer-method
> ###   values<-,RasterLayerSparse-method values<-,RasterStack-method
> ###   values<-,RasterBrick-method setValues setValues,RasterLayer-method
> ###   setValues,RasterLayerSparse-method setValues,RasterStack-method
> ###   setValues,RasterBrick-method
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> r <- raster(ncol=10, nrow=10)
> vals <- 1:ncell(r)
> r <- setValues(r, vals)
> # equivalent to
> r[] <- vals
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setValues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("shapefile")
> ### * shapefile
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: shapefile
> ### Title: Read or write a shapefile
> ### Aliases: shapefile shapefile,character-method shapefile,Spatial-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> if (require(rgdal)) {
+ 
+ filename <- system.file("external/lux.shp", package="raster")
+ filename
+ p <- shapefile(filename)
+ 
+ ## Not run: 
+ ##D shapefile(p, 'copy.shp')
+ ## End(Not run)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("shapefile", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’

> nameEx("shift")
> ### * shift
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: shift
> ### Title: Shift
> ### Aliases: shift shift,Raster-method shift,SpatialPolygons-method
> ###   shift,SpatialLines-method shift,SpatialPoints-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster()
> r <- shift(r, x=1, y=-1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("shift", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spEasy")
> ### * spEasy
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sp
> ### Title: Create SpatialLines* or SpatialPolygons*
> ### Aliases: spLines spPolygons
> ### Keywords: spatial
> 
> ### ** Examples
> 
> x1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
> x2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
> x3 <- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
> x4 <- rbind(c(41,-41.5), c(51,-35), c(62,-41), c(51,-50))
> 
> a <- spLines(x1, x2, x3)
> b <- spLines(x1, list(x2, x3), attr=data.frame(id=1:2), crs='+proj=longlat +datum=WGS84')
> b
class       : SpatialLinesDataFrame 
features    : 2 
extent      : -180, 160, -60, 60  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
variables   : 1
names       : id 
min values  :  1 
max values  :  2 
> 
> hole <- rbind(c(-150,-20), c(-100,-10), c(-110,20))
> d <- spPolygons(list(x1,hole), x2, list(x3, x4))
> 
> att <- data.frame(ID=1:3, name=c('a', 'b', 'c'))
> e <- spPolygons(list(x1,hole), x2, list(x3, x4), attr=att, crs='+proj=longlat +datum=WGS84')
> e
class       : SpatialPolygonsDataFrame 
features    : 3 
extent      : -180, 160, -60, 60  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
variables   : 2
names       : ID, name 
min values  :  1,    a 
max values  :  3,    c 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spEasy", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spplot")
> ### * spplot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spplot
> ### Title: Use spplot to plot a Raster* object
> ### Aliases: spplot spplot,Raster-method spplot,SpatialPoints-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> s <- stack(r, r*2)
> names(s) <- c('meuse', 'meuse x 2')
> 
> spplot(s)
> 
> pts <- data.frame(sampleRandom(r, 10, xy=TRUE))
> coordinates(pts) <- ~ x + y
> 
> spplot(s, scales = list(draw = TRUE), 
+ 		xlab = "easting", ylab = "northing", 
+ 		col.regions = rainbow(99, start=.1), 
+ 		names.attr=c('original', 'times two'),
+ 		sp.layout = list("sp.points", pts, pch=20, cex=2, col='black'),
+ 		par.settings = list(fontsize = list(text = 12)), at = seq(0, 4000, 500))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spplot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stack")
> ### * stack
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stack
> ### Title: Create a RasterStack object
> ### Aliases: stack stack,character-method stack,Raster-method
> ###   stack,list-method stack,missing-method
> ###   stack,SpatialPixelsDataFrame-method stack,SpatialGridDataFrame-method
> ###   stack,kasc-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> # file with one layer
> fn <- system.file("external/test.grd", package="raster")
> s <- stack(fn, fn)
> r <- raster(fn)
> s <- stack(r, fn) 
> nlayers(s)
[1] 2
> 
> # file with three layers
> slogo <- stack(system.file("external/rlogo.grd", package="raster")) 
> nlayers(slogo)
[1] 3
> slogo
class       : RasterStack 
dimensions  : 77, 101, 7777, 3  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=merc +ellps=WGS84 
names       : red, green, blue 
min values  :   0,     0,    0 
max values  : 255,   255,  255 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stack", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stackApply")
> ### * stackApply
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stackApply
> ### Title: Apply a function on subsets of a RasterStack or RasterBrick
> ### Aliases: stackApply
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r[]=1:ncell(r)
> s <- brick(r,r,r,r,r,r)
> s <- s * 1:6
> b1 <- stackApply(s, indices=c(1,1,1,2,2,2), fun=sum)
> b1
class       : RasterBrick 
dimensions  : 10, 10, 100, 2  (nrow, ncol, ncell, nlayers)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer.1, layer.2 
min values  :       6,      15 
max values  :     600,    1500 

> b2 <- stackApply(s, indices=c(1,2,3,1,2,3), fun=sum)
> b2
class       : RasterBrick 
dimensions  : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer.1, layer.2, layer.3 
min values  :       5,       7,       9 
max values  :     500,     700,     900 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stackApply", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stackSelect")
> ### * stackSelect
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stackSelect
> ### Title: Select cell values from a multi-layer Raster* object
> ### Aliases: stackSelect stackSelect,RasterStackBrick,Raster-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r[] <- 1
> s <- stack(r, r+2, r+5)
> r[] <- round((runif(ncell(r)))*3)
> x <- stackSelect(s, r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stackSelect", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strech")
> ### * strech
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stretch
> ### Title: Stretch
> ### Aliases: stretch
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nc=10, nr=10)
> r[] <- 1:100 * 10
> stretch(r)
class       : RasterLayer 
dimensions  : 10, 10, 100  (nrow, ncol, ncell)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : 0, 255  (min, max)

> s <- stack(r, r*2)
> stretch(s)
class       : RasterBrick 
dimensions  : 10, 10, 100, 2  (nrow, ncol, ncell, nlayers)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : layer.1, layer.2 
min values  :       0,       0 
max values  :     255,     255 

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strech", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("subset")
> ### * subset
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: subset
> ### Title: Subset layers in a Raster* object
> ### Aliases: subset subset,Raster-method subset,RasterStack-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> s <- stack(system.file("external/rlogo.grd", package="raster"))
> sel <- subset(s, 2:3)
> 
> # Note that this is equivalent to
> sel2 <- s[[2:3]]
> 
> 
> # and in this particular case:
> sel3 <- dropLayer(s, 1)
> 
> nlayers(s)
[1] 3
> nlayers(sel)
[1] 2
> 
> # effect of 'drop=FALSE' when selecting a single layer
> sel <- subset(s, 2)
> class(sel)
[1] "RasterLayer"
attr(,"package")
[1] "raster"
> sel <- subset(s, 2, drop=FALSE)
> class(sel)
[1] "RasterStack"
attr(,"package")
[1] "raster"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("subset", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("substitute")
> ### * substitute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: substitute
> ### Title: Substitute values in a Raster* object
> ### Aliases: subs subs,Raster,data.frame-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r[] <- round(runif(ncell(r)) * 10)
> df <- data.frame(id=2:8, v=c(10,10,11,11,12:14))
> x <- subs(r, df)
> x2 <- subs(r, df, subsWithNA=FALSE)
> 
> df$v2 <- df$v * 10
> x3 <- subs(r, df, which=2:3)
> 
> s <- stack(r, r*3)
> names(s) <- c('first', 'second')
> x4 <- subs(s, df)
> x5 <- subs(s, df, which=2:3)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("substitute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("symdif")
> ### * symdif
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: symdif
> ### Title: Symetrical difference
> ### Aliases: symdif symdif,SpatialPolygons,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> #SpatialPolygons
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
+ 	projection(b) <- projection(p)
+ 	sd <- symdif(p, b)
+ 	plot(sd, col='red')
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("symdif", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("terrain")
> ### * terrain
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: terrain
> ### Title: Terrain characteristics
> ### Aliases: terrain
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D elevation <- getData('alt', country='CHE')
> ##D x <- terrain(elevation, opt=c('slope', 'aspect'), unit='degrees')
> ##D plot(x)
> ##D 
> ##D 
> ##D # TPI for different neighborhood size:
> ##D tpiw <- function(x, w=5) {
> ##D 	m <- matrix(1/(w^2-1), nc=w, nr=w)
> ##D 	m[ceiling(0.5 * length(m))] <- 0
> ##D 	f <- focal(x, m)
> ##D 	x - f
> ##D }
> ##D tpi5 <- tpiw(elevation, w=5)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("terrain", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("text")
> ### * text
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: text
> ### Title: Add labels to a map
> ### Aliases: text text,RasterLayer-method text,RasterStackBrick-method
> ###   text,SpatialPoints-method text,SpatialPolygons-method
> ### Keywords: methods spatial
> 
> ### ** Examples
>  
> r <- raster(nrows=4, ncols=4)
> r <- setValues(r, 1:ncell(r))
> plot(r)
> text(r)
> 
> plot(r, col=bpy.colors(5))
> text(r, fun=function(x){x<5 | x>12}, col=c('red', 'white'), vfont=c("sans serif", "bold"), cex=2)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("text", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("transpose")
> ### * transpose
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: transpose
> ### Title: Transpose
> ### Aliases: t t,RasterLayer-method t,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(nrow=18, ncol=36)
> r[] <- 1:ncell(r)
> rt <- t(r)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("transpose", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("trim")
> ### * trim
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: trim
> ### Title: Trim
> ### Aliases: trim trim,Raster-method trim,character-method
> ###   trim,matrix-method trim,data.frame-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=18,nrow=18)
> r[39:49] <- 1
> r[113:155] <- 2
> r[200] <- 6
> s <- trim(r) 
> 
> 
> trim("   hi folks   ")
[1] "hi folks"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("trim", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("union")
> ### * union
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: union
> ### Title: Union Extent or SpatialPolygons* objects
> ### Aliases: union union,Extent,Extent-method
> ###   union,SpatialPolygons,SpatialPolygons-method
> ###   union,SpatialPolygons,missing-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> e1 <- extent(-10, 10, -20, 20)
> e2 <- extent(0, 20, -40, 5)
> union(e1, e2)
class       : Extent 
xmin        : -10 
xmax        : 20 
ymin        : -40 
ymax        : 20 
> 
> #SpatialPolygons
> if (require(rgdal) & require(rgeos)) {
+ 	p <- shapefile(system.file("external/lux.shp", package="raster"))
+ 	p0 <- aggregate(p)
+ 	b <- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
+ 	projection(b) <- projection(p)
+ 	u <- union(p0, b)
+ 	plot(u, col=2:4)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
Loading required package: rgeos
rgeos version: 0.3-11, (SVN revision 479)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.1-0 
 Polygon checking: TRUE 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("union", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgeos’, ‘package:rgdal’

> nameEx("unique")
> ### * unique
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: unique
> ### Title: Unique values
> ### Aliases: unique unique,RasterLayer,missing-method
> ###   unique,RasterStackBrick,missing-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> r[] <- round(runif(ncell(r))*10)
> unique(r)
 [1]  0  1  2  3  4  5  6  7  8  9 10
> unique(stack(r, round(r/2)))
      layer.1 layer.2
 [1,]       3       2
 [2,]       4       2
 [3,]       6       3
 [4,]       9       4
 [5,]       2       1
 [6,]       7       4
 [7,]       1       0
 [8,]       8       4
 [9,]       5       2
[10,]      10       5
[11,]       0       0
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("unique", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("unstack")
> ### * unstack
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: unstack
> ### Title: Unstack
> ### Aliases: unstack unstack,RasterStack-method unstack,RasterBrick-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   file <- system.file("external/test.grd", package="raster")
>   s <- stack(file, file)
>   list1 <- unstack(s)
>   b <- brick(s)
>   list2 <- unstack(b)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("unstack", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("update")
> ### * update
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: update
> ### Title: Update raster cells of files (on disk)
> ### Aliases: update update,RasterLayer-method update,RasterBrick-method
> ### Keywords: methods spatial
> 
> ### ** Examples
> 
> # setting up an example RasterLayer with file
> r <- raster(nrow=5, ncol=10)
> r[] = 0
> r <- writeRaster(r, 'test', overwrite=TRUE, datatype='INT2S')
> as.matrix(r)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0    0    0    0    0    0    0    0    0     0
[2,]    0    0    0    0    0    0    0    0    0     0
[3,]    0    0    0    0    0    0    0    0    0     0
[4,]    0    0    0    0    0    0    0    0    0     0
[5,]    0    0    0    0    0    0    0    0    0     0
> 
> # update with a vector starting a cell
> r <- update(r, v=rep(1, 5), cell=6)
> # 99.99 gets rounded because this is an integer file
> r <- update(r, v=9.99, cell=50)
> as.matrix(r)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0    0    0    0    0    1    1    1    1     1
[2,]    0    0    0    0    0    0    0    0    0     0
[3,]    0    0    0    0    0    0    0    0    0     0
[4,]    0    0    0    0    0    0    0    0    0     0
[5,]    0    0    0    0    0    0    0    0    0    10
> 
> # update with a vector of values and matching vector of cell numbers
> r <- update(r, v=5:1, cell=c(5,15,25,35,45))
> as.matrix(r)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0    0    0    0    5    1    1    1    1     1
[2,]    0    0    0    0    4    0    0    0    0     0
[3,]    0    0    0    0    3    0    0    0    0     0
[4,]    0    0    0    0    2    0    0    0    0     0
[5,]    0    0    0    0    1    0    0    0    0    10
> 
> # updating with a marix, anchored at a cell number
> m = matrix(1:10, ncol=2)
> r <- update(r, v=m, cell=2)
> as.matrix(r)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0    1    6    0    5    1    1    1    1     1
[2,]    0    2    7    0    4    0    0    0    0     0
[3,]    0    3    8    0    3    0    0    0    0     0
[4,]    0    4    9    0    2    0    0    0    0     0
[5,]    0    5   10    0    1    0    0    0    0    10
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("update", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("validCell")
> ### * validCell
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: validCell
> ### Title: Validity of a cell, column or row number
> ### Aliases: validCell validCol validRow
> ### Keywords: spatial
> 
> ### ** Examples
> 
> #using a new default raster (1 degree global)
> r <- raster()
> validCell(r, c(-1, 0, 1))
[1] FALSE FALSE  TRUE
> validRow(r, c(-1, 1, 100, 10000))
[1] FALSE  TRUE  TRUE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("validCell", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("validNames")
> ### * validNames
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: validNames
> ### Title: Create valid names
> ### Aliases: validNames
> 
> ### ** Examples
> 
> validNames(c('a', 'a', '', '1', NA, 'b', 'a'))
[1] "a.1"     "a.2"     "layer.1" "X1"      "layer.2" "b"       "a.3"    
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("validNames", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("weighted.mean")
> ### * weighted.mean
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: weighted.mean
> ### Title: Weighted mean of rasters
> ### Aliases: weighted.mean weighted.mean,RasterStackBrick,vector-method
> ###   weighted.mean,RasterStackBrick,RasterStackBrick-method
> 
> ### ** Examples
> 
> b <- brick(system.file("external/rlogo.grd", package="raster"))
> 
> # give least weight to first layer, most to last layer
> wm1 <- weighted.mean(b, w=1:3)
> 
> # spatially varying weights
> # weigh by column number
> w1 <- init(b, v='col')
> 
> # weigh by row number
> w2 <- init(b, v='row')
> w <- stack(w1, w2, w2)
> 
> wm2 <- weighted.mean(b, w=w)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("weighted.mean", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("which")
> ### * which
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: which
> ### Title: Which cells are TRUE?
> ### Aliases: Which Which,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> set.seed(0)
> r[] <- runif(ncell(r))
> r[r < 0.2 ] <- 0
> r[r > 0.8] <- 1
> r[r > 0 & r < 1 ] <- 0.5
> 
> Which(r, cells=TRUE)
 [1]   1   2   3   4   5   6   7   8   9  10  12  14  15  16  17  18  19  20  21
[20]  22  23  24  26  27  29  30  31  32  33  34  36  37  38  40  41  42  43  44
[39]  45  46  47  49  50  51  52  53  54  55  58  59  60  61  62  63  64  65  66
[58]  67  68  69  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86
[77]  87  88  90  92  94  95  96  97  98  99 100
> Which(r > 0.5, cells=TRUE)
 [1]   1   5   7   8  19  22  30  36  42  53  62  71  73  77  78  81  95 100
> 
> s1 <- r > 0.5
> s2 <- Which(r > 0.5)
> s1[1:15]
 [1] 1 0 0 0 1 0 1 1 0 0 0 0 0 0 0
> s2[1:15]
 [1] 1 0 0 0 1 0 1 1 0 0 0 0 0 0 0
> 
> # this expression
> x1 <- Which(r, na.rm=FALSE)
> # is the inverse of
> x2 <- r==0
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("which", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("which.minmax")
> ### * which.minmax
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: which.min
> ### Title: Where is the min or max value?
> ### Aliases: which.min which.max which.min,RasterLayer-method
> ###   which.max,RasterLayer-method which.min,RasterStackBrick-method
> ###   which.max,RasterStackBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D b <- brick(system.file("external/rlogo.grd", package="raster")) 
> ##D 
> ##D r <- which.min(b)
> ##D 
> ##D i <- which.min(b[[3]])
> ##D xy <- xyFromCell(b, i)
> ##D plot(b[[3]])
> ##D points(xy)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("which.minmax", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("writeFormats")
> ### * writeFormats
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: writeFormats
> ### Title: File types for writing
> ### Aliases: writeFormats
> ### Keywords: spatial
> 
> ### ** Examples
>  
> writeFormats() 
      name        long_name                                
 [1,] "raster"    "R-raster"                               
 [2,] "SAGA"      "SAGA GIS"                               
 [3,] "IDRISI"    "IDRISI"                                 
 [4,] "IDRISIold" "IDRISI (img/doc)"                       
 [5,] "BIL"       "Band by Line"                           
 [6,] "BSQ"       "Band Sequential"                        
 [7,] "BIP"       "Band by Pixel"                          
 [8,] "ascii"     "Arc ASCII"                              
 [9,] "CDF"       "NetCDF"                                 
[10,] "big"       "big.matrix"                             
[11,] "ADRG"      "ARC Digitized Raster Graphics"          
[12,] "BMP"       "MS Windows Device Independent Bitmap"   
[13,] "BT"        "VTP .bt (Binary Terrain) 1.3 Format"    
[14,] "CTable2"   "CTable2 Datum Grid Shift"               
[15,] "EHdr"      "ESRI .hdr Labelled"                     
[16,] "ELAS"      "ELAS"                                   
[17,] "ENVI"      "ENVI .hdr Labelled"                     
[18,] "ERS"       "ERMapper .ers Labelled"                 
[19,] "GS7BG"     "Golden Software 7 Binary Grid (.grd)"   
[20,] "GSBG"      "Golden Software Binary Grid (.grd)"     
[21,] "GTX"       "NOAA Vertical Datum .GTX"               
[22,] "GTiff"     "GeoTIFF"                                
[23,] "HFA"       "Erdas Imagine Images (.img)"            
[24,] "IDA"       "Image Data and Analysis"                
[25,] "ILWIS"     "ILWIS Raster Map"                       
[26,] "INGR"      "Intergraph Raster"                      
[27,] "ISIS2"     "USGS Astrogeology ISIS cube (Version 2)"
[28,] "KRO"       "KOLOR Raw"                              
[29,] "LAN"       "Erdas .LAN/.GIS"                        
[30,] "Leveller"  "Leveller heightfield"                   
[31,] "NITF"      "National Imagery Transmission Format"   
[32,] "NTv2"      "NTv2 Datum Grid Shift"                  
[33,] "PAux"      "PCI .aux Labelled"                      
[34,] "PCIDSK"    "PCIDSK Database File"                   
[35,] "PNM"       "Portable Pixmap Format (netpbm)"        
[36,] "RMF"       "Raster Matrix Format"                   
[37,] "RST"       "Idrisi Raster A.1"                      
[38,] "SAGA"      "SAGA GIS Binary Grid (.sdat)"           
[39,] "SGI"       "SGI Image File Format 1.0"              
[40,] "Terragen"  "Terragen heightfield"                   
[41,] "netCDF"    "Network Common Data Format"             
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("writeFormats", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("writeRaster")
> ### * writeRaster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: writeRaster
> ### Title: Write raster data to a file
> ### Aliases: writeRaster,RasterLayer,character-method
> ###   writeRaster,RasterStackBrick,character-method writeRaster
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> r <- raster(system.file("external/test.grd", package="raster"))
> 
> # take a small part
> r <- crop(r, extent(179880, 180800, 329880, 330840) )
> 
> # write to an integer binary file
> rf <- writeRaster(r, filename="allint.grd", datatype='INT4S', overwrite=TRUE)
> 
> # make a brick and save multi-layer file
> b <- brick(r, sqrt(r))
> bf <- writeRaster(b, filename="multi.grd", bandorder='BIL', overwrite=TRUE)
> 
> # write to a new geotiff file (depends on rgdal)
> if (require(rgdal)) {
+   rf <- writeRaster(r, filename="test.tif", format="GTiff", overwrite=TRUE)
+   bf <- writeRaster(b, filename="multi.tif", options="INTERLEAVE=BAND", overwrite=TRUE)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
>  
> # write to netcdf 
> if (require(ncdf)) {	
+  rnc <- writeRaster(r, filename='netCDF.nc', format="CDF", overwrite=TRUE)   
+ }
Loading required package: ncdf
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("writeRaster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ncdf’, ‘package:rgdal’

> nameEx("writeValues")
> ### * writeValues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: writeValues
> ### Title: Write values to a file
> ### Aliases: writeStart writeStart,RasterLayer,character-method
> ###   writeStart,RasterBrick,character-method writeStop
> ###   writeStop,RasterLayer-method writeStop,RasterBrick-method writeValues
> ###   writeValues,RasterLayer,vector-method
> ###   writeValues,RasterBrick,matrix-method
> ### Keywords: spatial methods
> 
> ### ** Examples
>  
> 
> r <- raster(system.file("external/test.grd", package="raster"))
> # write to a new binary file in chunks
> s <- raster(r)
> # 
> tr <- blockSize(r)
> tr
$row
[1]  1 30 59 88

$nrows
[1] 29 29 29 28

$n
[1] 4

> s <- writeStart(s, filename='test.grd',  overwrite=TRUE)
> for (i in 1:tr$n) {
+ 	v <- getValuesBlock(r, row=tr$row[i], nrows=tr$nrows[i])
+ 	s <- writeValues(s, v, tr$row[i])
+ }
> s <- writeStop(s)
> 
> if(require(rgdal)){
+ s2 <- writeStart(s, filename='test2.tif', format='GTiff', overwrite=TRUE)
+ # writing last row first
+ for (i in tr$n:1) {
+ 	v <- getValuesBlock(r, row=tr$row[i], nrows=tr$nrows[i])
+ 	s2 <- writeValues(s2, v, tr$row[i])
+ }
+ # row number 5 once more
+ v <- getValuesBlock(r, row=5, nrows=1)
+ writeValues(s2, v, 5)
+ s2 <- writeStop(s2)
+ }
Loading required package: rgdal
rgdal: version: 0.9-3, (SVN revision 530)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.11.2, released 2015/02/10
 Path to GDAL shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.1, 04 March 2015, [PJ_VERSION: 491]
 Path to PROJ.4 shared files: /Users/gaborcsardi/works/igraph/revdep_lib/rgdal/proj
 Linking to sp version: 1.1-0 
> 
> ## write values of a RasterStack to a RasterBrick
> s <- stack(system.file("external/rlogo.grd", package="raster"))
> # create empty brick
> b <- brick(s, values=FALSE)  
> b <- writeStart(b, filename="test.grd", format="raster",overwrite=TRUE)
> tr <- blockSize(b)
> for (i in 1:tr$n) {
+ 	v <- getValuesBlock(s, row=tr$row[i], nrows=tr$nrows[i])
+ 	b <- writeValues(b, v, tr$row[i])
+ }
> b <- writeStop(b)
> # note that the above is equivalent to 
> # b <- writeRaster(s, filename="test.grd", format="raster",overwrite=TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("writeValues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’

> nameEx("xyFromCell")
> ### * xyFromCell
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: xyFromCell
> ### Title: Coordinates from a row, column or cell number
> ### Aliases: xFromCol yFromRow xyFromCell xFromCell yFromCell
> ### Keywords: spatial
> 
> ### ** Examples
> 
> #using a new default raster (1 degree global)
> r <- raster()
> xFromCol(r, c(1, 120, 180))
[1] -179.5  -60.5   -0.5
> yFromRow(r, 90)
[1] 0.5
> xyFromCell(r, 10000)
        x    y
[1,] 99.5 62.5
> xyFromCell(r, c(0, 1, 32581, ncell(r), ncell(r)+1))
          x     y
[1,]     NA    NA
[2,] -179.5  89.5
[3,]    0.5  -0.5
[4,]  179.5 -89.5
[5,]     NA    NA
> 
> #using a file from disk
> r <- raster(system.file("external/test.grd", package="raster"))
> r
class       : RasterLayer 
dimensions  : 115, 80, 9200  (nrow, ncol, ncell)
resolution  : 40, 40  (x, y)
extent      : 178400, 181600, 329400, 334000  (xmin, xmax, ymin, ymax)
coord. ref. : +init=epsg:28992 +towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs 
data source : /Users/gaborcsardi/works/igraph/revdep_check/raster.Rcheck/raster/external/test.grd 
names       : test 
values      : 128.434, 1805.78  (min, max)

> cellFromXY(r, c(180000, 330000))
[1] 8041
> #xy for corners of a raster:
> xyFromCell(r, c(1, ncol(r), ncell(r)-ncol(r)+1, ncell(r)))
          x      y
[1,] 178420 333980
[2,] 181580 333980
[3,] 178420 329420
[4,] 181580 329420
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("xyFromCell", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("zApply")
> ### * zApply
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: zApply
> ### Title: z (time) apply
> ### Aliases: zApply
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # 12 values of irradiation, 1 for each month
> G0dm=c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179)*1000;
> # RasterBrick with 12 layers based on G0dm + noise
> r <- raster(nc=10, nr=10)
> s <- brick(lapply(1:12, function(x) setValues(r, G0dm[x]+100*rnorm(ncell(r)) )))
> 
> # time
> tm <- seq(as.Date('2010-01-15'), as.Date('2010-12-15'), 'month')
> s <- setZ(s, tm, 'months')
> 
> # library(zoo)
> # x <- zApply(s, by=as.yearqtr, fun=mean, name='quarters')
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("zApply", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("zonal")
> ### * zonal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: zonal
> ### Title: Zonal statistics
> ### Aliases: zonal zonal,RasterLayer,RasterLayer-method
> ###   zonal,RasterStackBrick,RasterLayer-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncols=10, nrows=10)
> r[] <- runif(ncell(r)) * 1:ncell(r)
> z <- r
> z[] <- rep(1:5, each=20)
> # for big files, use a character value rather than a function
> zonal(r, z, 'sum')
     zone      sum
[1,]    1 121.9663
[2,]    2 293.4533
[3,]    3 500.1199
[4,]    4 807.9618
[5,]    5 888.2572
> 
> # for smaller files you can also provide a function
> ## Not run: 
> ##D zonal(r, z, mean)
> ##D zonal(r, z, min)
> ## End(Not run)
> 
> # multiple layers
> zonal(stack(r, r*10), z, 'sum')
     zone  layer.1  layer.2
[1,]    1 121.9663 1219.663
[2,]    2 293.4533 2934.533
[3,]    3 500.1199 5001.199
[4,]    4 807.9618 8079.618
[5,]    5 888.2572 8882.572
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("zonal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("zvalues")
> ### * zvalues
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: z-values
> ### Title: Get or set z-values
> ### Aliases: getZ setZ
> ### Keywords: spatial
> 
> ### ** Examples
> 
> r <- raster(ncol=10, nrow=10)
> s <- stack(lapply(1:3, function(x) setValues(r, runif(ncell(r)))))
> s <- setZ(s, as.Date('2000-1-1') + 0:2)
> s
class       : RasterStack 
dimensions  : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)
resolution  : 36, 18  (x, y)
extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
names       :    layer.1,    layer.2,    layer.3 
min values  : 0.01339033, 0.01307758, 0.02778712 
max values  :  0.9919061,  0.9926841,  0.9815635 
time        : 2000-01-01, 2000-01-02, 2000-01-03 

> getZ(s)
[1] "2000-01-01" "2000-01-02" "2000-01-03"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("zvalues", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  15.663 0.297 16.808 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
